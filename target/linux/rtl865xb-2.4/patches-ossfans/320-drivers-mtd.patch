Index: linux-2.4.27/drivers/mtd/Config.in
===================================================================
--- linux-2.4.27.orig/drivers/mtd/Config.in	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/Config.in	2008-03-22 11:19:20.000000000 +0300
@@ -1,5 +1,5 @@
 
-# $Id: Config.in,v 1.74 2002/04/23 13:52:14 mag Exp $
+# $Id: Config.in,v 1.1.1.1 2004/08/20 11:30:49 r04482 Exp $
 
 mainmenu_option next_comment
 comment 'Memory Technology Devices (MTD)'
@@ -14,6 +14,9 @@
    dep_tristate '  MTD partitioning support' CONFIG_MTD_PARTITIONS $CONFIG_MTD
    dep_tristate '  MTD concatenating support' CONFIG_MTD_CONCAT $CONFIG_MTD
    dep_tristate '  RedBoot partition table parsing' CONFIG_MTD_REDBOOT_PARTS $CONFIG_MTD_PARTITIONS
+   if [ "$CONFIG_MTD_REDBOOT_PARTS" = "y" ]; then
+      dep_bool '  Include unallocated flash space' CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED $CONFIG_MTD_REDBOOT_PARTS
+   fi
    dep_tristate '  Command line partition table parsing' CONFIG_MTD_CMDLINE_PARTS $CONFIG_MTD_PARTITIONS
    if [ "$CONFIG_ARM" = "y" ]; then
       dep_tristate '  ARM Firmware Suite partition parsing' CONFIG_MTD_AFS_PARTS $CONFIG_MTD_PARTITIONS
@@ -27,6 +30,7 @@
    fi
    dep_tristate '  FTL (Flash Translation Layer) support' CONFIG_FTL $CONFIG_MTD
    dep_tristate '  NFTL (NAND Flash Translation Layer) support' CONFIG_NFTL $CONFIG_MTD
+   dep_tristate '  INFTL (Inverse NAND Flash Translation Layer) support' CONFIG_INFTL $CONFIG_MTD
    if [ "$CONFIG_NFTL" = "y" -o "$CONFIG_NFTL" = "m" ]; then
       bool '    Write support for NFTL (BETA)' CONFIG_NFTL_RW
    fi
Index: linux-2.4.27/drivers/mtd/Makefile
===================================================================
--- linux-2.4.27.orig/drivers/mtd/Makefile	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/Makefile	2008-03-22 11:19:20.000000000 +0300
@@ -8,7 +8,7 @@
 # Note 2! The CFLAGS definitions are now inherited from the
 # parent makes..
 #
-# $Id: Makefile,v 1.65 2002/03/22 07:10:34 dwmw2 Exp $
+# $Id: Makefile,v 1.1.1.1 2004/08/20 11:30:49 r04482 Exp $
 
 
 obj-y           += chips/chipslink.o maps/mapslink.o \
@@ -20,7 +20,7 @@
 O_TARGET	:= mtdlink.o
 
 export-objs	:= mtdcore.o mtdpart.o redboot.o cmdlinepart.o afs.o mtdconcat.o
-list-multi	:= nftl.o
+list-multi	:= nftl.o inftl.o
 
 mod-subdirs	:= 
 subdir-y	:= chips maps devices nand
@@ -49,6 +49,7 @@
 obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
 obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
 obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
+obj-$(CONFIG_MTD_CMDLINE_PARTS)	+= cmdlinepart.o
 
 # 'Users' - code which presents functionality to userspace.
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
@@ -56,11 +57,16 @@
 obj-$(CONFIG_MTD_BLOCK_RO)	+= mtdblock_ro.o
 obj-$(CONFIG_FTL)		+= ftl.o
 obj-$(CONFIG_NFTL)		+= nftl.o
+obj-$(CONFIG_INFTL)		+= inftl.o
 
 nftl-objs	:= nftlcore.o nftlmount.o
+inftl-objs	:= inftlcore.o inftlmount.o
 
 include $(TOPDIR)/Rules.make
 
 nftl.o: $(nftl-objs)
 	$(LD) -r -o $@ $(nftl-objs)
 
+inftl.o: $(inftl-objs)
+	$(LD) -r -o $@ $(inftl-objs)
+
Index: linux-2.4.27/drivers/mtd/bootldr.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/bootldr.c	2008-03-22 11:19:20.000000000 +0300
@@ -0,0 +1,214 @@
+/*
+ * Read flash partition table from Compaq Bootloader
+ *
+ * Copyright 2001 Compaq Computer Corporation.
+ *
+ * $Id$
+ *
+ * Use consistent with the GNU GPL is permitted,
+ * provided that this copyright notice is
+ * preserved in its entirety in all copies and derived works.
+ *
+ * COMPAQ COMPUTER CORPORATION MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
+ * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
+ * FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ */
+
+/*
+ * Maintainer: Jamey Hicks (jamey.hicks@compaq.com)
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <asm/setup.h>
+#include <linux/bootmem.h>
+
+#define FLASH_PARTITION_NAMELEN 32
+enum LFR_FLAGS {
+   LFR_SIZE_PREFIX = 1,		/* prefix data with 4-byte size */
+   LFR_PATCH_BOOTLDR = 2,	/* patch bootloader's 0th instruction */
+   LFR_KERNEL = 4,		/* add BOOTIMG_MAGIC, imgsize and VKERNEL_BASE to head of programmed region (see bootldr.c) */
+   LFR_EXPAND = 8               /* expand partition size to fit rest of flash */
+};
+
+// the tags are parsed too early to malloc or alloc_bootmem so we'll fix it
+// for now
+#define MAX_NUM_PARTITIONS 8
+typedef struct FlashRegion {
+   char name[FLASH_PARTITION_NAMELEN];
+   unsigned long base;
+   unsigned long size;
+   enum LFR_FLAGS flags;
+} FlashRegion;
+
+typedef struct BootldrFlashPartitionTable {
+  int magic; /* should be filled with 0x646c7470 (btlp) BOOTLDR_PARTITION_MAGIC */
+  int npartitions;
+  struct FlashRegion partition[8];
+} BootldrFlashPartitionTable;
+
+#define BOOTLDR_MAGIC      0x646c7462        /* btld: marks a valid bootldr image */
+#define BOOTLDR_PARTITION_MAGIC  0x646c7470  /* btlp: marks a valid bootldr partition table in params sector */
+
+#define BOOTLDR_MAGIC_OFFSET 0x20 /* offset 0x20 into the bootldr */
+#define BOOTCAP_OFFSET 0X30 /* offset 0x30 into the bootldr */
+
+#define BOOTCAP_WAKEUP	(1<<0)
+#define BOOTCAP_PARTITIONS (1<<1) /* partition table stored in params sector */
+#define BOOTCAP_PARAMS_AFTER_BOOTLDR (1<<2) /* params sector right after bootldr sector(s), else in last sector */
+
+static struct BootldrFlashPartitionTable Table;
+static struct BootldrFlashPartitionTable *partition_table = NULL;
+
+
+int parse_bootldr_partitions(struct mtd_info *master, struct mtd_partition **pparts)
+{
+	struct mtd_partition *parts;
+	int ret, retlen, i;
+	int npartitions = 0;
+	long partition_table_offset;
+	long bootmagic = 0;
+	long bootcap = 0;
+	int namelen = 0;
+
+	char *names; 
+
+#if 0
+	/* verify bootldr magic */
+	ret = master->read(master, BOOTLDR_MAGIC_OFFSET, sizeof(long), &retlen, (void *)&bootmagic);
+	if (ret) 
+		goto out;
+        if (bootmagic != BOOTLDR_MAGIC)
+                goto out;
+	/* see if bootldr supports partition tables and where to find the partition table */
+	ret = master->read(master, BOOTCAP_OFFSET, sizeof(long), &retlen, (void *)&bootcap);
+	if (ret) 
+		goto out;
+
+	if (!(bootcap & BOOTCAP_PARTITIONS))
+		goto out;
+	if (bootcap & BOOTCAP_PARAMS_AFTER_BOOTLDR)
+		partition_table_offset = master->erasesize;
+	else
+		partition_table_offset = master->size - master->erasesize;
+
+	printk(__FUNCTION__ ": partition_table_offset=%#lx\n", partition_table_offset);
+	printk(__FUNCTION__ ": ptable_addr=%#lx\n", ptable_addr);
+
+
+	/* Read the partition table */
+	partition_table = (struct BootldrFlashPartitionTable *)kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!partition_table)
+		return -ENOMEM;
+
+	ret = master->read(master, partition_table_offset,
+			   PAGE_SIZE, &retlen, (void *)partition_table);
+	if (ret)
+	    goto out;
+
+#endif
+	if (!partition_table)
+	    return -ENOMEM;
+
+	
+	printk(__FUNCTION__ ": magic=%#x\n", partition_table->magic);
+	printk(__FUNCTION__ ": numPartitions=%#x\n", partition_table->npartitions);
+
+
+	/* check for partition table magic number */
+	if (partition_table->magic != BOOTLDR_PARTITION_MAGIC) 
+		goto out;
+	npartitions = (partition_table->npartitions > MAX_NUM_PARTITIONS)?
+	    MAX_NUM_PARTITIONS:partition_table->npartitions;	
+
+	printk(__FUNCTION__ ": npartitions=%#x\n", npartitions);
+
+	for (i = 0; i < npartitions; i++) {
+		namelen += strlen(partition_table->partition[i].name) + 1;
+	}
+
+	parts = kmalloc(sizeof(*parts)*npartitions + namelen, GFP_KERNEL);
+	if (!parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	names = (char *)&parts[npartitions];
+	memset(parts, 0, sizeof(*parts)*npartitions + namelen);
+
+
+
+	// from here we use the partition table
+	for (i = 0; i < npartitions; i++) {
+                struct FlashRegion *partition = &partition_table->partition[i];
+		const char *name = partition->name;
+		parts[i].name = names;
+		names += strlen(name) + 1;
+		strcpy(parts[i].name, name);
+
+                if (partition->flags & LFR_EXPAND)
+                        parts[i].size = MTDPART_SIZ_FULL;
+                else
+                        parts[i].size = partition->size;
+		parts[i].offset = partition->base;
+		parts[i].mask_flags = 0;
+		
+		printk("        partition %s o=%x s=%x\n", 
+		       parts[i].name, parts[i].offset, parts[i].size);
+
+	}
+
+	ret = npartitions;
+	*pparts = parts;
+
+ out:
+#if 0
+	if (partition_table)
+		kfree(partition_table);
+#endif
+	
+	return ret;
+}
+
+
+static int __init parse_tag_ptable(const struct tag *tag)
+{
+    char buf[128];
+    int i;
+    int j;
+    
+    partition_table = &Table;
+
+#ifdef CONFIG_DEBUG_LL    
+    sprintf(buf,"ptable: magic = = 0x%lx  npartitions= %d \n",
+	    tag->u.ptable.magic,tag->u.ptable.npartitions);
+    printascii(buf);
+    
+    for (i=0; i<tag->u.ptable.npartitions; i++){
+	sprintf(buf,"ptable: partition name = %s base= 0x%lx  size= 0x%lx flags= 0x%lx\n",
+	    (char *) (&tag->u.ptable.partition[i].name[0]),
+		tag->u.ptable.partition[i].base,
+		tag->u.ptable.partition[i].size,
+		tag->u.ptable.partition[i].flags);
+	printascii(buf);
+    }
+#endif
+
+    memcpy((void *)partition_table,(void *) (&(tag->u.ptable)),sizeof(partition_table) +
+	sizeof(struct FlashRegion)*tag->u.ptable.npartitions);
+
+    
+    return 0;
+}
+
+__tagtable(ATAG_PTABLE, parse_tag_ptable);
+
+EXPORT_SYMBOL(parse_bootldr_partitions);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Compaq Computer Corporation");
+MODULE_DESCRIPTION("Parsing code for Compaq bootldr partitions");
Index: linux-2.4.27/drivers/mtd/chips/amd_flash.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/chips/amd_flash.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/chips/amd_flash.c	2008-03-22 11:19:20.000000000 +0300
@@ -67,6 +67,8 @@
 #define AM29LV160DB	0x2249
 #define AM29BDS323D     0x22D1
 #define AM29BDS643D	0x227E
+#define AM29LV004T	0x00B5
+#define AM29LV004B	0x00B6
 
 /* Atmel */
 #define AT49xV16x	0x00C0
@@ -430,6 +432,30 @@
 	const struct amd_flash_info table[] = {
 	{
 		mfr_id: MANUFACTURER_AMD,
+                dev_id: AM29LV004T,
+                name: "AMD AM29LV004T",
+                size: 0x00080000,
+                numeraseregions: 4,
+                regions: {
+                        { offset: 0x000000, erasesize: 0x10000, numblocks:  7 },
+                        { offset: 0x070000, erasesize: 0x08000, numblocks:  1 },
+                        { offset: 0x078000, erasesize: 0x02000, numblocks:  2 },
+                        { offset: 0x07C000, erasesize: 0x04000, numblocks:  1 }
+                }
+        }, {
+                mfr_id: MANUFACTURER_AMD,
+                dev_id: AM29LV004B,
+                name: "AMD AM29LV004B",
+                size: 0x00080000,
+                numeraseregions: 4,
+                regions: {
+                        { offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+                        { offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+                        { offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+                        { offset: 0x010000, erasesize: 0x10000, numblocks:  7 }
+                }
+        }, {
+		mfr_id: MANUFACTURER_AMD,
 		dev_id: AM29LV160DT,
 		name: "AMD AM29LV160DT",
 		size: 0x00200000,
Index: linux-2.4.27/drivers/mtd/chips/cfi_cmdset_0002.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/chips/cfi_cmdset_0002.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/chips/cfi_cmdset_0002.c	2008-03-22 11:19:21.000000000 +0300
@@ -18,6 +18,7 @@
 #include <linux/sched.h>
 #include <asm/io.h>
 #include <asm/byteorder.h>
+#include <asm/unaligned.h>
 
 #include <linux/errno.h>
 #include <linux/slab.h>
@@ -511,13 +512,18 @@
 	   or tells us why it failed. */        
 	dq6 = CMD(1<<6);
 	dq5 = CMD(1<<5);
-	timeo = jiffies + (HZ/1000); /* setting timeout to 1ms for now */
+	timeo = jiffies + HZ; /* setting timeout to 1s for safety */
 		
 	oldstatus = cfi_read(map, adr);
 	status = cfi_read(map, adr);
 
-	while( (status & dq6) != (oldstatus & dq6) && 
-	       (status & dq5) != dq5 &&
+	/*
+	 * some toshiba flash acts weird with the toggle bits, so
+	 * we check the datum as well
+	 */
+	while( (status != datum ||
+	           ((status & dq6) != (oldstatus & dq6) && 
+	           (status & dq5) != dq5)) &&
 	       !time_after(jiffies, timeo) ) {
 
 		if (need_resched()) {
@@ -541,7 +547,9 @@
 			status = cfi_read(map, adr);
 		    
 			if ( (oldstatus & 0x00FF) == (status & 0x00FF) ) {
+#ifndef CONFIG_MTD_SNAPGEODE
 				printk(KERN_WARNING "Warning: DQ5 raised while program operation was in progress, however operation completed OK\n" );
+#endif
 			} else { 
 				/* DQ5 is active so we can do a reset and stop the erase */
 				cfi_write(map, CMD(0xF0), chip->start);
@@ -633,9 +641,9 @@
 		if (cfi_buswidth_is_1()) {
 			datum = *(__u8*)buf;
 		} else if (cfi_buswidth_is_2()) {
-			datum = *(__u16*)buf;
+			datum = get_unaligned((__u16*)buf);
 		} else if (cfi_buswidth_is_4()) {
-			datum = *(__u32*)buf;
+			datum = get_unaligned((__u32*)buf);
 		} else {
 			return -EINVAL;
 		}
Index: linux-2.4.27/drivers/mtd/chips/jedec_probe.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/chips/jedec_probe.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/chips/jedec_probe.c	2008-03-22 11:19:21.000000000 +0300
@@ -44,6 +44,10 @@
 #define AM29F040	0x00A4
 #define AM29LV040B	0x004F
 #define AM29F032B	0x0041
+#define AM29LV004T	0x00B5
+#define AM29LV004B	0x00B6
+#define AM29LV320DT	0x22F6
+#define AM29LV320DB	0x22F9
 
 /* Atmel */
 #define AT49BV512	0x0003
@@ -110,6 +114,7 @@
 #define SST39LF040	0x00D7
 #define SST39SF010A	0x00B5
 #define SST39SF020A	0x00B6
+#define SST49LF020A	0x0061
 #define SST49LF030A	0x001C
 #define SST49LF040A	0x0051
 #define SST49LF080A	0x005B
@@ -126,6 +131,7 @@
 struct amd_flash_info {
 	const __u16 mfr_id;
 	const __u16 dev_id;
+	const __u16 extra_id;
 	const char *name;
 	const int DevSize;
 	const int InterfaceDesc;
@@ -148,6 +154,30 @@
 static const struct amd_flash_info jedec_table[] = {
 	{
 		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV004T,
+		name: "AMD AM29LV004T",
+		DevSize: SIZE_512KiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x10000,7),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x04000,1)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV004B,
+		name: "AMD AM29LV004B",
+		DevSize: SIZE_512KiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 4,
+		regions: {ERASEINFO(0x04000,1),
+			  ERASEINFO(0x02000,2),
+			  ERASEINFO(0x08000,1),
+			  ERASEINFO(0x10000,7)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
 		dev_id: AM29F032B,
 		name: "AMD AM29F032B",
 		DevSize: SIZE_4MiB,
@@ -157,6 +187,26 @@
 		}
 	}, {
 		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV320DT,
+		name: "AMD AM29LV320DT",
+		DevSize: SIZE_4MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 2,
+		regions: {ERASEINFO(0x02000,8),
+			  ERASEINFO(0x10000,63)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV320DB,
+		name: "AMD AM29LV320DB",
+		DevSize: SIZE_4MiB,
+		CmdSet:	P_ID_AMD_STD,
+		NumEraseRegions: 2,
+		regions: {ERASEINFO(0x10000,63),
+			  ERASEINFO(0x02000,8)
+		}
+	}, {
+		mfr_id: MANUFACTURER_AMD,
 		dev_id: AM29LV160DT,
 		name: "AMD AM29LV160DT",
 		DevSize: SIZE_2MiB,
@@ -671,6 +721,7 @@
 	}, {
 		mfr_id: MANUFACTURER_ATMEL,
 		dev_id: AT49BV16X,
+		extra_id: 8,			/* always place before devices with undefined extra_id !! */
 		name: "Atmel AT49BV16X",
 		DevSize: SIZE_2MiB,
 		CmdSet: P_ID_AMD_STD,
@@ -681,6 +732,7 @@
 	}, {
 		mfr_id: MANUFACTURER_ATMEL,
 		dev_id: AT49BV16XT,
+		extra_id: 8,			/* always place before devices with undefined extra_id !! */
 		name: "Atmel AT49BV16XT",
 		DevSize: SIZE_2MiB,
 		CmdSet: P_ID_AMD_STD,
@@ -688,6 +740,50 @@
 		regions: {ERASEINFO(0x10000,31),
 			  ERASEINFO(0x02000,8)
 		}
+        }, {
+                mfr_id: MANUFACTURER_ATMEL,
+                dev_id: AT49BV16X,
+                extra_id: 0xc8,                 /* always place before devices with undefined extra_id !! */
+                name: "Atmel AT49BV16X4A",
+                DevSize: SIZE_2MiB,
+                CmdSet: P_ID_AMD_STD,
+                NumEraseRegions: 2,
+                regions: {ERASEINFO(0x02000,8),
+                          ERASEINFO(0x10000,31)
+                }
+        }, {
+                mfr_id: MANUFACTURER_ATMEL,
+                dev_id: AT49BV16XT,
+                extra_id: 0xc8,                 /* always place before devices with undefined extra_id !! */
+                name: "Atmel AT49BV16X4AT",
+                DevSize: SIZE_2MiB,
+                CmdSet: P_ID_AMD_STD,
+                NumEraseRegions: 2,
+                regions: {ERASEINFO(0x10000,31),
+                          ERASEINFO(0x02000,8)
+                }
+	}, {
+		mfr_id: MANUFACTURER_ATMEL,
+		dev_id: AT49BV16X,
+		name: "Atmel AT49BV16X4",
+		DevSize: SIZE_2MiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 3,
+		regions: {ERASEINFO(0x02000,8),
+			  ERASEINFO(0x08000,2),
+			  ERASEINFO(0x10000,30)
+		}
+	}, {
+                mfr_id: MANUFACTURER_ATMEL,
+                dev_id: AT49BV16XT,
+                name: "Atmel AT49BV16X4T",
+                DevSize: SIZE_2MiB,
+		CmdSet: P_ID_AMD_STD,
+                NumEraseRegions: 3,
+                regions: {ERASEINFO(0x10000,30),
+                          ERASEINFO(0x08000,2),
+			  ERASEINFO(0x02000,8)
+                }
 	}, {
 		mfr_id: MANUFACTURER_ATMEL,
 		dev_id: AT49BV32X,
@@ -875,6 +971,15 @@
 		}
 	}, {
 		mfr_id: MANUFACTURER_SST,
+		dev_id: SST49LF020A,
+		name: "SST 49LF020A",
+		DevSize: SIZE_256KiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x01000,64),
+		}
+	}, {
+		mfr_id: MANUFACTURER_SST,
 		dev_id: SST49LF030A,
 		name: "SST 49LF030A",
 		DevSize: SIZE_512KiB,
@@ -900,7 +1005,18 @@
 		NumEraseRegions: 1,
 		regions: {ERASEINFO(0x01000,256),
 		}
-	} 
+	}, {
+		mfr_id: MANUFACTURER_SST,
+		dev_id: SST39LF160,
+		name: "SST 39LF/VF160",
+		DevSize: SIZE_2MiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 2,
+    /* Split into two regions to get around the 256-region restriction */
+		regions: {ERASEINFO(0x01000,256),
+			  ERASEINFO(0x01000,256),
+		}
+ }
 };
 
 
@@ -911,22 +1027,16 @@
 
 struct mtd_info *jedec_probe(struct map_info *map);
 
-static inline u32 jedec_read_mfr(struct map_info *map, __u32 base, 
-	struct cfi_private *cfi)
-{
-	u32 result, mask;
-	mask = (1 << (cfi->device_type * 8)) -1;
-	result = cfi_read(map, base);
-	result &= mask;
-	return result;
-}
+#define MFR_ID 0
+#define DEV_ID 1
+#define EXTRA_ID 3
 
 static inline u32 jedec_read_id(struct map_info *map, __u32 base, 
-	struct cfi_private *cfi)
+	struct cfi_private *cfi,int addr)
 {
 	int osf;
 	u32 result, mask;
-	osf = cfi->interleave *cfi->device_type;
+	osf = cfi->interleave *cfi->device_type * addr;
 	mask = (1 << (cfi->device_type * 8)) -1;
 	result = cfi_read(map, base + osf);
 	result &= mask;
@@ -978,8 +1088,16 @@
 			      struct flchip *chips, struct cfi_private *cfi)
 {
 	int i;
+	int busmask;
 	int unlockpass = 0;
 
+	switch(map->buswidth) {
+	case 1:  busmask = 0xff; break;
+	case 2:  busmask = 0xffff; break;
+	case 4:  busmask = 0xffffffff; break;
+	default: printk("Unknown buswidth in jedec_probe_chip\n"); return(0);
+	}
+
 	if (!cfi->numchips) {
 		switch (cfi->device_type) {
 		case CFI_DEVICETYPE_X8:
@@ -1043,13 +1161,22 @@
 		/* This is the first time we're called. Set up the CFI 
 		   stuff accordingly and return */
 		
-		cfi->mfr = jedec_read_mfr(map, base, cfi);
-		cfi->id = jedec_read_id(map, base, cfi);
+		cfi->mfr = jedec_read_id(map, base, cfi, MFR_ID);
+		cfi->id = jedec_read_id(map, base, cfi, DEV_ID);
+		/* this is the third id that is available in some
+   		 * devices. If it is not used, it is set to 0 later. 
+		 */
+		cfi->extra=jedec_read_id(map, base, cfi, EXTRA_ID);
+
 		printk(KERN_INFO "Search for id:(%02x %02x) interleave(%d) type(%d)\n", 
 			cfi->mfr, cfi->id, cfi->interleave, cfi->device_type);
 		for (i=0; i<sizeof(jedec_table)/sizeof(jedec_table[0]); i++) {
-			if (cfi->mfr == jedec_table[i].mfr_id &&
-			    cfi->id == jedec_table[i].dev_id) {
+			if (cfi->mfr == (jedec_table[i].mfr_id&busmask) &&
+			    cfi->id == (jedec_table[i].dev_id&busmask) &&
+			    (!jedec_table[i].extra_id || cfi->extra == (jedec_table[i].extra_id&busmask))) {
+				
+				if (!jedec_table[i].extra_id) cfi->extra=0; /*don't check*/ 
+
 				if (!cfi_jedec_setup(cfi, i))
 					return 0;
 				goto ok_out;
@@ -1068,12 +1195,17 @@
 	} else {
 		__u16 mfr;
 		__u16 id;
+		__u16 extra;
+
+
 
 		/* Make sure it is a chip of the same manufacturer and id */
-		mfr = jedec_read_mfr(map, base, cfi);
-		id = jedec_read_id(map, base, cfi);
+		mfr = jedec_read_id(map, base, cfi,MFR_ID);
+		id = jedec_read_id(map, base, cfi,DEV_ID);
+		extra = jedec_read_id(map, base, cfi,EXTRA_ID);
 
-		if ((mfr != cfi->mfr) || (id != cfi->id)) {
+		if ((mfr != cfi->mfr) || (id != cfi->id) ||
+			 (cfi->extra && extra != cfi->extra)) {
 			printk(KERN_DEBUG "%s: Found different chip or no chip at all (mfr 0x%x, id 0x%x) at 0x%x\n",
 			       map->name, mfr, id, base);
 			jedec_reset(base, map, cfi);
@@ -1085,15 +1217,17 @@
 	for (i=0; i<cfi->numchips; i++) {
 		/* This chip should be in read mode if it's one
 		   we've already touched. */
-		if (jedec_read_mfr(map, chips[i].start, cfi) == cfi->mfr &&
-		    jedec_read_id(map, chips[i].start, cfi) == cfi->id) {
+		if (jedec_read_id(map, chips[i].start, cfi,MFR_ID) == cfi->mfr &&
+		    jedec_read_id(map, chips[i].start, cfi,DEV_ID) == cfi->id &&
+		    (!cfi->extra || jedec_read_id(map, chips[i].start, cfi,EXTRA_ID)==cfi->extra)) {
 			/* Eep. This chip also looks like it's in autoselect mode.
 			   Is it an alias for the new one? */
 			jedec_reset(chips[i].start, map, cfi);
 
 			/* If the device IDs go away, it's an alias */
-			if (jedec_read_mfr(map, base, cfi) != cfi->mfr ||
-			    jedec_read_id(map, base, cfi) != cfi->id) {
+			if (jedec_read_id(map, base, cfi,MFR_ID) != cfi->mfr ||
+			    jedec_read_id(map, base, cfi,DEV_ID) != cfi->id ||
+			    (cfi->extra && jedec_read_id(map, base, cfi,EXTRA_ID) != cfi->extra)) {
 				printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
 				       map->name, base, chips[i].start);
 				return 0;
@@ -1104,8 +1238,9 @@
 			 * too and if it's the same, assume it's an alias. */
 			/* FIXME: Use other modes to do a proper check */
 			jedec_reset(base, map, cfi);
-			if (jedec_read_mfr(map, base, cfi) == cfi->mfr &&
-			    jedec_read_id(map, base, cfi) == cfi->id) {
+			if (jedec_read_id(map, base, cfi,MFR_ID) == cfi->mfr &&
+			    jedec_read_id(map, base, cfi,DEV_ID) == cfi->id&&
+		    	   (!cfi->extra || jedec_read_id(map, base, cfi,EXTRA_ID)==cfi->extra)) {
 				printk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",
 				       map->name, base, chips[i].start);
 				return 0;
Index: linux-2.4.27/drivers/mtd/chips/map_ram.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/chips/map_ram.c	2001-10-05 02:14:59.000000000 +0400
+++ linux-2.4.27/drivers/mtd/chips/map_ram.c	2008-03-22 11:19:21.000000000 +0300
@@ -34,6 +34,11 @@
 
 	/* Check the first byte is RAM */
 #if 0
+	/*
+	 * enabling this code will corrupt the first and last byte of memory
+	 * in the area.  This is particularly bad if you have pre-loaded
+	 * something useful into the area (like a rom filesystem)
+	 */
 	map->write8(map, 0x55, 0);
 	if (map->read8(map, 0) != 0x55)
 		return NULL;
Index: linux-2.4.27/drivers/mtd/chips/stm_flash.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/chips/stm_flash.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,930 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/flashchip.h>
+
+#define MAX_SMT_CHIPS 8
+
+#define DEVICE_TYPE_X8  (8 / 8)
+#define DEVICE_TYPE_X16 (16 / 8)
+#define DEVICE_TYPE_X32 (32 / 8)
+
+/* Addresses */
+#define ADDR_MANUFACTURER		0x0000
+#define ADDR_DEVICE_ID			0x0002
+#define ADDR_UNLOCK_1			0x0AAA
+#define ADDR_UNLOCK_2			0x0554
+
+/* Commands */
+#define CMD_UNLOCK_DATA_1		0x00aa
+#define CMD_UNLOCK_DATA_2		0x0055
+#define CMD_MANUFACTURER_UNLOCK_DATA	0x0090
+#define CMD_PROGRAM_UNLOCK_DATA		0x00A0
+#define CMD_RESET_DATA			0x00F0
+#define CMD_SECTOR_ERASE_UNLOCK_DATA	0x0080
+#define CMD_SECTOR_ERASE_UNLOCK_DATA_2	0x0030
+
+#define D6_MASK 0x40
+
+struct stm_flash_private {
+	int device_type;
+	int interleave;
+	int numchips;
+	unsigned long chipshift;
+	struct flchip chips[0];
+};
+
+struct stm_flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const u_long size;
+	const int numeraseregions;
+	const struct mtd_erase_region_info regions[4];
+};
+
+static int stm_flash_read(struct mtd_info *, loff_t, size_t, size_t *, unsigned char *);
+static int stm_flash_write(struct mtd_info *, loff_t, size_t, size_t *, const unsigned char *);
+static void stm_flash_sync(struct mtd_info *);
+static int stm_flash_erase(struct mtd_info *, struct erase_info *);
+static void stm_flash_destroy(struct mtd_info*);
+static struct mtd_info* stm_flash_probe(struct map_info *);
+static int stm_flash_suspend(struct mtd_info *mtd);
+static void stm_flash_resume(struct mtd_info *mtd);
+
+static struct mtd_chip_driver stm_flash_chipdrv = {
+	probe:		stm_flash_probe,
+	destroy:	stm_flash_destroy,
+	name:		"stm_flash",
+	module:		THIS_MODULE
+};
+
+static const char im_name[] = "stm_flash";
+
+static void send_unlock(struct map_info *map, unsigned long base)
+{
+	map->write16(map, CMD_UNLOCK_DATA_1, base + ADDR_UNLOCK_1);
+	map->write16(map, CMD_UNLOCK_DATA_2, base + ADDR_UNLOCK_2);
+}
+
+static void send_cmd(struct map_info *map, unsigned long base, 
+		     unsigned long cmd)
+{
+	send_unlock(map, base);
+	map->write16(map, cmd, base + ADDR_UNLOCK_1);
+}
+
+static void send_cmd_to_addr(struct map_info *map, unsigned long base, 
+			     unsigned long cmd, unsigned long addr)
+{
+	send_unlock(map, base);
+	map->write16(map, cmd, addr);
+}
+
+static int probe_new_chip(struct mtd_info *mtd, __u32 base, 
+			  struct flchip *chips,
+			  struct stm_flash_private *private,
+			  const struct stm_flash_info *table,
+			  int table_size)
+{
+	__u32 mfr_id, dev_id;
+	struct map_info *map = mtd->priv;
+	struct stm_flash_private temp;
+	int i;
+
+	temp.device_type = DEVICE_TYPE_X16;
+	temp.interleave = 1;
+	map->fldrv_priv = &temp;
+
+	/* Enter autoselect mode. */
+	send_cmd(map, base, CMD_RESET_DATA);
+	send_cmd(map, base, CMD_MANUFACTURER_UNLOCK_DATA);
+
+	mfr_id = map->read16(map, base + ADDR_MANUFACTURER) & 0x00FF;
+	dev_id = map->read16(map, base + ADDR_DEVICE_ID) & 0x00FF;
+
+	for (i = 0; i < table_size; i++)
+	{
+		if ((mfr_id == table[i].mfr_id) &&
+		    (dev_id == table[i].dev_id))
+		{
+			if (chips)
+			{
+				int j;
+
+				for (j = 0; j < private->numchips; j++)
+				{
+					if ((map->read16(map, chips[j].start +
+							ADDR_MANUFACTURER)
+						== mfr_id) &&
+					    (map->read16(map, chips[j].start +
+							 ADDR_DEVICE_ID)
+						== dev_id))
+					{
+						/* Exit autoselect mode */
+						send_cmd(map, base, CMD_RESET_DATA);
+						return -1;
+					}
+				}
+
+				if (private->numchips == MAX_SMT_CHIPS)
+				{
+					printk(KERN_WARNING "%s: Too many "
+						"flash chips detected. "
+						"Increase MAX_SMT_CHIPS "
+						"from %d.\n", map->name,
+						MAX_SMT_CHIPS);
+					return -1;
+				}
+
+				chips[private->numchips].start = base;
+				chips[private->numchips].state = FL_READY;
+				chips[private->numchips].mutex =
+					&chips[private->numchips]._spinlock;
+				private->numchips++;
+			}
+			printk("%s: Found %d x %ldMiB %s at 0x%08x\n",
+				map->name, temp.interleave, 
+				(table[i].size)/(1024*1024),
+				table[i].name, base);
+			
+			mtd->size += table[i].size * temp.interleave;
+			mtd->numeraseregions += table[i].numeraseregions;
+
+			break;
+		}
+	}
+
+	/* Exit autoselect mode. */
+	send_cmd(map, base, CMD_RESET_DATA);
+
+	if (i == table_size)
+	{
+		printk(KERN_DEBUG "%s: unknown flash device at 0x%08x, "
+			"mfr id 0x%02x, dev_id 0x%02x\n", map->name,
+			base, mfr_id, dev_id);
+		map->fldrv_priv = NULL;
+
+		return -1;
+	}
+
+	private->device_type = temp.device_type;
+	private->interleave = temp.interleave;
+
+	return i;
+}
+
+static struct mtd_info* stm_flash_probe(struct map_info *map)
+{
+	const struct stm_flash_info table[] = {
+	{
+		mfr_id: 0x20,
+		dev_id: 0xe9,
+		name: "ST PSD4256G",
+		size: 0x00100000,
+		numeraseregions: 1,
+		regions: {
+		  { offset: 0x000000, erasesize: 0x10000, numblocks: 16 }, 
+		}
+	}
+	};
+	struct mtd_info *mtd;
+	struct flchip chips[MAX_SMT_CHIPS];
+	int table_pos[MAX_SMT_CHIPS];
+	struct stm_flash_private temp;
+	struct stm_flash_private *private;
+	unsigned long base;
+	unsigned long size;
+	int i;
+	int offset, reg_idx;
+
+	mtd = (struct mtd_info*)kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd)
+	{
+		printk(KERN_WARNING "%s: kmalloc failed for info structure\n",
+			map->name);
+		return NULL;
+	}
+	memset(mtd, 0, sizeof(*mtd));
+	mtd->priv = map;
+
+	memset(&temp, 0, sizeof(temp));
+	
+	printk("%s: Probing for SMT PSD4256G compatible flash...\n", map->name);
+	
+	if ((table_pos[0] = probe_new_chip(mtd, 0, NULL, &temp, table,
+					sizeof(table)/sizeof(table[0]))) == -1)
+	{
+		printk(KERN_WARNING 
+			"%s: Found no SMT PSD4256G compatible device at "
+			"location zero\n", map->name);
+		kfree(mtd);
+
+		return NULL;
+	}
+
+	chips[0].start = 0;
+	chips[0].state = FL_READY;
+	chips[0].mutex = &chips[0]._spinlock;
+	temp.numchips = 1;
+	for (size = mtd->size; size > 1; size >>= 1)
+		temp.chipshift++;
+
+	/* Find out if there are any more chips in the map. */
+	for (base = (1 << temp.chipshift); base < map->size;
+			base += (1 << temp.chipshift))
+	{
+		int numchips = temp.numchips;
+		table_pos[numchips] = 
+			probe_new_chip(mtd, base, chips, &temp, 
+				table, sizeof(table)/sizeof(table[0]));
+	}
+
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) *
+					mtd->numeraseregions, GFP_KERNEL);
+
+	if (!mtd->eraseregions)
+	{
+		printk(KERN_WARNING "%s: Failed to allocate memory for "
+			"MTD erase region info\n", map->name);
+		kfree(mtd);
+		map->fldrv_priv = NULL;
+		return NULL;
+	}
+
+	reg_idx = 0;
+	offset = 0;
+	for (i = 0; i < temp.numchips; i++)
+	{
+		int dev_size;
+		int j;
+
+		dev_size = 0;
+		for (j = 0; j < table[table_pos[i]].numeraseregions; j++)
+		{
+			mtd->eraseregions[reg_idx].offset = offset + 
+				(table[table_pos[i]].regions[j].offset *
+				 temp.interleave);
+			mtd->eraseregions[reg_idx].erasesize =
+				table[table_pos[i]].regions[j].erasesize *
+				temp.interleave;
+			mtd->eraseregions[reg_idx].numblocks =
+				table[table_pos[i]].regions[j].numblocks;
+			if (mtd->erasesize < 
+					mtd->eraseregions[reg_idx].erasesize)
+				mtd->erasesize = 
+					mtd->eraseregions[reg_idx].erasesize;
+
+			dev_size += mtd->eraseregions[reg_idx].erasesize *
+				mtd->eraseregions[reg_idx].numblocks;
+			reg_idx++;
+		}
+		offset += dev_size;
+	}
+
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = map->name;
+	mtd->erase = stm_flash_erase;
+	mtd->read = stm_flash_read;
+	mtd->write = stm_flash_write;
+	mtd->sync = stm_flash_sync;
+	mtd->suspend = stm_flash_suspend;
+	mtd->resume = stm_flash_resume;
+
+	private = kmalloc(sizeof(*private) + 
+			(sizeof(struct flchip) * temp.numchips), GFP_KERNEL);
+	if (!private) {
+		printk(KERN_WARNING
+		       "%s: kmalloc failed for private structure\n", map->name);
+		kfree(mtd);
+		map->fldrv_priv = NULL;
+		return NULL;
+	}
+	memcpy(private, &temp, sizeof(temp));
+	memcpy(private->chips, chips, 
+		sizeof(struct flchip) * private->numchips);
+	for (i = 0; i < private->numchips; i++)
+	{
+		init_waitqueue_head(&private->chips[i].wq);
+		spin_lock_init(&private->chips[i]._spinlock);
+	}
+
+	map->fldrv_priv = private;
+
+	map->fldrv = &stm_flash_chipdrv;
+	MOD_INC_USE_COUNT;
+	
+	return mtd;
+}
+
+static void stm_flash_destroy(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct stm_flash_private *private = map->fldrv_priv;
+	kfree(private);
+}
+
+static void stm_flash_sync(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct stm_flash_private *private = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	for (i = 0; !ret && (i < private->numchips); i++)
+	{
+		chip = &private->chips[i];
+
+	retry:
+		spin_lock_bh(chip->mutex);
+
+		switch (chip->state)
+		{
+		case FL_READY:
+		case FL_STATUS:
+		case FL_CFI_QUERY:
+		case FL_JEDEC_QUERY:
+			chip->oldstate = chip->state;
+			chip->state = FL_SYNCING;
+		case FL_SYNCING:
+			spin_unlock_bh(chip->mutex);
+			break;
+		default:
+			/* Not an idle state */
+			add_wait_queue(&chip->wq, &wait);
+
+			spin_unlock_bh(chip->mutex);
+
+			schedule();
+
+			remove_wait_queue(&chip->wq, &wait);
+
+			goto retry;
+		}
+	}
+
+	/* Unlock the chips again */
+	for (i--; i >= 0; i--)
+	{
+		chip = &private->chips[i];
+
+		spin_lock_bh(chip->mutex);
+
+		if (chip->state == FL_SYNCING) 
+		{
+			chip->state = chip->oldstate;
+			wake_up(&chip->wq);
+		}
+		spin_unlock_bh(chip->mutex);
+	}
+}
+
+static int read_one_chip(struct map_info *map, struct flchip *chip, 
+			loff_t addr, size_t len, unsigned char *buf)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long timeo = jiffies + HZ;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY)
+	{
+		printk(KERN_INFO "%s: waiting for chip to read, state = %d\n",
+			map->name, chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if (signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}
+
+	addr += chip->start;
+
+	chip->state = FL_READY;
+
+	map->copy_from(map, buf, addr, len);
+
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+static int stm_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t *retlen, unsigned char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct stm_flash_private *private = map->fldrv_priv;
+	unsigned long offset;
+	int chipnum;
+	int ret = 0;
+
+	if ((from + len) > mtd->size)
+	{
+		printk(KERN_WARNING "%s: read request past end of device "
+			"(0x%lx)\n", map->name, (unsigned long)from + len);
+		return -EINVAL;
+	}
+
+	/* Offset within the first chip that the first read should start. */
+	chipnum = (from >> private->chipshift);
+	offset = from - (chipnum << private->chipshift);
+
+	*retlen = 0;
+
+	while (len)
+	{
+		unsigned long this_len;
+
+		if (chipnum >= private->numchips)
+			break;
+
+		if ((len + offset -1) >> private->chipshift)
+			this_len = (1 << private->chipshift) - offset;
+		else
+			this_len = len;
+
+		ret = read_one_chip(map, &private->chips[chipnum], offset,
+				this_len, buf);
+
+		if (ret)
+			break;
+
+		*retlen += this_len;
+		len -= this_len;
+		buf += this_len;
+
+		offset = 0;
+		chipnum++;
+	}
+
+	return ret;
+}
+
+static int flash_is_busy(struct map_info *map, unsigned long addr)
+{
+	unsigned short read1, read2, toggled;
+	
+	read1 = map->read16(map, addr);
+	read2 = map->read16(map, addr);
+	toggled = read1 ^ read2;
+	toggled &= (((unsigned short)1) << 6);
+	return toggled;
+}
+
+static int write_one_word(struct map_info *map, struct flchip *chip,
+		unsigned long addr, unsigned long datum)
+{
+	unsigned long timeo = jiffies + HZ;
+	struct stm_flash_private *private = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+	int ret = 0;
+	int times_left;
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY)
+	{
+		printk("%s: waiting for chip to write, state = %d\n",
+				map->name, chip->state);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+		printk(KERN_INFO "%s: woke up to write\n", map->name);
+		if (signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}
+
+	chip->state = FL_WRITING;
+
+	addr += chip->start;
+
+	send_cmd(map, chip->start, CMD_PROGRAM_UNLOCK_DATA);
+	map->write16(map, datum, addr);
+
+	times_left = 50000;
+	while (times_left-- && flash_is_busy(map, addr))
+	{
+		if (current->need_resched) 
+		{
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			spin_lock_bh(chip->mutex);
+		}
+	}
+
+	if (!times_left)
+	{
+		printk(KERN_WARNING "%s: write to 0x%lx timed out!\n",
+				map->name, addr);
+		ret = -EIO;
+	} else {
+		unsigned long verify;
+		if ((verify = map->read16(map, addr)) != datum) 
+		{
+			printk(KERN_WARNING "%s: write to 0x%lx failed. "
+				"datum = %lx, verify = %lx\n", map->name,
+				addr, datum, verify);
+			ret = -EIO;
+		}
+	}
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return ret;
+}
+
+static int stm_flash_write(struct mtd_info *mtd, loff_t to, size_t len,
+			   size_t *retlen, const unsigned char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct stm_flash_private *private = map->fldrv_priv;
+	int ret = 0;
+	int chipnum;
+	unsigned long offset;
+	unsigned long chipstart;
+
+	*retlen = 0;
+	if (!len)
+		return 0;
+
+	chipnum = to >> private->chipshift;
+	offset = to - (chipnum << private->chipshift);
+	chipstart = private->chips[chipnum].start;
+
+	/* If it's not bus-aligned, do the first byte write. */
+	if (offset & (map->buswidth -1))
+	{
+		unsigned long bus_offset = offset & ~(map->buswidth - 1);
+		int i = offset - bus_offset;
+		int n = 0;
+		unsigned char tmp_buf[4];
+		unsigned long datum;
+
+		map->copy_from(map, tmp_buf, 
+			       bus_offset + private->chips[chipnum].start,
+			       map->buswidth);
+		while (len && i < map->buswidth)
+			tmp_buf[i++] = buf[n++], len--;
+
+		if (map->buswidth == 2)
+			datum = *(__u16*)tmp_buf;
+		else if (map->buswidth == 4)
+			datum = *(__u32*)tmp_buf;
+		else
+			return -EINVAL;
+
+		ret = write_one_word(map, &private->chips[chipnum], bus_offset,
+				datum);
+
+		if (ret)
+			return ret;
+
+		offset += n;
+		buf += n;
+		(*retlen) += n;
+
+		if (offset >> private->chipshift)
+		{
+			chipnum++;
+			offset = 0;
+			if (chipnum == private->numchips)
+				return 0;
+		}
+	}
+
+	/* We are now aligned, write as much as possible. */
+	while (len >= map->buswidth)
+	{
+		unsigned long datum;
+
+		if (map->buswidth == 1)
+			datum = *(unsigned char*)buf;
+		else if (map->buswidth == 2)
+			datum = *(unsigned short*)buf;
+		else if (map->buswidth == 4)
+			datum = *(unsigned long*)buf;
+		else
+			return -EINVAL;
+
+		ret = write_one_word(map, &private->chips[chipnum], offset, 
+				datum);
+
+		if (ret)
+			return ret;
+
+		offset += map->buswidth;
+		buf += map->buswidth;
+		(*retlen) += map->buswidth;
+		len -= map->buswidth;
+
+		if (offset >> private->chipshift)
+		{
+			chipnum++;
+			offset = 0;
+			if (chipnum == private->numchips)
+				return 0;
+			chipstart = private->chips[chipnum].start;
+		}
+	}
+
+	if (len & (map->buswidth - 1))
+	{
+		int i = 0, n = 0;
+		unsigned char tmp_buf[2];
+		unsigned long datum;
+
+		map->copy_from(map, tmp_buf, 
+				offset + private->chips[chipnum].start,
+				map->buswidth);
+
+		while (len--)
+			tmp_buf[i++] = buf[n++];
+
+		if (map->buswidth == 2)
+			datum = *(unsigned short*)tmp_buf;
+		else if (map->buswidth == 4)
+			datum = *(unsigned long*)tmp_buf;
+		else
+			return -EINVAL;
+
+		ret = write_one_word(map, &private->chips[chipnum], offset, 
+				datum);
+
+		if (ret)
+			return ret;
+
+		(*retlen) += n;
+	}
+
+	return 0;
+}
+
+static int erase_one_block(struct map_info *map, struct flchip *chip,
+			   unsigned long addr, unsigned long size)
+{
+	unsigned long timeo = jiffies + HZ;
+	struct stm_flash_private *private = map->fldrv_priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	if (chip->state != FL_READY)
+	{
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		if (signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}
+
+	chip->state = FL_ERASING;
+
+	addr += chip->start;
+
+	send_cmd(map, chip->start, CMD_SECTOR_ERASE_UNLOCK_DATA);
+	send_cmd_to_addr(map, chip->start, CMD_SECTOR_ERASE_UNLOCK_DATA_2, addr);
+
+	timeo = jiffies + (HZ * 20);
+
+	spin_unlock_bh(chip->mutex);
+	schedule_timeout(HZ);
+	spin_lock_bh(chip->mutex);
+
+	while (flash_is_busy(map, chip->start))
+	{
+		if (chip->state != FL_ERASING)
+		{
+			/* Someone's suspended the erase. Sleep. */
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_INFO "%s: erase suspended. Sleeping.\n",
+				map->name);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+
+			if (signal_pending(current))
+				return -EINTR;
+
+			timeo = jiffies + (HZ*2);
+			spin_lock_bh(chip->mutex);
+			continue;
+		}
+
+		/* OK Still waiting */
+		if (time_after(jiffies, timeo))
+		{
+			chip->state = FL_READY;
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_WARNING "%s: waiting for erase to complete "
+				"timed out.\n", map->name);
+
+			return -EIO;
+		}
+
+		/* Latency issues. Drop the lock, wait a while, and retry. */
+		spin_unlock_bh(chip->mutex);
+
+		if (current->need_resched)
+			schedule();
+		else
+			udelay(1);
+
+		spin_lock_bh(chip->mutex);
+	}
+
+	{
+		/* Verify every single word */
+		int address;
+		int error = 0;
+		int verify;
+		
+		for (address = addr; address < (addr + size); address += 2)
+			if ((verify = map->read16(map, address)) != 0xFFFF)
+			{
+				error = 1;
+				break;
+			}
+
+		if (error)
+		{
+			chip->state = FL_READY;
+			spin_unlock_bh(chip->mutex);
+			printk(KERN_WARNING "%s: verify error at 0x%x, size "
+				"%ld.\n", map->name, address, size);
+			return -EIO;
+		}
+	}
+
+	chip->state = FL_READY;
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+
+	return 0;
+}
+
+static int stm_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct stm_flash_private *private = map->fldrv_priv;
+	unsigned long addr, len;
+	int chipnum;
+	int ret = 0;
+	int i, first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	if (instr->addr > mtd->size)
+		return -EINVAL;
+
+	if ((instr->len + instr->addr) > mtd->size)
+		return -EINVAL;
+
+	/*
+	 * Check that both start and end of the requested erase are aligned
+	 * with the erasesize at the appropriate addresses.
+	 */
+	i = 0;
+
+	/*
+	 * Skip all erase regions which are ended before the start of the
+	 * requested erase. Actually, to save on the calculations, we skip
+	 * to the first erase region which starts after the start of the 
+	 * requested erase, and then go back one.
+	 */
+	while ((i < mtd->numeraseregions) &&
+	       (instr->addr >= regions[i].offset))
+		i++;
+	i--;
+
+	/*
+	 * OK. Now i is pointing at the erase region in which this erase 
+	 * request starts. Check the start of the requested erase range
+	 * is aligned with the erase size which is in effect here.
+	 */
+	if (instr->addr & (regions[i].erasesize -1))
+		return -EINVAL;
+
+	/*
+	 * Remember the erase region we start on.
+	 */
+	first = i;
+
+	/*
+	 * Next, theck that the end of the requested erase is aligned with
+	 * the erase region at that address.
+	 */
+	while ((i < mtd->numeraseregions) &&
+	       ((instr->addr + instr->len) >= regions[i].offset))
+		i++;
+	i--;
+
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1))
+		return -EINVAL;
+
+	chipnum = instr->addr >> private->chipshift;
+	addr = instr->addr - (chipnum << private->chipshift);
+	len = instr->len;
+
+	i = first;
+
+	while (len)
+	{
+		ret = erase_one_block(map, &private->chips[chipnum], addr,
+				regions[i].erasesize);
+
+		if (ret)
+			return ret;
+
+		addr += regions[i].erasesize;
+		len -= regions[i].erasesize;
+
+		if ((addr % (1 << private->chipshift)) ==
+		    ((regions[i].offset + (regions[i].erasesize *
+					   regions[i].numblocks))
+		     % (1 << private->chipshift)))
+			i++;
+
+		if (addr >> private->chipshift)
+		{
+			addr = 0;
+			chipnum++;
+
+			if (chipnum >= private->numchips)
+				break;
+		}
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+
+	return 0;
+}
+
+static int stm_flash_suspend(struct mtd_info *mtd)
+{
+	printk("stm_flash_suspend(): not implemented!\n");
+	        return -EINVAL;
+}
+
+
+
+static void stm_flash_resume(struct mtd_info *mtd)
+{
+	printk("stm_flash_resume(): not implemented!\n");
+}
+
+int __init stm_flash_init(void)
+{
+	register_mtd_chip_driver(&stm_flash_chipdrv);
+	return 0;
+}
+
+void __exit stm_flash_exit(void)
+{
+	unregister_mtd_chip_driver(&stm_flash_chipdrv);
+}
+
+module_init(stm_flash_init);
+module_exit(stm_flash_exit);
Index: linux-2.4.27/drivers/mtd/cmdlinepart.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/cmdlinepart.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/cmdlinepart.c	2008-03-22 11:19:21.000000000 +0300
@@ -35,7 +35,7 @@
 #define ERRP "mtd: "
 
 /* debug macro */
-#if 0
+#if 1
 #define dbg(x) do { printk("DEBUG-CMDLINE-PART: "); printk x; } while(0)
 #else
 #define dbg(x)
@@ -79,7 +79,7 @@
 	unsigned long offset = 0;
 	char *name;
 	int name_len;
-	unsigned char *extra_mem;
+	unsigned char *extra_mem,*pName;
 	char delim;
 	unsigned int mask_flags;
 
@@ -134,7 +134,7 @@
 	}
    
 	/* record name length for memory allocation later */
-	extra_mem_size += name_len + 1;
+	//xxxx extra_mem_size += name_len + 1;
 
         /* test for options */
         if (strncmp(s, "ro", 2) == 0) 
@@ -153,7 +153,7 @@
 		}
 		/* more partitions follow, parse them */
 		if ((parts = newpart(s + 1, &s, num_parts, 
-		                     this_part + 1, &extra_mem, extra_mem_size)) == 0)
+		                     this_part + 1, &extra_mem, extra_mem_size+name_len+1)) == 0)
 		  return 0;
 	}
 	else
@@ -162,13 +162,15 @@
 
 		*num_parts = this_part + 1;
 		alloc_size = *num_parts * sizeof(struct mtd_partition) +
-			     extra_mem_size;
+			     extra_mem_size+name_len+1;
 		parts = kmalloc(alloc_size, GFP_KERNEL);
 		if (!parts)
 		{
 			printk(KERN_ERR ERRP "out of memory\n");
 			return 0;
 		}
+		dbg(("parts=0x%lx *num_parts=0x%lx\n",parts,*num_parts));
+
 		memset(parts, 0, alloc_size);
 		extra_mem = (unsigned char *)(parts + *num_parts);
 	}
@@ -176,17 +178,20 @@
 	parts[this_part].size = size;
 	parts[this_part].offset = offset;
 	parts[this_part].mask_flags = mask_flags;
+	pName = extra_mem+extra_mem_size;
 	if (name)
 	{
-		strncpy(extra_mem, name, name_len);
-		extra_mem[name_len] = 0;
+		strncpy(pName, name, name_len);
+		pName[name_len] = 0;
+		dbg(("ext. name\n"));
 	}
 	else
 	{
-		sprintf(extra_mem, "Partition_%03d", this_part);
+		dbg(("def. name\n"));
+		sprintf(pName, "Partition_%03d", this_part);
 	}
-	parts[this_part].name = extra_mem;
-	extra_mem += name_len + 1;
+	parts[this_part].name = pName;
+	//extra_mem += name_len + 1;
 
 	dbg(("partition %d: name <%s>, offset %x, size %x, mask flags %x\n",
 	     this_part, 
@@ -230,8 +235,6 @@
 		}
 		mtd_id_len = p - mtd_id;
 
-		dbg(("parsing <%s>\n", p+1));
-
 		/* 
 		 * parse one mtd. have it reserve memory for the
 		 * struct cmdline_mtd_partition and the mtd-id string.
@@ -254,6 +257,7 @@
 			 return 0;
 		 }
 
+
 		/* enter results */	    
 		this_mtd->parts = parts;
 		this_mtd->num_parts = num_parts;
@@ -299,7 +303,7 @@
 	int i;
 	struct cmdline_mtd_partition *part;
 
-	if(!cmdline)
+	if (!cmdline)
 		return -EINVAL;
 
 	/* parse command line */
Index: linux-2.4.27/drivers/mtd/inftlcore.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/inftlcore.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,1255 @@
+/* 
+ * inftlcore.c -- Linux driver for Inverse Flash Translation Layer (INFTL)
+ *
+ * (C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
+ *
+ * Based heavily on the inftlcore.c code which is:
+ * (c) 1999 Machine Vision Holdings, Inc.
+ * Author: David Woodhouse <dwmw2@infradead.org>
+ *
+ * $Id$
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/hdreg.h>
+#include <linux/blkpg.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nftl.h>
+#include <linux/mtd/inftl.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+/*
+ * Maximum number of loops while examining next block, to have a
+ * chance to detect consistency problems (they should never happen
+ * because of the checks done in the mounting.
+ */
+#define MAX_LOOPS 10000
+
+/* INFTL block device stuff */
+#define MAJOR_NR INFTL_MAJOR
+#define DEVICE_OFF(device)
+
+#include <linux/blk.h>
+#include <linux/hdreg.h>
+
+/*
+ * There is some confusion as to what major inftl actually can use.
+ */
+#undef DEVICE_REQUEST
+#undef DEVICE_NR
+#define DEVICE_REQUEST inftl_request
+#define	DEVICE_NR(device) (MINOR(device) >> PARTN_BITS)
+
+
+extern void INFTL_dumptables(struct INFTLrecord *inftl);
+extern void INFTL_dumpVUchains(struct INFTLrecord *inftl);
+
+
+/* Linux-specific block device functions */
+
+/* I _HATE_ the Linux block device setup more than anything else I've ever
+ *  encountered, except ...
+ */
+
+static int inftl_sizes[256];
+static int inftl_blocksizes[256];
+
+/* .. for the Linux partition table handling. */
+static struct hd_struct part_table[256];
+
+static struct gendisk inftl_gendisk = {
+	.major =	MAJOR_NR,
+	.major_name =	"inftl",
+	.minor_shift =	INFTL_PARTN_BITS, /* Bits to shift to get real from partition */
+	.max_p =	(1<<INFTL_PARTN_BITS)-1, /* Number of partitions per real */
+	.part =		part_table,     /* hd struct */
+	.sizes =	inftl_sizes,     /* block sizes */
+};
+
+struct INFTLrecord *INFTLs[MAX_INFTLS];
+
+static void INFTL_setup(struct mtd_info *mtd)
+{
+	int i;
+	struct INFTLrecord *inftl;
+	unsigned long temp;
+	int firstfree = -1;
+
+	DEBUG(MTD_DEBUG_LEVEL1, "INFTL: INFTL_setup()\n");
+
+	for (i = 0; i < MAX_INFTLS; i++) {
+		if (!INFTLs[i] && firstfree == -1)
+			firstfree = i;
+		else if (INFTLs[i] && INFTLs[i]->mtd == mtd) {
+			/*
+			 * This is a Spare Media Header for an INFTL we've
+			 * already found.
+			 */
+			DEBUG(MTD_DEBUG_LEVEL1, "INFTL: MTD already mounted "
+				"as INFTL\n");
+			return;
+		}
+	}
+        if (firstfree == -1) {
+		printk(KERN_WARNING "INFTL: No more INFTL slots available\n");
+		return;
+        }
+
+	inftl = kmalloc(sizeof(struct INFTLrecord), GFP_KERNEL);
+	if (!inftl) {
+		printk(KERN_WARNING "INFTL: out of memory for INFTL data "
+			"structures\n");
+		return;
+	}
+
+	init_MUTEX(&inftl->mutex);
+	inftl->mtd = mtd;
+
+        if (INFTL_mount(inftl) < 0) {
+		printk(KERN_WARNING "INFTL:cCould not mount INFTL device\n");
+		kfree(inftl);
+		return;
+        }
+
+	/* OK, it's a new one. Set up all the data structures. */
+#ifdef PSYCHO_DEBUG
+	printk("INFTL: found new INFTL inftl%c\n", firstfree + 'a');
+#endif
+
+        /* linux stuff */
+	inftl->usecount = 0;
+	inftl->cylinders = 1024;
+	inftl->heads = 16;
+
+	temp = inftl->cylinders * inftl->heads;
+	inftl->sectors = inftl->nr_sects / temp;
+	if (inftl->nr_sects % temp) {
+		inftl->sectors++;
+		temp = inftl->cylinders * inftl->sectors;
+		inftl->heads = inftl->nr_sects / temp;
+
+		if (inftl->nr_sects % temp) {
+			inftl->heads++;
+			temp = inftl->heads * inftl->sectors;
+			inftl->cylinders = inftl->nr_sects / temp;
+		}
+	}
+
+	if (inftl->nr_sects != inftl->heads*inftl->cylinders*inftl->sectors) {
+		printk(KERN_WARNING "INFTL: cannot calculate an INFTL "
+			"geometry to match size of 0x%x.\n",
+			(int)inftl->nr_sects);
+		printk(KERN_WARNING "INFTL: Using C:%d H:%d S:%d (== 0x%lx "
+			"sects)\n", inftl->cylinders, inftl->heads,
+			inftl->sectors, (long)inftl->cylinders *
+			(long)inftl->heads * (long)inftl->sectors );
+
+		/*
+		 * Oh no we don't have inftl->nr_sects = inftl->heads *
+		 * inftl->cylinders * inftl->sectors;
+		 */
+	}
+	INFTLs[firstfree] = inftl;
+	/* Finally, set up the block device sizes */
+	inftl_sizes[firstfree * 16] = inftl->nr_sects;
+	//nftl_blocksizes[firstfree*16] = 512;
+	part_table[firstfree * 16].nr_sects = inftl->nr_sects;
+
+	inftl_gendisk.nr_real++;
+
+	/* partition check ... */
+	grok_partitions(&inftl_gendisk, firstfree, 1 << INFTL_PARTN_BITS,
+		inftl->nr_sects);
+}
+
+static void INFTL_unsetup(int i)
+{
+	struct INFTLrecord *inftl = INFTLs[i];
+
+	DEBUG(MTD_DEBUG_LEVEL1, "INFTL: INFTL_unsetup(%d)\n", i);
+	
+	INFTLs[i] = NULL;
+	
+	if (inftl->PUtable)
+		kfree(inftl->PUtable);
+	if (inftl->VUtable)
+		kfree(inftl->VUtable);
+		      
+	inftl_gendisk.nr_real--;
+	kfree(inftl);
+}
+
+/*
+ * Search the MTD device for INFTL partitions
+ */
+static void INFTL_notify_add(struct mtd_info *mtd)
+{
+	DEBUG(MTD_DEBUG_LEVEL1, "INFTL: INFTL_notify_add(%s)\n", mtd->name);
+
+	if (mtd) {
+		if (!mtd->read_oob) {
+			/*
+			 * If this MTD doesn't have out-of-band data,
+			 * then there's no point continuing.
+			 */
+			DEBUG(MTD_DEBUG_LEVEL1, "INFTL: no OOB data, quitting\n");
+			return;
+		}
+		DEBUG(MTD_DEBUG_LEVEL3, "INFTL: mtd->read = %p, size = %d, "
+			"erasesize = %d\n", mtd->read, mtd->size,
+			mtd->erasesize);
+
+                INFTL_setup(mtd);
+	}
+}
+
+static void INFTL_notify_remove(struct mtd_info *mtd)
+{
+	int i;
+
+	for (i = 0; i < MAX_INFTLS; i++) {
+		if (INFTLs[i] && INFTLs[i]->mtd == mtd)
+			INFTL_unsetup(i);
+	}
+}
+
+/*
+ * Actual INFTL access routines.
+ */
+
+/*
+ * INFTL_findfreeblock: Find a free Erase Unit on the INFTL partition.
+ *	This function is used when the give Virtual Unit Chain.
+ */
+static u16 INFTL_findfreeblock(struct INFTLrecord *inftl, int desperate)
+{
+	u16 pot = inftl->LastFreeEUN;
+	int silly = inftl->nb_blocks;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_findfreeblock(inftl=0x%x,"
+		"desperate=%d)\n", (int)inftl, desperate);
+
+	/*
+	 * Normally, we force a fold to happen before we run out of free
+	 * blocks completely.
+	 */
+	if (!desperate && inftl->numfreeEUNs < 2) {
+		DEBUG(MTD_DEBUG_LEVEL1, "INFTL: there are too few free "
+			"EUNs (%d)\n", inftl->numfreeEUNs);
+		return 0xffff;
+	}
+
+	/* Scan for a free block */
+	do {
+		if (inftl->PUtable[pot] == BLOCK_FREE) {
+			inftl->LastFreeEUN = pot;
+			return pot;
+		}
+
+		if (++pot > inftl->lastEUN)
+			pot = 0;
+
+		if (!silly--) {
+			printk(KERN_WARNING "INFTL: no free blocks found!  "
+				"EUN range = %d - %d\n", 0, inftl->LastFreeEUN);
+			return BLOCK_NIL;
+		}
+	} while (pot != inftl->LastFreeEUN);
+
+	return BLOCK_NIL;
+}
+
+static u16 INFTL_foldchain(struct INFTLrecord *inftl, unsigned thisVUC, unsigned pendingblock)
+{
+	u16 BlockMap[MAX_SECTORS_PER_UNIT];
+	unsigned char BlockDeleted[MAX_SECTORS_PER_UNIT];
+	unsigned int thisEUN, prevEUN, status;
+	int block, silly;
+	unsigned int targetEUN;
+	struct inftl_oob oob;
+        size_t retlen;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_foldchain(inftl=0x%x,thisVUC=%d,"
+		"pending=%d)\n", (int)inftl, thisVUC, pendingblock);
+
+	memset(BlockMap, 0xff, sizeof(BlockMap));
+	memset(BlockDeleted, 0, sizeof(BlockDeleted));
+
+	thisEUN = targetEUN = inftl->VUtable[thisVUC];
+
+	if (thisEUN == BLOCK_NIL) {
+		printk(KERN_WARNING "INFTL: trying to fold non-existent "
+		       "Virtual Unit Chain %d!\n", thisVUC);
+		return BLOCK_NIL;
+	}
+	
+	/*
+	 * Scan to find the Erase Unit which holds the actual data for each
+	 * 512-byte block within the Chain.
+	 */
+        silly = MAX_LOOPS;
+	while (thisEUN < inftl->nb_blocks) {
+		for (block = 0; block < inftl->EraseSize/SECTORSIZE; block ++) {
+			if ((BlockMap[block] != 0xffff) || BlockDeleted[block])
+				continue;
+
+			if (MTD_READOOB(inftl->mtd, (thisEUN * inftl->EraseSize)
+			     + (block * SECTORSIZE), 16 , &retlen,
+			     (char *)&oob) < 0)
+				status = SECTOR_IGNORE;
+			else
+                        	status = oob.b.Status | oob.b.Status1;
+
+			switch(status) {
+			case SECTOR_FREE:
+			case SECTOR_IGNORE:
+				break;
+			case SECTOR_USED:
+				BlockMap[block] = thisEUN;
+				continue;
+			case SECTOR_DELETED:
+				BlockDeleted[block] = 1;
+				continue;
+			default:
+				printk(KERN_WARNING "INFTL: unknown status "
+					"for block %d in EUN %d: %x\n",
+					block, thisEUN, status);
+				break;
+			}
+		}
+
+		if (!silly--) {
+			printk(KERN_WARNING "INFTL: infinite loop in Virtual "
+				"Unit Chain 0x%x\n", thisVUC);
+			return BLOCK_NIL;
+		}
+		
+		thisEUN = inftl->PUtable[thisEUN];
+	}
+
+	/*
+	 * OK. We now know the location of every block in the Virtual Unit
+	 * Chain, and the Erase Unit into which we are supposed to be copying.
+	 * Go for it.
+	 */
+	DEBUG(MTD_DEBUG_LEVEL1, "INFTL: folding chain %d into unit %d\n",
+		thisVUC, targetEUN);
+
+	for (block = 0; block < inftl->EraseSize/SECTORSIZE ; block++) {
+		unsigned char movebuf[SECTORSIZE];
+		int ret;
+
+		/*
+		 * If it's in the target EUN already, or if it's pending write,
+		 * do nothing.
+		 */
+		if (BlockMap[block] == targetEUN || (pendingblock ==
+		    (thisVUC * (inftl->EraseSize / SECTORSIZE) + block))) {
+			continue;
+		}
+
+                /*
+		 * Copy only in non free block (free blocks can only
+                 * happen in case of media errors or deleted blocks).
+		 */
+                if (BlockMap[block] == BLOCK_NIL)
+                        continue;
+                
+                ret = MTD_READECC(inftl->mtd, (inftl->EraseSize *
+			BlockMap[block]) + (block * SECTORSIZE), SECTORSIZE,
+			&retlen, movebuf, (char *)&oob, NAND_ECC_DISKONCHIP); 
+                if (ret < 0) {
+			ret = MTD_READECC(inftl->mtd, (inftl->EraseSize *
+				BlockMap[block]) + (block * SECTORSIZE),
+				SECTORSIZE, &retlen, movebuf, (char *)&oob,
+				NAND_ECC_DISKONCHIP); 
+			if (ret != -EIO) 
+                        	DEBUG(MTD_DEBUG_LEVEL1, "INFTL: error went "
+					"away on retry?\n");
+                }
+                MTD_WRITEECC(inftl->mtd, (inftl->EraseSize * targetEUN) +
+			(block * SECTORSIZE), SECTORSIZE, &retlen,
+			movebuf, (char *)&oob, NAND_ECC_DISKONCHIP);
+	}
+
+	/*
+	 * Newest unit in chain now contains data from _all_ older units.
+	 * So go through and erase each unit in chain, oldest first. (This
+	 * is important, by doing oldest first if we crash/reboot then it
+	 * it is relatively simple to clean up the mess).
+	 */
+	DEBUG(MTD_DEBUG_LEVEL1, "INFTL: want to erase virtual chain %d\n",
+		thisVUC);
+
+	for (;;) {
+		/* Find oldest unit in chain. */
+		thisEUN = inftl->VUtable[thisVUC];
+		prevEUN = BLOCK_NIL;
+		while (inftl->PUtable[thisEUN] != BLOCK_NIL) {
+			prevEUN = thisEUN;
+			thisEUN = inftl->PUtable[thisEUN];
+		}
+
+		/* Check if we are all done */
+		if (thisEUN == targetEUN)
+			break;
+
+                if (INFTL_formatblock(inftl, thisEUN) < 0) {
+			/*
+			 * Could not erase : mark block as reserved.
+			 * FixMe: Update Bad Unit Table on disk.
+			 */
+			inftl->PUtable[thisEUN] = BLOCK_RESERVED;
+                } else {
+			/* Correctly erased : mark it as free */
+			inftl->PUtable[thisEUN] = BLOCK_FREE;
+			inftl->PUtable[prevEUN] = BLOCK_NIL;
+			inftl->numfreeEUNs++;
+                }
+	}
+
+	return targetEUN;
+}
+
+u16 INFTL_makefreeblock(struct INFTLrecord *inftl, unsigned pendingblock)
+{
+	/*
+	 * This is the part that needs some cleverness applied. 
+	 * For now, I'm doing the minimum applicable to actually
+	 * get the thing to work.
+	 * Wear-levelling and other clever stuff needs to be implemented
+	 * and we also need to do some assessment of the results when
+	 * the system loses power half-way through the routine.
+	 */
+	u16 LongestChain = 0;
+	u16 ChainLength = 0, thislen;
+	u16 chain, EUN;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_makefreeblock(inftl=0x%x,"
+		"pending=%d)\n", (int)inftl, pendingblock);
+
+	for (chain = 0; chain < inftl->nb_blocks; chain++) {
+		EUN = inftl->VUtable[chain];
+		thislen = 0;
+
+		while (EUN <= inftl->lastEUN) {
+			thislen++;
+			EUN = inftl->PUtable[EUN];
+			if (thislen > 0xff00) {
+				printk(KERN_WARNING "INFTL: endless loop in "
+					"Virtual Chain %d: Unit %x\n",
+					chain, EUN);
+				/*
+				 * Actually, don't return failure.
+				 * Just ignore this chain and get on with it.
+				 */
+				thislen = 0;
+				break;
+			}
+		}
+
+		if (thislen > ChainLength) {
+			ChainLength = thislen;
+			LongestChain = chain;
+		}
+	}
+
+	if (ChainLength < 2) {
+		printk(KERN_WARNING "INFTL: no Virtual Unit Chains available "
+			"for folding. Failing request\n");
+		return BLOCK_NIL;
+	}
+
+	return INFTL_foldchain(inftl, LongestChain, pendingblock);
+}
+
+static int nrbits(unsigned int val, int bitcount)
+{
+	int i, total = 0;
+
+	for (i = 0; (i < bitcount); i++)
+		total += (((0x1 << i) & val) ? 1 : 0);
+	return total;
+}
+
+/*
+ * INFTL_findwriteunit: Return the unit number into which we can write 
+ *                      for this block. Make it available if it isn't already.
+ */
+static /*inline*/ u16 INFTL_findwriteunit(struct INFTLrecord *inftl, unsigned int block)
+{
+	unsigned int thisVUC = block / (inftl->EraseSize / SECTORSIZE);
+	unsigned int thisEUN, writeEUN, prev_block, status;
+	unsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize -1);
+	struct inftl_oob oob;
+	struct inftl_bci bci;
+	size_t retlen;
+	int silly, silly2 = 3;
+	unsigned char anac, nacs, parity;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_findwriteunit(inftl=0x%x,"
+		"block=%d)\n", (int)inftl, block);
+
+	do {
+		/*
+		 * Scan the media to find a unit in the VUC which has
+		 * a free space for the block in question.
+		 */
+		writeEUN = BLOCK_NIL;
+		thisEUN = inftl->VUtable[thisVUC];
+		silly = MAX_LOOPS;
+
+		while (thisEUN <= inftl->lastEUN) {
+			MTD_READOOB(inftl->mtd, (thisEUN * inftl->EraseSize) +
+				blockofs, 8, &retlen, (char *)&bci);
+
+                        status = bci.Status | bci.Status1;
+			DEBUG(MTD_DEBUG_LEVEL3, "INFTL: status of block %d in "
+				"EUN %d is %x\n", block , writeEUN, status);
+
+			switch(status) {
+			case SECTOR_FREE:
+				writeEUN = thisEUN;
+				break;
+			case SECTOR_DELETED:
+			case SECTOR_USED:
+				/* Can't go any further */
+				goto hitused;
+			case SECTOR_IGNORE:
+				break;
+			default:
+				/*
+				 * Invalid block. Don't use it any more.
+				 * Must implement.
+				 */
+				break;			
+			}
+			
+			if (!silly--) { 
+				printk(KERN_WARNING "INFTL: infinite loop in "
+					"Virtual Unit Chain 0x%x\n", thisVUC);
+				return 0xffff;
+			}
+
+			/* Skip to next block in chain */
+			thisEUN = inftl->PUtable[thisEUN];
+		}
+
+hitused:
+		if (writeEUN != BLOCK_NIL)
+			return writeEUN;
+
+
+		/*
+		 * OK. We didn't find one in the existing chain, or there 
+		 * is no existing chain. Allocate a new one.
+		 */
+		writeEUN = INFTL_findfreeblock(inftl, 0);
+
+		if (writeEUN == BLOCK_NIL) {
+			/*
+			 * That didn't work - there were no free blocks just
+			 * waiting to be picked up. We're going to have to fold
+			 * a chain to make room.
+			 */
+			thisEUN = INFTL_makefreeblock(inftl, 0xffff);
+
+			/*
+			 * Hopefully we free something, lets try again.
+			 * This time we are desperate...
+			 */
+			DEBUG(MTD_DEBUG_LEVEL1, "INFTL: using desperate==1 "
+				"to find free EUN to accommodate write to "
+				"VUC %d\n", thisVUC);
+			writeEUN = INFTL_findfreeblock(inftl, 1);
+			if (writeEUN == BLOCK_NIL) {
+				/*
+				 * Ouch. This should never happen - we should
+				 * always be able to make some room somehow. 
+				 * If we get here, we've allocated more storage 
+				 * space than actual media, or our makefreeblock
+				 * routine is missing something.
+				 */
+				printk(KERN_WARNING "INFTL: cannot make free "
+					"space.\n");
+#ifdef DEBUG
+				INFTL_dumptables(inftl);
+				INFTL_dumpVUchains(inftl);
+#endif
+				return BLOCK_NIL;
+			}			
+		}
+
+		/*
+		 * Insert new block into virtual chain. Firstly update the
+		 * block headers in flash...
+		 */
+		anac = 0;
+		nacs = 0;
+		thisEUN = inftl->VUtable[thisVUC];
+
+		if (thisEUN != BLOCK_NIL) {
+			MTD_READOOB(inftl->mtd, thisEUN * inftl->EraseSize
+				+ 8, 8, &retlen, (char *)&oob.u);
+			anac = oob.u.a.ANAC + 1;
+			nacs = oob.u.a.NACs + 1;
+		}
+
+		prev_block = inftl->VUtable[thisVUC];
+		if (prev_block < inftl->nb_blocks)
+			prev_block -= inftl->firstEUN;
+
+		parity = (nrbits(thisVUC, 16) & 0x1) ? 0x1 : 0;
+		parity |= (nrbits(prev_block, 16) & 0x1) ? 0x2 : 0;
+		parity |= (nrbits(anac, 8) & 0x1) ? 0x4 : 0;
+		parity |= (nrbits(nacs, 8) & 0x1) ? 0x8 : 0;
+ 
+		oob.u.a.virtualUnitNo = cpu_to_le16(thisVUC);
+		oob.u.a.prevUnitNo = cpu_to_le16(prev_block);
+		oob.u.a.ANAC = anac;
+		oob.u.a.NACs = nacs;
+		oob.u.a.parityPerField = parity;
+		oob.u.a.discarded = 0xaa;
+
+		MTD_WRITEOOB(inftl->mtd, writeEUN * inftl->EraseSize + 8, 8,
+			&retlen, (char *)&oob.u);
+
+		/* Also back up header... */
+		oob.u.b.virtualUnitNo = cpu_to_le16(thisVUC);
+		oob.u.b.prevUnitNo = cpu_to_le16(prev_block);
+		oob.u.b.ANAC = anac;
+		oob.u.b.NACs = nacs;
+		oob.u.b.parityPerField = parity;
+		oob.u.b.discarded = 0xaa;
+
+		MTD_WRITEOOB(inftl->mtd, writeEUN * inftl->EraseSize + 
+			SECTORSIZE * 4 + 8, 8, &retlen, (char *)&oob.u);
+
+		inftl->PUtable[writeEUN] = inftl->VUtable[thisVUC];
+		inftl->VUtable[thisVUC] = writeEUN;
+
+		inftl->numfreeEUNs--;
+		return writeEUN;
+
+	} while (silly2--);
+
+	printk(KERN_WARNING "INFTL: error folding to make room for Virtual "
+		"Unit Chain 0x%x\n", thisVUC);
+	return 0xffff;
+}
+
+/*
+ * Given a Virtual Unit Chain, see if it can be deleted, and if so do it.
+ */
+static void INFTL_trydeletechain(struct INFTLrecord *inftl, unsigned thisVUC)
+{
+	unsigned char BlockUsed[MAX_SECTORS_PER_UNIT];
+	unsigned char BlockDeleted[MAX_SECTORS_PER_UNIT];
+	unsigned int thisEUN, status;
+	int block, silly;
+	struct inftl_bci bci;
+	size_t retlen;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_trydeletechain(inftl=0x%x,"
+		"thisVUC=%d)\n", (int)inftl, thisVUC);
+
+	memset(BlockUsed, 0, sizeof(BlockUsed));
+	memset(BlockDeleted, 0, sizeof(BlockDeleted));
+
+	thisEUN = inftl->VUtable[thisVUC];
+	if (thisEUN == BLOCK_NIL) {
+		printk(KERN_WARNING "INFTL: trying to delete non-existent "
+		       "Virtual Unit Chain %d!\n", thisVUC);
+		return;
+	}
+	
+	/*
+	 * Scan through the Erase Units to determine whether any data is in
+	 * each of the 512-byte blocks within the Chain.
+	 */
+	silly = MAX_LOOPS;
+	while (thisEUN < inftl->nb_blocks) {
+		for (block = 0; block < inftl->EraseSize/SECTORSIZE; block++) {
+			if (BlockUsed[block] || BlockDeleted[block])
+				continue;
+
+			if (MTD_READOOB(inftl->mtd, (thisEUN * inftl->EraseSize)
+			    + (block * SECTORSIZE), 8 , &retlen,
+			    (char *)&bci) < 0)
+				status = SECTOR_IGNORE;
+			else
+				status = bci.Status | bci.Status1;
+
+			switch(status) {
+			case SECTOR_FREE:
+			case SECTOR_IGNORE:
+				break;
+			case SECTOR_USED:
+				BlockUsed[block] = 1;
+				continue;
+			case SECTOR_DELETED:
+				BlockDeleted[block] = 1;
+				continue;
+			default:
+				printk(KERN_WARNING "INFTL: unknown status "
+					"for block %d in EUN %d: 0x%x\n",
+					block, thisEUN, status);
+			}
+		}
+
+		if (!silly--) {
+			printk(KERN_WARNING "INFTL: infinite loop in Virtual "
+				"Unit Chain 0x%x\n", thisVUC);
+			return;
+		}
+		
+		thisEUN = inftl->PUtable[thisEUN];
+	}
+
+	for (block = 0; block < inftl->EraseSize/SECTORSIZE; block++)
+		if (BlockUsed[block])
+			return;
+
+	/*
+	 * For each block in the chain free it and make it available
+	 * for future use. Erase from the oldest unit first.
+	 */
+	DEBUG(MTD_DEBUG_LEVEL1, "INFTL: deleting empty VUC %d\n", thisVUC);
+
+	for (;;) {
+		u16 *prevEUN = &inftl->VUtable[thisVUC];
+		thisEUN = *prevEUN;
+
+		/* If the chain is all gone already, we're done */
+		if (thisEUN == BLOCK_NIL) {
+			DEBUG(MTD_DEBUG_LEVEL2, "INFTL: Empty VUC %d for deletion was already absent\n", thisEUN);
+			return;
+		}
+
+		/* Find oldest unit in chain. */
+		while (inftl->PUtable[thisEUN] != BLOCK_NIL) {
+			BUG_ON(thisEUN >= inftl->nb_blocks);
+
+			prevEUN = &inftl->PUtable[thisEUN];
+			thisEUN = *prevEUN;
+		}
+
+		DEBUG(MTD_DEBUG_LEVEL3, "Deleting EUN %d from VUC %d\n",
+		      thisEUN, thisVUC);
+
+                if (INFTL_formatblock(inftl, thisEUN) < 0) {
+			/*
+			 * Could not erase : mark block as reserved.
+			 * FixMe: Update Bad Unit Table on medium.
+			 */
+			inftl->PUtable[thisEUN] = BLOCK_RESERVED;
+                } else {
+			/* Correctly erased : mark it as free */
+			inftl->PUtable[thisEUN] = BLOCK_FREE;
+			inftl->numfreeEUNs++;
+		}
+
+		/* Now sort out whatever was pointing to it... */
+		*prevEUN = BLOCK_NIL;
+
+		/* Ideally we'd actually be responsive to new
+		   requests while we're doing this -- if there's
+		   free space why should others be made to wait? */
+		cond_resched();
+	}
+
+	inftl->VUtable[thisVUC] = BLOCK_NIL;
+}
+
+static int INFTL_deleteblock(struct INFTLrecord *inftl, unsigned block)
+{
+	unsigned int thisEUN = inftl->VUtable[block / (inftl->EraseSize / SECTORSIZE)];
+	unsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);
+	unsigned int status;
+	int silly = MAX_LOOPS;
+	size_t retlen;
+	struct inftl_bci bci;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_deleteblock(inftl=0x%x,"
+		"block=%d)\n", (int)inftl, block);
+
+	while (thisEUN < inftl->nb_blocks) {
+		if (MTD_READOOB(inftl->mtd, (thisEUN * inftl->EraseSize) +
+		    blockofs, 8, &retlen, (char *)&bci) < 0)
+			status = SECTOR_IGNORE;
+		else
+			status = bci.Status | bci.Status1;
+
+		switch (status) {
+		case SECTOR_FREE:
+		case SECTOR_IGNORE:
+			break;
+		case SECTOR_DELETED:
+			thisEUN = BLOCK_NIL;
+			goto foundit;
+		case SECTOR_USED:
+			goto foundit;
+		default:
+			printk(KERN_WARNING "INFTL: unknown status for "
+				"block %d in EUN %d: 0x%x\n",
+				block, thisEUN, status);
+			break;
+		}
+
+		if (!silly--) {
+			printk(KERN_WARNING "INFTL: infinite loop in Virtual "
+				"Unit Chain 0x%x\n",
+				block / (inftl->EraseSize / SECTORSIZE));
+			return 1;
+		}
+		thisEUN = inftl->PUtable[thisEUN];
+	}
+
+foundit:
+	if (thisEUN != BLOCK_NIL) {
+		loff_t ptr = (thisEUN * inftl->EraseSize) + blockofs;
+
+		if (MTD_READOOB(inftl->mtd, ptr, 8, &retlen, (char *)&bci) < 0)
+			return -EIO;
+		bci.Status = bci.Status1 = SECTOR_DELETED;
+		if (MTD_WRITEOOB(inftl->mtd, ptr, 8, &retlen, (char *)&bci) < 0)
+			return -EIO;
+		INFTL_trydeletechain(inftl, block / (inftl->EraseSize / SECTORSIZE));
+	}
+	return 0;
+}
+
+static int INFTL_writeblock(struct INFTLrecord *inftl, unsigned block, char *buffer)
+{
+	u16 writeEUN;
+	unsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);
+	size_t retlen;
+	u8 eccbuf[6];
+	char *p, *pend;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: inftl_writeblock(inftl=0x%x,block=%d,"
+		"buffer=0x%x)\n", (int)inftl, block, (int)buffer);
+
+	/* Is block all zero? */
+	pend = buffer + SECTORSIZE;
+	for (p = buffer; p < pend && !*p; p++);
+
+	if (p < pend) {
+		writeEUN = INFTL_findwriteunit(inftl, block);
+
+		if (writeEUN == BLOCK_NIL) {
+			printk(KERN_WARNING "INFTL__writeblock(): cannot find "
+				"block to write to\n");
+			/*
+			 * If we _still_ haven't got a block to use,
+			 * we're screwed.
+			 */
+			return 1;
+		}
+
+		MTD_WRITEECC(inftl->mtd, (writeEUN * inftl->EraseSize) +
+			blockofs, SECTORSIZE, &retlen, (char *)buffer,
+			(char *)eccbuf, NAND_ECC_DISKONCHIP);
+		/*
+		 * no need to write SECTOR_USED flags since they are
+		 * written in mtd_writeecc.
+		 */
+	} else {
+		INFTL_deleteblock(inftl, block);
+	}
+
+	return 0;
+}
+
+static int INFTL_readblock(struct INFTLrecord *inftl, unsigned block, char *buffer)
+{
+	u16 thisEUN = inftl->VUtable[block / (inftl->EraseSize / SECTORSIZE)];
+	unsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);
+        unsigned int status;
+	int silly = MAX_LOOPS;
+        struct inftl_bci bci;
+        size_t retlen;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: inftl_readblock(inftl=0x%x,block=%d,"
+		"buffer=0x%x)\n", (int)inftl, block, (int)buffer);
+
+	while (thisEUN < inftl->nb_blocks) {
+		if (MTD_READOOB(inftl->mtd, (thisEUN * inftl->EraseSize) +
+		     blockofs, 8, &retlen, (char *)&bci) < 0)
+			status = SECTOR_IGNORE;
+		else
+			status = bci.Status | bci.Status1;
+
+		switch (status) {
+		case SECTOR_DELETED:
+			thisEUN = BLOCK_NIL;
+			goto foundit;
+		case SECTOR_USED:
+			goto foundit;
+		case SECTOR_FREE:
+		case SECTOR_IGNORE:
+			break;
+		default:
+			printk(KERN_WARNING "INFTL: unknown status for "
+				"block %d in EUN %d: 0x%04x\n",
+				block, thisEUN, status);
+			break;
+		}
+
+		if (!silly--) {
+			printk(KERN_WARNING "INFTL: infinite loop in "
+				"Virtual Unit Chain 0x%x\n",
+				block / (inftl->EraseSize / SECTORSIZE));
+			return 1;
+		}
+
+		thisEUN = inftl->PUtable[thisEUN];
+	}
+
+foundit:
+	if (thisEUN == BLOCK_NIL) {
+		/* The requested block is not on the media, return all 0x00 */
+		memset(buffer, 0, SECTORSIZE);
+	} else {
+        	size_t retlen;
+		loff_t ptr = (thisEUN * inftl->EraseSize) + blockofs;
+		u_char eccbuf[6];
+		if (MTD_READECC(inftl->mtd, ptr, SECTORSIZE, &retlen,
+		    buffer, eccbuf, NAND_ECC_DISKONCHIP))
+			return -EIO;
+	}
+	return 0;
+}
+
+static int inftl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct INFTLrecord *inftl;
+	int p;
+
+	inftl = INFTLs[MINOR(inode->i_rdev) >> INFTL_PARTN_BITS];
+
+	if (!inftl)
+		return -EINVAL;
+
+	switch (cmd) {
+#if 0
+	case INFTL_IOCTL_DELETE_SECTOR: {
+		unsigned int dev;
+		int res;
+
+		if (arg >= part_table[dev].nr_sects)
+			return -EINVAL;
+		arg += part_table[MINOR(inode->i_rdev)].start_sect;
+		DEBUG(MTD_DEBUG_LEVEL3, "Waiting for mutex\n");
+		down(&inftl->mutex);
+		DEBUG(MTD_DEBUG_LEVEL3, "Got mutex\n");
+		res = INFTL_deleteblock(inftl, arg);
+		up(&inftl->mutex);
+		return res;
+	}
+#endif
+	case HDIO_GETGEO: {
+		struct hd_geometry g;
+
+		g.heads = inftl->heads;
+		g.sectors = inftl->sectors;
+		g.cylinders = inftl->cylinders;
+		g.start = part_table[MINOR(inode->i_rdev)].start_sect;
+		return copy_to_user((void *)arg, &g, sizeof g) ? -EFAULT : 0;
+	}
+	case BLKGETSIZE:   /* Return device size */
+		return put_user(part_table[MINOR(inode->i_rdev)].nr_sects,
+			(unsigned long *) arg);
+
+#ifdef BLKGETSIZE64
+	case BLKGETSIZE64:
+		return put_user((u64)part_table[MINOR(inode->i_rdev)].nr_sects << 9,
+			(u64 *)arg);
+#endif
+
+	case BLKFLSBUF:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EACCES;
+		fsync_dev(inode->i_rdev);
+		invalidate_buffers(inode->i_rdev);
+		if (inftl->mtd->sync)
+			inftl->mtd->sync(inftl->mtd);
+		return 0;
+
+	case BLKRRPART:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EACCES;
+		if (inftl->usecount > 1)
+			return -EBUSY;
+		/* 
+		 * We have to flush all buffers and invalidate caches,
+		 * or we won't be able to re-use the partitions,
+		 * if there was a change and we don't want to reboot
+		 */
+		p = (1 << INFTL_PARTN_BITS) - 1;
+		while (p-- > 0) {
+			kdev_t devp = MKDEV(MAJOR(inode->i_dev),
+				MINOR(inode->i_dev)+p);
+			if (part_table[p].nr_sects > 0)
+				invalidate_device (devp, 1);
+
+			part_table[MINOR(inode->i_dev)+p].start_sect = 0;
+			part_table[MINOR(inode->i_dev)+p].nr_sects = 0;
+		}
+		
+#if LINUX_VERSION_CODE < 0x20328
+		resetup_one_dev(&inftl_gendisk,
+			MINOR(inode->i_rdev) >> INFTL_PARTN_BITS);
+#else
+		grok_partitions(&inftl_gendisk,
+			MINOR(inode->i_rdev) >> INFTL_PARTN_BITS,
+			1 << INFTL_PARTN_BITS, inftl->nr_sects);
+#endif
+		return 0;
+
+	case BLKROSET:
+	case BLKROGET:
+	case BLKSSZGET:
+		return blk_ioctl(inode->i_rdev, cmd, arg);
+
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+void inftl_request(RQFUNC_ARG)
+{
+	unsigned int dev, block, nsect;
+	struct INFTLrecord *inftl;
+	char *buffer;
+	struct request *req;
+	int res;
+
+	while (1) {
+		INIT_REQUEST;	/* blk.h */
+		req = CURRENT;
+		
+		/* We can do this because the generic code knows not to
+		   touch the request at the head of the queue */
+		spin_unlock_irq(&io_request_lock);
+
+		DEBUG(MTD_DEBUG_LEVEL2, "INFTL_request\n");
+		DEBUG(MTD_DEBUG_LEVEL3, "INFTL %s request, from sector 0x%04lx"
+			" for 0x%04lx sectors\n",
+			(req->cmd == READ) ? "Read " : "Write",
+			req->sector, req->current_nr_sectors);
+
+		dev = MINOR(req->rq_dev);
+		block = req->sector;
+		nsect = req->current_nr_sectors;
+		buffer = req->buffer;
+		res = 1; /* succeed */
+
+		if (dev >= MAX_INFTLS * (1 << INFTL_PARTN_BITS)) {
+			/* there is no such partition */
+			printk("INFTL: bad minor number: device = %s\n",
+			       kdevname(req->rq_dev));
+			res = 0; /* fail */
+			goto repeat;
+		}
+		
+		inftl = INFTLs[dev / (1 << INFTL_PARTN_BITS)];
+		DEBUG(MTD_DEBUG_LEVEL3, "Waiting for mutex\n");
+		down(&inftl->mutex);
+		DEBUG(MTD_DEBUG_LEVEL3, "Got mutex\n");
+
+		if (block + nsect > part_table[dev].nr_sects) {
+			/* access past the end of device */
+			printk("inftl%c%d: bad access: block = %d, "
+				"count = %d\n",
+				(MINOR(req->rq_dev) >> 6) + 'a', dev & 0xf,
+				block, nsect);
+			up(&inftl->mutex);
+			res = 0; /* fail */
+			goto repeat;
+		}
+		
+		block += part_table[dev].start_sect;
+		
+		if (req->cmd == READ) {
+			DEBUG(MTD_DEBUG_LEVEL2, "INFTL: read request of 0x%x"
+				"  sectors @ %x (req->nr_sectors == %lx)\n",
+				nsect, block, req->nr_sectors);
+	
+			for ( ; nsect > 0; nsect-- , block++, buffer += SECTORSIZE) {
+				/* Read a single sector to req->buffer + (512 * i) */
+				if (INFTL_readblock(inftl, block, buffer)) {
+					DEBUG(MTD_DEBUG_LEVEL2, "INFTL: "
+						"read request failed\n");
+					up(&inftl->mutex);
+					res = 0;
+					goto repeat;
+				}
+			}
+
+			DEBUG(MTD_DEBUG_LEVEL2, "INFTL: read request "
+				"completed OK\n");
+			up(&inftl->mutex);
+			goto repeat;
+		} else if (req->cmd == WRITE) {
+			DEBUG(MTD_DEBUG_LEVEL2, "INFTL: write request of 0x%x"
+				" sectors @ %x (req->nr_sectors == %lx)\n",
+				nsect, block, req->nr_sectors);
+			for ( ; nsect > 0; nsect-- , block++, buffer += 512) {
+				/* Read a single sector to req->buffer + (512 * i) */
+				if (INFTL_writeblock(inftl, block, buffer)) {
+					DEBUG(MTD_DEBUG_LEVEL1, "INFTL: "
+						"write request failed\n");
+					up(&inftl->mutex);
+					res = 0;
+					goto repeat;
+				}
+			}
+			DEBUG(MTD_DEBUG_LEVEL2, "INFTL write request "
+				"completed OK\n");
+			up(&inftl->mutex);
+			goto repeat;
+		} else {
+			DEBUG(MTD_DEBUG_LEVEL0, "INFTL: unknown request\n");
+			up(&inftl->mutex);
+			res = 0;
+			goto repeat;
+		}
+	repeat: 
+		DEBUG(MTD_DEBUG_LEVEL3, "INFTL: end_request(%d)\n", res);
+		spin_lock_irq(&io_request_lock);
+		end_request(res);
+	}
+}
+
+static int inftl_open(struct inode *ip, struct file *fp)
+{
+	int inftlnum = MINOR(ip->i_rdev) >> INFTL_PARTN_BITS;
+	struct INFTLrecord *thisINFTL;
+	thisINFTL = INFTLs[inftlnum];
+
+	DEBUG(MTD_DEBUG_LEVEL2, "INFTL: INFTL_open()\n");
+
+#ifdef CONFIG_KMOD
+	if (!thisINFTL && inftlnum == 0) {
+		request_module("docprobe");
+		thisINFTL = INFTLs[inftlnum];
+	}
+#endif
+	if (!thisINFTL) {
+		DEBUG(MTD_DEBUG_LEVEL2, "INFTL: ENODEV, thisINFTL = %d, "
+			"minor = %d, ip = %p, fp = %p\n", 
+			inftlnum, ip->i_rdev, ip, fp);
+		return -ENODEV;
+	}
+
+	thisINFTL->usecount++;
+	if (!get_mtd_device(thisINFTL->mtd, -1))
+		return -ENXIO;
+
+	return 0;
+}
+
+static int inftl_release(struct inode *inode, struct file *fp)
+{
+	struct INFTLrecord *thisINFTL;
+
+	thisINFTL = INFTLs[MINOR(inode->i_rdev) / 16];
+
+	DEBUG(MTD_DEBUG_LEVEL2, "INFTL: INFTL_release()\n");
+
+	if (thisINFTL->mtd->sync)
+		thisINFTL->mtd->sync(thisINFTL->mtd);
+	thisINFTL->usecount--;
+
+	put_mtd_device(thisINFTL->mtd);
+
+	return 0;
+}
+
+static struct block_device_operations inftl_fops = 
+{
+	.owner =	THIS_MODULE,
+	.open =		inftl_open,
+	.release =	inftl_release,
+	.ioctl = 	inftl_ioctl
+};
+
+/****************************************************************************
+ *
+ * Module stuff
+ *
+ ****************************************************************************/
+                                                                                
+static struct mtd_notifier inftl_notifier = {
+	.add = INFTL_notify_add,
+	.remove = INFTL_notify_remove
+};
+                                                                                
+extern char inftlmountrev[];
+
+static int __init init_inftl(void)
+{
+	int i;
+
+	printk(KERN_INFO "INFTL: inftlcore.c $Revision: 1.1.1.1 $, "
+		"inftlmount.c %s\n", inftlmountrev);
+
+	if (register_blkdev(MAJOR_NR, "inftl", &inftl_fops)) {
+		printk(KERN_WARNING "INFTL: unable to register INFTL block "
+			"device on major %d\n", MAJOR_NR);
+		return -EBUSY;
+	}
+
+	blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), &inftl_request);
+
+	/* set block size to 1kb each */
+	for (i = 0; i < 256; i++)
+		inftl_blocksizes[i] = 1024;
+	blksize_size[MAJOR_NR] = inftl_blocksizes;
+
+	add_gendisk(&inftl_gendisk);
+	register_mtd_user(&inftl_notifier);
+	return 0;
+}
+
+static void __exit cleanup_inftl(void)
+{
+	unregister_mtd_user(&inftl_notifier);
+	unregister_blkdev(MAJOR_NR, "inftl");
+	blk_cleanup_queue(BLK_DEFAULT_QUEUE(MAJOR_NR));
+	del_gendisk(&inftl_gendisk);
+}
+
+module_init(init_inftl);
+module_exit(cleanup_inftl);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Greg Ungerer <gerg@snapgear.com>, David Woodhouse <dwmw2@infradead.org>, Fabrice Bellard <fabrice.bellard@netgem.com> et al.");
+MODULE_DESCRIPTION("Support code for Inverse Flash Translation Layer, used on M-Systems DiskOnChip 2000, Millennium and Millennium Plus");
Index: linux-2.4.27/drivers/mtd/inftlmount.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/inftlmount.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,814 @@
+/* 
+ * inftlmount.c -- INFTL mount code with extensive checks.
+ *
+ * Author: Greg Ungerer (gerg@snapgear.com)
+ * (C) Copyright 2002-2003, Greg Ungerer (gerg@snapgear.com)
+ *
+ * Based heavily on the nftlmount.c code which is:
+ * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
+ * Copyright (C) 2000 Netgem S.A.
+ *
+ * $Id$
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nftl.h>
+#include <linux/mtd/inftl.h>
+#include <linux/mtd/compatmac.h>
+
+char inftlmountrev[]="$Revision: 1.1.1.1 $";
+
+/*
+ * find_boot_record: Find the INFTL Media Header and its Spare copy which
+ *	contains the various device information of the INFTL partition and
+ *	Bad Unit Table. Update the PUtable[] table according to the Bad
+ *	Unit Table. PUtable[] is used for management of Erase Unit in
+ *	other routines in inftlcore.c and inftlmount.c.
+ */
+static int find_boot_record(struct INFTLrecord *inftl)
+{
+	struct inftl_unittail h1;
+	//struct inftl_oob oob;
+	unsigned int i, block, boot_record_count = 0;
+	u8 buf[SECTORSIZE];
+	struct INFTLMediaHeader *mh = &inftl->MediaHdr;
+	struct INFTLPartition *ip;
+	int retlen;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: find_boot_record(inftl=0x%x)\n",
+		(int)inftl);
+
+        /*
+	 * Assume logical EraseSize == physical erasesize for starting the
+	 * scan. We'll sort it out later if we find a MediaHeader which says
+	 * otherwise.
+	 */
+	inftl->EraseSize = inftl->mtd->erasesize;
+        inftl->nb_blocks = inftl->mtd->size / inftl->EraseSize;
+
+	inftl->MediaUnit = BLOCK_NIL;
+	inftl->SpareMediaUnit = BLOCK_NIL;
+
+	/* Search for a valid boot record */
+	for (block = 0; block < inftl->nb_blocks; block++) {
+		int ret;
+
+		/*
+		 * Check for BNAND header first. Then whinge if it's found
+		 * but later checks fail.
+		 */
+		if ((ret = MTD_READ(inftl->mtd, block * inftl->EraseSize,
+		    SECTORSIZE, &retlen, buf))) {
+			static int warncount = 5;
+
+			if (warncount) {
+				printk(KERN_WARNING "INFTL: block read at 0x%x "
+					"of mtd%d failed: %d\n",
+					block * inftl->EraseSize,
+					inftl->mtd->index, ret);
+				if (!--warncount)
+					printk(KERN_WARNING "INFTL: further "
+						"failures for this block will "
+						"not be printed\n");
+			}
+			continue;
+		}
+
+		if (retlen < 6 || memcmp(buf, "BNAND", 6)) {
+			/* BNAND\0 not found. Continue */
+			continue;
+		}
+
+		/* To be safer with BIOS, also use erase mark as discriminant */
+		if ((ret = MTD_READOOB(inftl->mtd, block * inftl->EraseSize +
+		    SECTORSIZE + 8, 8, &retlen, (char *)&h1) < 0)) {
+			printk(KERN_WARNING "INFTL: ANAND header found at "
+				"0x%x in mtd%d, but OOB data read failed "
+				"(err %d)\n", block * inftl->EraseSize,
+				inftl->mtd->index, ret);
+			continue;
+		}
+
+		if (boot_record_count) {
+			/*
+			 * We've already processed one. So we just check if
+			 * this one is the same as the first one we found.
+			 */
+			if (memcmp(mh, buf, sizeof(struct INFTLMediaHeader))) {
+				printk(KERN_WARNING "INFTL: Media Headers at "
+					"0x%x and 0x%x disagree.\n",
+					inftl->MediaUnit * inftl->EraseSize,
+					block * inftl->EraseSize);
+				return -1;
+			}
+			if (boot_record_count == 1)
+				inftl->SpareMediaUnit = block;
+
+			/*
+			 * Mark this boot record (INFTL MediaHeader) block as
+			 * reserved.
+			 */
+			inftl->PUtable[block] = BLOCK_RESERVED;
+
+			boot_record_count++;
+			continue;
+		}
+
+		/*
+		 * This is the first we've seen.
+		 * Copy the media header structure into place.
+		 */
+		memcpy(mh, buf, sizeof(struct INFTLMediaHeader));
+		mh->NoOfBootImageBlocks = le32_to_cpu(mh->NoOfBootImageBlocks);
+		mh->NoOfBinaryPartitions = le32_to_cpu(mh->NoOfBinaryPartitions);
+		mh->NoOfBDTLPartitions = le32_to_cpu(mh->NoOfBDTLPartitions);
+		mh->BlockMultiplierBits = le32_to_cpu(mh->BlockMultiplierBits);
+		mh->FormatFlags = le32_to_cpu(mh->FormatFlags);
+		mh->PercentUsed = le32_to_cpu(mh->PercentUsed);
+
+#ifdef CONFIG_MTD_DEBUG_VERBOSE
+		if (CONFIG_MTD_DEBUG_VERBOSE >= 2) {
+			printk("INFTL: Media Header ->\n"
+				"    bootRecordID          = %s\n"
+				"    NoOfBootImageBlocks   = %d\n"
+				"    NoOfBinaryPartitions  = %d\n"
+				"    NoOfBDTLPartitions    = %d\n"
+				"    BlockMultiplerBits    = %d\n"
+				"    FormatFlgs            = %d\n"
+				"    OsakVersion           = 0x%x\n"
+				"    PercentUsed           = %d\n",
+				mh->bootRecordID, mh->NoOfBootImageBlocks,
+				mh->NoOfBinaryPartitions,
+				mh->NoOfBDTLPartitions,
+				mh->BlockMultiplierBits, mh->FormatFlags,
+				mh->OsakVersion, mh->PercentUsed);
+		}
+#endif
+
+		if (mh->NoOfBDTLPartitions == 0) {
+			printk(KERN_WARNING "INFTL: Media Header sanity check "
+				"failed: NoOfBDTLPartitions (%d) == 0, "
+				"must be at least 1\n", mh->NoOfBDTLPartitions);
+			return -1;
+		}
+
+		if ((mh->NoOfBDTLPartitions + mh->NoOfBinaryPartitions) > 4) {
+			printk(KERN_WARNING "INFTL: Media Header sanity check "
+				"failed: Total Partitions (%d) > 4, "
+				"BDTL=%d Binary=%d\n", mh->NoOfBDTLPartitions +
+				mh->NoOfBinaryPartitions,
+				mh->NoOfBDTLPartitions,
+				mh->NoOfBinaryPartitions);
+			return -1;
+		}
+
+		if (mh->BlockMultiplierBits > 1) {
+			printk(KERN_WARNING "INFTL: sorry, we don't support "
+				"UnitSizeFactor 0x%02x\n",
+				mh->BlockMultiplierBits);
+			return -1;
+		} else if (mh->BlockMultiplierBits == 1) {
+			printk(KERN_WARNING "INFTL: support for INFTL with "
+				"UnitSizeFactor 0x%02x is experimental\n",
+				mh->BlockMultiplierBits);
+			inftl->EraseSize = inftl->mtd->erasesize <<
+				(0xff - mh->BlockMultiplierBits);
+			inftl->nb_blocks = inftl->mtd->size / inftl->EraseSize;
+		}
+
+		/* Scan the partitions */
+		for (i = 0; (i < 4); i++) {
+			ip = &mh->Partitions[i];
+			ip->virtualUnits = le32_to_cpu(ip->virtualUnits);
+			ip->firstUnit = le32_to_cpu(ip->firstUnit);
+			ip->lastUnit = le32_to_cpu(ip->lastUnit);
+			ip->flags = le32_to_cpu(ip->flags);
+			ip->spareUnits = le32_to_cpu(ip->spareUnits);
+			ip->Reserved0 = le32_to_cpu(ip->Reserved0);
+
+#ifdef CONFIG_MTD_DEBUG_VERBOSE
+			if (CONFIG_MTD_DEBUG_VERBOSE >= 2) {
+				printk("    PARTITION[%d] ->\n"
+					"        virtualUnits    = %d\n"
+					"        firstUnit       = %d\n"
+					"        lastUnit        = %d\n"
+					"        flags           = 0x%x\n"
+					"        spareUnits      = %d\n",
+					i, ip->virtualUnits, ip->firstUnit,
+					ip->lastUnit, ip->flags,
+					ip->spareUnits);
+			}
+#endif
+
+			if (ip->Reserved0 != ip->firstUnit) {
+				struct erase_info *instr = &inftl->instr;
+
+				/*
+				 * 	Most likely this is using the
+				 * 	undocumented qiuck mount feature.
+				 * 	We don't support that, we will need
+				 * 	to erase the hidden block for full
+				 * 	compatibility.
+				 */
+				instr->addr = ip->Reserved0 * inftl->EraseSize;
+				instr->len = inftl->EraseSize;
+				MTD_ERASE(inftl->mtd, instr);
+			}
+			if ((ip->lastUnit - ip->firstUnit + 1) < ip->virtualUnits) {
+				printk(KERN_WARNING "INFTL: Media Header "
+					"Partition %d sanity check failed\n"
+					"    firstUnit %d : lastUnit %d  >  "
+					"virtualUnits %d\n", i, ip->lastUnit,
+					ip->firstUnit, ip->Reserved0);
+				return -1;
+			}
+			if (ip->Reserved1 != 0) {
+				printk(KERN_WARNING "INFTL: Media Header "
+					"Partition %d sanity check failed: "
+					"Reserved1 %d != 0\n",
+					i, ip->Reserved1);
+				return -1;
+			}
+
+			if (ip->flags & INFTL_BDTL)
+				break;
+		}
+
+		if (i >= 4) {
+			printk(KERN_WARNING "INFTL: Media Header Partition "
+				"sanity check failed:\n       No partition "
+				"marked as Disk Partition\n");
+			return -1;
+		}
+
+		inftl->nb_boot_blocks = ip->firstUnit;
+		inftl->numvunits = ip->virtualUnits;
+		if (inftl->numvunits > (inftl->nb_blocks -
+		    inftl->nb_boot_blocks - 2)) {
+			printk(KERN_WARNING "INFTL: Media Header sanity check "
+				"failed:\n        numvunits (%d) > nb_blocks "
+				"(%d) - nb_boot_blocks(%d) - 2\n",
+				inftl->numvunits, inftl->nb_blocks,
+				inftl->nb_boot_blocks);
+			return -1;
+		}
+		
+		inftl->nr_sects  = inftl->numvunits *
+			(inftl->EraseSize / SECTORSIZE);
+
+		/*
+		 * Block count is set to last used EUN (we won't need to keep
+		 * any meta-data past that point).
+		 */
+		inftl->firstEUN = ip->firstUnit;
+		inftl->lastEUN = ip->lastUnit;
+		inftl->nb_blocks = ip->lastUnit + 1;
+
+		/* Memory alloc */
+		inftl->PUtable = kmalloc(inftl->nb_blocks * sizeof(u16), GFP_KERNEL);
+		if (!inftl->PUtable) {
+			printk(KERN_WARNING "INFTL: allocation of PUtable "
+				"failed (%d bytes)\n",
+				inftl->nb_blocks * sizeof(u16));
+			return -ENOMEM;
+		}
+
+		inftl->VUtable = kmalloc(inftl->nb_blocks * sizeof(u16), GFP_KERNEL);
+		if (!inftl->VUtable) {
+			kfree(inftl->PUtable);
+			printk(KERN_WARNING "INFTL: allocation of VUtable "
+				"failed (%d bytes)\n",
+				inftl->nb_blocks * sizeof(u16));
+			return -ENOMEM;
+		}
+		
+		/* Mark the blocks before INFTL MediaHeader as reserved */
+		for (i = 0; i < inftl->nb_boot_blocks; i++)
+			inftl->PUtable[i] = BLOCK_RESERVED;
+		/* Mark all remaining blocks as potentially containing data */
+		for (; i < inftl->nb_blocks; i++)
+			inftl->PUtable[i] = BLOCK_NOTEXPLORED;
+
+		/* Mark this boot record (NFTL MediaHeader) block as reserved */
+		inftl->PUtable[block] = BLOCK_RESERVED;
+
+#if 0
+		/* Read Bad Erase Unit Table and modify PUtable[] accordingly */
+		for (i = 0; i < inftl->nb_blocks; i++) {
+			if ((i & (SECTORSIZE - 1)) == 0) {
+				/* read one sector for every SECTORSIZE of blocks */
+				if ((ret = MTD_READECC(inftl->mtd,
+				    block * inftl->EraseSize + i + SECTORSIZE,
+				    SECTORSIZE, &retlen, buf,
+				    (char *)&oob, NULL)) < 0) {
+					printk(KERN_WARNING "INFTL: read of "
+						"bad sector table failed "
+						"(err %d)\n", ret);
+					kfree(inftl->VUtable);
+					kfree(inftl->PUtable);
+					return -1;
+				}
+			}
+			/* Mark the Bad Erase Unit as RESERVED in PUtable */
+			if (buf[i & (SECTORSIZE - 1)] != 0xff)
+				inftl->PUtable[i] = BLOCK_RESERVED;
+		}
+#endif
+
+		inftl->MediaUnit = block;
+		boot_record_count++;
+	}
+		
+	return boot_record_count ? 0 : -1;
+}
+
+static int memcmpb(void *a, int c, int n)
+{
+	int i;
+	for (i = 0; i < n; i++) {
+		if (c != ((unsigned char *)a)[i])
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * check_free_sector: check if a free sector is actually FREE,
+ *	i.e. All 0xff in data and oob area.
+ */
+static int check_free_sectors(struct INFTLrecord *inftl, unsigned int address,
+	int len, int check_oob)
+{
+	int i, retlen;
+	u8 buf[SECTORSIZE];
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: check_free_sectors(inftl=0x%x,"
+		"address=0x%x,len=%d,check_oob=%d)\n", (int)inftl,
+		address, len, check_oob);
+
+	for (i = 0; i < len; i += SECTORSIZE) {
+		/*
+		 * We want to read the sector without ECC check here since a
+		 * free sector does not have ECC syndrome on it yet.
+		 */
+		if (MTD_READ(inftl->mtd, address, SECTORSIZE, &retlen, buf) < 0)
+			return -1;
+		if (memcmpb(buf, 0xff, SECTORSIZE) != 0)
+			return -1;
+
+		if (check_oob) {
+			if (MTD_READOOB(inftl->mtd, address,
+			    inftl->mtd->oobsize, &retlen, buf) < 0)
+				return -1;
+			if (memcmpb(buf, 0xff, inftl->mtd->oobsize) != 0)
+				return -1;
+		}
+		address += SECTORSIZE;
+	}
+
+	return 0;
+}
+
+/*
+ * INFTL_format: format a Erase Unit by erasing ALL Erase Zones in the Erase
+ *		 Unit and Update INFTL metadata. Each erase operation is
+ *		 checked with check_free_sectors.
+ *
+ * Return: 0 when succeed, -1 on error.
+ *
+ * ToDo: 1. Is it neceressary to check_free_sector after erasing ?? 
+ *       2. UnitSizeFactor != 0xFF
+ */
+int INFTL_formatblock(struct INFTLrecord *inftl, int block)
+{
+	int retlen;
+	struct inftl_unittail uci;
+	struct erase_info *instr = &inftl->instr;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_formatblock(inftl=0x%x,"
+		"block=%d)\n", (int)inftl, block);
+
+	memset(instr, 0, sizeof(struct erase_info));
+
+	/* Use async erase interface, test return code */
+	instr->addr = block * inftl->EraseSize;
+	instr->len = inftl->EraseSize;
+	MTD_ERASE(inftl->mtd, instr);
+
+	if (instr->state == MTD_ERASE_FAILED) {
+		/*
+		 * Could not format, FixMe: We should update the BadUnitTable 
+		 * both in memory and on disk.
+		 */
+		printk(KERN_WARNING "INFTL: error while formatting block %d\n",
+			block);
+		return -1;
+	}
+
+	/*
+	 * Check the "freeness" of Erase Unit before updating metadata.
+	 * FixMe: is this check really necessary? Since we have check the
+	 *        return code after the erase operation.
+	 */
+	if (check_free_sectors(inftl, instr->addr, inftl->EraseSize, 1) != 0)
+		return -1;
+
+	uci.EraseMark = cpu_to_le16(ERASE_MARK);
+	uci.EraseMark1 = cpu_to_le16(ERASE_MARK);
+	uci.Reserved[0] = 0;
+	uci.Reserved[1] = 0;
+	uci.Reserved[2] = 0;
+	uci.Reserved[3] = 0;
+	if (MTD_WRITEOOB(inftl->mtd, block * inftl->EraseSize + SECTORSIZE * 2 +
+	    8, 8, &retlen, (char *)&uci) < 0)
+		return -1;
+	return 0;
+}
+
+/*
+ * format_chain: Format an invalid Virtual Unit chain. It frees all the Erase
+ *	Units in a Virtual Unit Chain, i.e. all the units are disconnected.
+ *
+ *	Since the chain is invalid then we will have to erase it from its
+ *	head (normally for INFTL we go from the oldest). But if it has a
+ *	loop then there is no oldest...
+ */
+static void format_chain(struct INFTLrecord *inftl, unsigned int first_block)
+{
+	unsigned int block = first_block, block1;
+
+	printk(KERN_WARNING "INFTL: formatting chain at block %d\n",
+		first_block);
+
+	for (;;) {
+		block1 = inftl->PUtable[block];
+
+		printk(KERN_WARNING "INFTL: formatting block %d\n", block);
+		if (INFTL_formatblock(inftl, block) < 0) {
+			/*
+			 * Cannot format !!!! Mark it as Bad Unit,
+			 * FixMe: update the BadUnitTable on disk.
+			 */
+			inftl->PUtable[block] = BLOCK_RESERVED;
+		} else {
+			inftl->PUtable[block] = BLOCK_FREE;
+		}
+
+		/* Goto next block on the chain */
+		block = block1;
+
+		if (block == BLOCK_NIL || block >= inftl->lastEUN)
+			break;
+	}
+}
+
+void INFTL_dumptables(struct INFTLrecord *s)
+{
+	int i;
+
+	printk("-------------------------------------------"
+		"----------------------------------\n");
+
+	printk("VUtable[%d] ->", s->nb_blocks);
+	for (i = 0; i < s->nb_blocks; i++) {
+		if ((i % 8) == 0)
+			printk("\n%04x: ", i);
+		printk("%04x ", s->VUtable[i]);
+	}
+
+	printk("\n-------------------------------------------"
+		"----------------------------------\n");
+
+	printk("PUtable[%d-%d=%d] ->", s->firstEUN, s->lastEUN, s->nb_blocks);
+	for (i = 0; i <= s->lastEUN; i++) {
+		if ((i % 8) == 0)
+			printk("\n%04x: ", i);
+		printk("%04x ", s->PUtable[i]);
+	}
+
+	printk("\n-------------------------------------------"
+		"----------------------------------\n");
+
+	printk("INFTL ->\n"
+		"  EraseSize       = %d\n"
+		"  h/s/c           = %d/%d/%d\n"
+		"  numvunits       = %d\n"
+		"  firstEUN        = %d\n"
+		"  lastEUN         = %d\n"
+		"  numfreeEUNs     = %d\n"
+		"  LastFreeEUN     = %d\n"
+		"  nb_blocks       = %d\n"
+		"  nb_boot_blocks  = %d",
+		s->EraseSize, s->heads, s->sectors, s->cylinders,
+		s->numvunits, s->firstEUN, s->lastEUN, s->numfreeEUNs,
+		s->LastFreeEUN, s->nb_blocks, s->nb_boot_blocks);
+
+	printk("\n-------------------------------------------"
+		"----------------------------------\n");
+}
+
+void INFTL_dumpVUchains(struct INFTLrecord *s)
+{
+	int logical, block, i;
+
+	printk("-------------------------------------------"
+		"----------------------------------\n");
+
+	printk("INFTL Virtual Unit Chains:\n");
+	for (logical = 0; logical < s->nb_blocks; logical++) {
+		block = s->VUtable[logical];
+		if (block > s->nb_blocks)
+			continue;
+		printk("  LOGICAL %d --> %d ", logical, block);
+		for (i = 0; i < s->nb_blocks; i++) {
+			if (s->PUtable[block] == BLOCK_NIL)
+				break;
+			block = s->PUtable[block];
+			printk("%d ", block);
+		}
+		printk("\n");
+	}
+
+	printk("-------------------------------------------"
+		"----------------------------------\n");
+}
+
+int INFTL_mount(struct INFTLrecord *s)
+{
+	unsigned int block, first_block, prev_block, last_block;
+	unsigned int first_logical_block, logical_block, erase_mark;
+	int chain_length, do_format_chain;
+	struct inftl_unithead1 h0;
+	struct inftl_unittail h1;
+	int i, retlen;
+	u8 *ANACtable, ANAC;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_mount(inftl=0x%x)\n", (int)s);
+
+	/* Search for INFTL MediaHeader and Spare INFTL Media Header */
+	if (find_boot_record(s) < 0) {
+		printk(KERN_WARNING "INFTL: could not find valid boot record?\n");
+		return -1;
+	}
+
+	/* Init the logical to physical table */
+	for (i = 0; i < s->nb_blocks; i++)
+		s->VUtable[i] = BLOCK_NIL;
+
+	logical_block = block = BLOCK_NIL;
+
+	/* Temporary buffer to store ANAC numbers. */
+	ANACtable = kmalloc(s->nb_blocks * sizeof(u8), GFP_KERNEL);
+	memset(ANACtable, 0, s->nb_blocks);
+
+	/*
+	 * First pass is to explore each physical unit, and construct the
+	 * virtual chains that exist (newest physical unit goes into VUtable).
+	 * Any block that is in any way invalid will be left in the
+	 * NOTEXPLORED state. Then at the end we will try to format it and
+	 * mark it as free.
+	 */
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: pass 1, explore each unit\n");
+	for (first_block = s->firstEUN; first_block <= s->lastEUN; first_block++) {
+		if (s->PUtable[first_block] != BLOCK_NOTEXPLORED)
+			continue;
+
+		do_format_chain = 0;
+		first_logical_block = BLOCK_NIL;
+		last_block = BLOCK_NIL;
+		block = first_block;
+
+		for (chain_length = 0; ; chain_length++) {
+
+			if ((chain_length == 0) && 
+			    (s->PUtable[block] != BLOCK_NOTEXPLORED)) {
+				/* Nothing to do here, onto next block */
+				break;
+			}
+
+			if (MTD_READOOB(s->mtd, block * s->EraseSize + 8,
+			    8, &retlen, (char *)&h0) < 0 ||
+			    MTD_READOOB(s->mtd, block * s->EraseSize +
+			    2 * SECTORSIZE + 8, 8, &retlen, (char *)&h1) < 0) {
+				/* Should never happen? */
+				do_format_chain++;
+				break;
+			}
+
+			logical_block = le16_to_cpu(h0.virtualUnitNo);
+			prev_block = le16_to_cpu(h0.prevUnitNo);
+			erase_mark = le16_to_cpu((h1.EraseMark | h1.EraseMark1));
+			ANACtable[block] = h0.ANAC;
+
+			/* Previous block is relative to start of Partition */
+			if (prev_block < s->nb_blocks)
+				prev_block += s->firstEUN;
+
+			/* Already explored partial chain? */
+			if (s->PUtable[block] != BLOCK_NOTEXPLORED) {
+				/* Check if chain for this logical */
+				if (logical_block == first_logical_block) {
+					if (last_block != BLOCK_NIL)
+						s->PUtable[last_block] = block;
+				}
+				break;
+			}
+
+			/* Check for invalid block */
+			if (erase_mark != ERASE_MARK) {
+				printk(KERN_WARNING "INFTL: corrupt block %d "
+					"in chain %d, chain length %d, erase "
+					"mark 0x%x?\n", block, first_block,
+					chain_length, erase_mark);
+				/*
+				 * Assume end of chain, probably incomplete
+				 * fold/erase...
+				 */
+				if (chain_length == 0)
+					do_format_chain++;
+				break;
+			}
+
+			/* Check for it being free already then... */
+			if ((logical_block == BLOCK_FREE) ||
+			    (logical_block == BLOCK_NIL)) {
+				s->PUtable[block] = BLOCK_FREE;
+				break;
+			}
+
+			/* Sanity checks on block numbers */
+			if ((logical_block >= s->nb_blocks) ||
+			    ((prev_block >= s->nb_blocks) &&
+			     (prev_block != BLOCK_NIL))) {
+				if (chain_length > 0) {
+					printk(KERN_WARNING "INFTL: corrupt "
+						"block %d in chain %d?\n",
+						block, first_block);
+					do_format_chain++;
+				}
+				break;
+			}
+
+			if (first_logical_block == BLOCK_NIL) {
+				first_logical_block = logical_block;
+			} else {
+				if (first_logical_block != logical_block) {
+					/* Normal for folded chain... */
+					break;
+				}
+			}
+
+			/*
+			 * Current block is valid, so if we followed a virtual
+			 * chain to get here then we can set the previous
+			 * block pointer in our PUtable now. Then move onto
+			 * the previous block in the chain.
+			 */
+			s->PUtable[block] = BLOCK_NIL;
+			if (last_block != BLOCK_NIL)
+				s->PUtable[last_block] = block;
+			last_block = block;
+			block = prev_block;
+
+			/* Check for end of chain */
+			if (block == BLOCK_NIL)
+				break;
+
+			/* Validate next block before following it... */
+			if (block > s->lastEUN) {
+				printk(KERN_WARNING "INFTL: invalid previous "
+					"block %d in chain %d?\n", block,
+					first_block);
+				do_format_chain++;
+				break;
+			}
+		}
+
+		if (do_format_chain) {
+			format_chain(s, first_block);
+			continue;
+		}
+
+		/*
+		 * Looks like a valid chain then. It may not really be the
+		 * newest block in the chain, but it is the newest we have
+		 * found so far. We might update it in later iterations of
+		 * this loop if we find something newer.
+		 */
+		s->VUtable[first_logical_block] = first_block;
+		logical_block = BLOCK_NIL;
+	}
+
+#ifdef CONFIG_MTD_DEBUG_VERBOSE
+	if (CONFIG_MTD_DEBUG_VERBOSE >= 2)
+		INFTL_dumptables(s);
+#endif
+
+	/*
+	 * Second pass, check for infinite loops in chains. These are
+	 * possible because we don't update the previous pointers when
+	 * we fold chains. No big deal, just fix them up in PUtable.
+	 */
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: pass 2, validate virtual chains\n");
+	for (logical_block = 0; logical_block < s->numvunits; logical_block++) {
+		block = s->VUtable[logical_block];
+		last_block = BLOCK_NIL;
+
+		/* Check for free/reserved/nil */
+		if (block >= BLOCK_RESERVED)
+			continue;
+
+		ANAC = ANACtable[block];
+		for (i = 0; i < s->numvunits; i++) {
+			if (s->PUtable[block] == BLOCK_NIL)
+				break;
+			if (s->PUtable[block] > s->lastEUN) {
+				printk(KERN_WARNING "INFTL: invalid prev %d, "
+					"in virtual chain %d\n",
+					s->PUtable[block], logical_block);
+				s->PUtable[block] = BLOCK_NIL;
+					
+			}
+			if (ANACtable[block] != ANAC) {
+				/*
+				 * Chain must point back to itself. This is ok,
+				 * but we will need adjust the tables with this
+				 * newest block and oldest block.
+				 */
+				s->VUtable[logical_block] = block;
+				s->PUtable[last_block] = BLOCK_NIL;
+				break;
+			}
+
+			ANAC--;
+			last_block = block;
+			block = s->PUtable[block];
+		}
+
+		if (i >= s->nb_blocks) {
+			/*
+			 * Uhoo, infinite chain with valid ANACS!
+			 * Format whole chain...
+			 */
+			format_chain(s, first_block);
+		}
+	}
+
+#ifdef CONFIG_MTD_DEBUG_VERBOSE
+	if (CONFIG_MTD_DEBUG_VERBOSE >= 2)
+		INFTL_dumptables(s);
+	if (CONFIG_MTD_DEBUG_VERBOSE >= 2)
+		INFTL_dumpVUchains(s);
+#endif
+
+	/*
+	 * Third pass, format unreferenced blocks and init free block count.
+	 */
+	s->numfreeEUNs = 0;
+	s->LastFreeEUN = BLOCK_NIL;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "INFTL: pass 3, format unused blocks\n");
+	for (block = s->firstEUN; block <= s->lastEUN; block++) {
+		if (s->PUtable[block] == BLOCK_NOTEXPLORED) {
+			printk("INFTL: unreferenced block %d, formatting it\n",
+				block);
+			if (INFTL_formatblock(s, block) < 0)
+				s->PUtable[block] = BLOCK_RESERVED;
+			else
+				s->PUtable[block] = BLOCK_FREE;
+		}
+		if (s->PUtable[block] == BLOCK_FREE) {
+			s->numfreeEUNs++;
+			if (s->LastFreeEUN == BLOCK_NIL)
+				s->LastFreeEUN = block;
+		}
+	}
+
+	kfree(ANACtable);
+	return 0;
+}
Index: linux-2.4.27/drivers/mtd/maps/Makefile
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/Makefile	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/Makefile	2008-03-22 11:20:09.000000000 +0300
@@ -1,7 +1,7 @@
 #
 # linux/drivers/maps/Makefile
 #
-# $Id: Makefile,v 1.37 2003/01/24 14:26:38 dwmw2 Exp $
+# $Id: Makefile,v 1.2 2004/09/02 04:45:08 r05457 Exp $
 
 BELOW25		:= $(shell echo $(PATCHLEVEL) | sed s/[1234]/y/)
 
@@ -10,6 +10,7 @@
 endif
 
 # Chip mappings
+obj-$(CONFIG_MTD_DRAGONIX)      += dragonix_map.o
 obj-$(CONFIG_MTD_CDB89712)	+= cdb89712.o
 obj-$(CONFIG_MTD_ARM_INTEGRATOR)+= integrator-flash.o
 obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
@@ -47,19 +48,38 @@
 obj-$(CONFIG_MTD_SCx200_DOCFLASH)+= scx200_docflash.o
 obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o
 obj-$(CONFIG_MTD_OCELOT)	+= ocelot.o
+obj-$(CONFIG_MTD_KEYWEST)	+= keywest.o
+obj-$(CONFIG_MTD_SNAPGEODE)	+= snapgeode.o
+obj-$(CONFIG_MTD_SNAPARM)	+= snaparm.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
+obj-$(CONFIG_MTD_ADVANTA)	+= advanta.o
+obj-$(CONFIG_MTD_KeyTechnology)	+= keyTechnology.o
+obj-$(CONFIG_MTD_COBRA5272)     += cobra5272.o
+obj-$(CONFIG_MTD_DNP5280)	+= dnp5280.o
+obj-$(CONFIG_MTD_M5272C3)	+= m5272c3.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
 obj-$(CONFIG_MTD_PB1000)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_PB1100)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_PB1500)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
+obj-$(CONFIG_MTD_IXP425)	+= ixp425.o
+obj-$(CONFIG_MTD_SE4000)	+= se4000.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
 obj-$(CONFIG_MTD_FORTUNET)	+= fortunet.o
 obj-$(CONFIG_MTD_REDWOOD)	+= redwood.o
+obj-$(CONFIG_MTD_SUZAKU)	+= suzaku.o
 obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
+obj-$(CONFIG_MTD_DM270)		+= dm270-flash.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
+obj-$(CONFIG_MTD_NETteluC)	+= nettel-uc.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
+obj-$(CONFIG_MTD_MBVANILLA)	+= mbvanilla-flash.o
+obj-$(CONFIG_MTD_SED_SIOSIII)       += sedsios.o
+obj-$(CONFIG_MTD_BLACKFIN_533)	+= bf533-flash.o
+obj-$(CONFIG_MTD_COBRA5282)	+= cobra5282.o
+obj-$(CONFIG_MTD_FEITH)		+= feith.o
 
 include $(TOPDIR)/Rules.make
+
Index: linux-2.4.27/drivers/mtd/maps/advanta.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/advanta.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,191 @@
+/****************************************************************************/
+
+/*
+ *      advanta.c -- mappings for Adtran Advanta 3110 board.
+ *
+ *      (C) Copyright 2002, SnapGear Inc (www.snapgear.com)
+ */
+
+/****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+#include <linux/reboot.h>
+#include <asm/io.h>
+
+/****************************************************************************/
+
+#define ADVANTA_WINDOW_MAXSIZE	0x00200000
+#define ADVANTA_BUSWIDTH		1
+
+/*
+ *	PAR masks and shifts, assuming 64K pages.
+ */
+#define SC520_PAR_ADDR_MASK	0x00003fff
+#define SC520_PAR_ADDR_SHIFT	16
+#define SC520_PAR_TO_ADDR(par) \
+	(((par)&SC520_PAR_ADDR_MASK) << SC520_PAR_ADDR_SHIFT)
+
+#define SC520_PAR_SIZE_MASK	0x01ffc000
+#define SC520_PAR_SIZE_SHIFT	2
+#define SC520_PAR_TO_SIZE(par) \
+	((((par)&SC520_PAR_SIZE_MASK) << SC520_PAR_SIZE_SHIFT) + (64*1024))
+
+#define SC520_PAR(cs, addr, size) \
+	((cs) | \
+	((((size)-(64*1024)) >> SC520_PAR_SIZE_SHIFT) & SC520_PAR_SIZE_MASK) | \
+	(((addr) >> SC520_PAR_ADDR_SHIFT) & SC520_PAR_ADDR_MASK))
+
+#define SC520_PAR_BOOTCS	0x8a000000
+#define	SC520_PAR_ROMCS1	0xaa000000
+#define SC520_PAR_ROMCS2	0xca000000	/* Cache disabled, 64K page */
+
+static struct mtd_info *advanta_mtd;
+
+/****************************************************************************/
+
+static __u8 advanta_read8(struct map_info *map, unsigned long ofs)
+{
+	return(readb(map->map_priv_1 + ofs));
+}
+
+static __u16 advanta_read16(struct map_info *map, unsigned long ofs)
+{
+	return(readw(map->map_priv_1 + ofs));
+}
+
+static __u32 advanta_read32(struct map_info *map, unsigned long ofs)
+{
+	return(readl(map->map_priv_1 + ofs));
+}
+
+static void advanta_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+static void advanta_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void advanta_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void advanta_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void advanta_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+/****************************************************************************/
+
+static struct map_info advanta_map = {
+	name: "Adtran Advanta",
+	size: 256*1024,
+	buswidth: ADVANTA_BUSWIDTH,
+	read8: advanta_read8,
+	read16: advanta_read16,
+	read32: advanta_read32,
+	copy_from: advanta_copy_from,
+	write8: advanta_write8,
+	write16: advanta_write16,
+	write32: advanta_write32,
+	copy_to: advanta_copy_to
+};
+
+static struct mtd_partition advanta_partitions[] = {
+	{
+		name: "All",
+		offset: 0
+	},
+};
+
+#define NUM_PARTITIONS \
+	(sizeof(advanta_partitions)/sizeof(advanta_partitions[0]))
+
+/****************************************************************************/
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_nettel init_module
+#define cleanup_nettel cleanup_module
+#endif
+
+mod_init_t init_advanta(void)
+{
+	static void *mmcrp = NULL;
+	volatile unsigned long *par;
+	unsigned long addr, maxsize;
+	int rc;
+
+	mmcrp = (void *) ioremap_nocache(0xfffef000, 4096);
+	if (mmcrp == NULL) {
+		printk("Advanta: failed to disable MMCR cache??\n");
+		return(-EIO);
+	}
+
+	/* Set up DoC CS */
+	*(unsigned long *)(mmcrp + 0xa8) = 0x440400d0;
+
+	/* Set up OTP EPROM CS */
+	par = (volatile unsigned long *)(mmcrp + 0xc0);
+	addr = 0x20000000;
+	maxsize = ADVANTA_WINDOW_MAXSIZE;
+
+	*par = SC520_PAR(SC520_PAR_BOOTCS, addr, maxsize);
+	__asm__ ("wbinvd");
+
+	advanta_map.map_priv_1 = (unsigned long)ioremap_nocache(addr, maxsize);
+	if (!advanta_map.map_priv_1) {
+		printk("Advanta: failed to ioremap() BOOTCS\n");
+		return(-EIO);
+	}
+
+	advanta_mtd = do_map_probe("map_rom", &advanta_map);
+	if (!advanta_mtd) {
+		iounmap((void *)advanta_map.map_priv_1);
+		return(-ENXIO);
+	}
+
+	rc = add_mtd_partitions(advanta_mtd, advanta_partitions,
+		NUM_PARTITIONS);
+
+	return rc;
+}
+
+/****************************************************************************/
+
+mod_exit_t cleanup_advanta(void)
+{
+	if (advanta_mtd) {
+		del_mtd_partitions(advanta_mtd);
+		map_destroy(advanta_mtd);
+	}
+	if (advanta_map.map_priv_1) {
+		iounmap((void *)advanta_map.map_priv_1);
+		advanta_map.map_priv_1 = 0;
+	}
+}
+
+/****************************************************************************/
+
+module_init(init_advanta);
+module_exit(cleanup_advanta);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Philip Craig <philipc@snapgear.com>");
+MODULE_DESCRIPTION("Adtran Advanta 3110 OTP EPROM support");
+
+/****************************************************************************/
Index: linux-2.4.27/drivers/mtd/maps/bf533-flash.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/bf533-flash.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,168 @@
+/*
+ * Flash memory access on BlackFin BF533 based devices
+ * 
+ * (C) 2000 Nicolas Pitre <nico@cam.org>
+ * 
+ * $Id$
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#ifndef CONFIG_BLACKFIN_EZKIT
+#error This is for BlackFin ADDS-BF533-EZLITE boards only
+#endif
+
+
+#define WINDOW_ADDR 0x20000000
+
+#ifndef lo
+# define lo(addr)	(addr & 0xFFFF)
+#endif
+#ifndef hi
+# define hi(addr)	(addr >> 16)
+#endif
+
+static __u16 bf533_read16(struct map_info *map, unsigned long ofs)
+{
+	int nValue = 0x0;
+	__asm__ __volatile__ (
+		"p2.l = 0x0000; \n\t"
+		"p2.h = 0x2000; \n\t"
+		"r3 = %1; \n\t"
+		"r2 = p2; \n\t"
+		"r2 = r2 + r3; \n\t"
+		"p2 = r2; \n\t"
+		/* The actual thing */
+		"ssync; \n\t"
+		"%0 = w[p2] (z); \n\t"
+		"ssync; \n\t"
+		: "=d" (nValue)
+		: "d" (ofs));
+	return (__u16)nValue;
+}
+
+static void bf533_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	unsigned long i;
+
+	for (i = 0; i < len; i += 2)
+		*((u16*)(to + i)) = bf533_read16(map, from + i);
+	if (len & 0x01)
+		*((u8*)(to + (i-1))) = (u8)(bf533_read16(map, from + i) >> 8);
+}
+
+static void bf533_write16(struct map_info *map, __u16 d, unsigned long ofs)
+{
+	__asm__ __volatile__ (
+		"p2.l = 0x0000; \n\t"
+		"p2.h = 0x2000; \n\t"
+		"r3 = %1; \n\t"
+		"r2 = p2; \n\t"
+		"r2 = r2 + r3; \n\t"
+		"p2 = r2; \n\t"
+		/* The actual thing */
+		"ssync; \n\t"
+		"w[p2] = %0; \n\t"
+		"ssync; \n\t"
+		: 
+		: "d" (d), "d" (ofs));
+}
+
+static void bf533_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(WINDOW_ADDR + to), from, len);
+}
+
+static struct map_info bf533_map = {
+	name:		"BF533 flash",
+	read8:		NULL,
+	read16:		bf533_read16,
+	read32:		NULL,
+	copy_from:	bf533_copy_from,
+	write8:		NULL,
+	write16:	bf533_write16,
+	write32:	NULL,
+	copy_to:	bf533_copy_to
+};
+
+
+/*
+ * Here are partition information for all known BlackFin-based devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ * 
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must correspond to the 
+ * value specified in the mapping definition defined by the
+ * "struct map_desc *_io_desc" for the corresponding machine.
+ */
+
+static unsigned long bf533_max_flash_size = 0x00200000;
+static struct mtd_partition bf533_partitions[] = {
+	{
+		name: "bootloader",
+		size: 0x00010000,
+		offset: 0,
+		mask_flags: MTD_CAP_ROM
+	},{
+		name: "kernel image",
+		size: MTDPART_SIZ_FULL,
+		offset: MTDPART_OFS_APPEND
+	}
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+
+int __init bf533_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	bf533_map.buswidth = 2;
+	bf533_map.size = bf533_max_flash_size;
+
+	printk(KERN_NOTICE "BF533 flash: probing %d-bit flash bus\n", bf533_map.buswidth*8);
+	mymtd = do_map_probe("stm_flash", &bf533_map);
+	if (!mymtd)
+		return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+#ifdef CONFIG_BLACKFIN_EZKIT
+	parts = bf533_partitions;
+	nb_parts = NB_OF(bf533_partitions);
+#endif
+
+	if (nb_parts == 0) {
+		printk(KERN_NOTICE "BF533 flash: no partition info available, registering whole flash at once\n");
+		add_mtd_device(mymtd);
+	} else {
+		printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+		add_mtd_partitions(mymtd, parts, nb_parts);
+	}
+	return 0;
+}
+
+static void __exit bf533_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+}
+
+module_init(bf533_mtd_init);
+module_exit(bf533_mtd_cleanup);
Index: linux-2.4.27/drivers/mtd/maps/ceiva.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/ceiva.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/ceiva.c	2008-03-22 11:19:21.000000000 +0300
@@ -318,7 +318,7 @@
 	return nr;
 }
 
-extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts, unsigned long fis_origin);
 extern int parse_cmdline_partitions(struct mtd_info *master, struct mtd_partition **pparts, char *);
 
 static struct mtd_partition *parsed_parts;
@@ -339,7 +339,7 @@
 		}
 #endif
 #ifdef CONFIG_MTD_REDBOOT_PARTS
-		nr_parts = parse_redboot_partitions(mtd, &parsed_parts);
+		nr_parts = parse_redboot_partitions(mtd, &parsed_parts, 0);
 		if (nr_parts > 0) {
 			part_type = "RedBoot";
 			break;
Index: linux-2.4.27/drivers/mtd/maps/cobra5272.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/cobra5272.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,220 @@
+/*
+ * This file is "heavily based" ;) on physmap.c, which I copied
+ * and changed to suit my needs! But to show who is responsible
+ * for the file I included the new copyright. I don't know if that
+ * is the correct way, so if this should be a problem, please
+ * email me! 
+ * 
+ * (C) 2002 senTec Elektronik GmbH, Heiko Degenhardt
+ * <linux@sentec-elektronik.de>
+ * 
+ * ----------------------------------------------------------------------
+ * File:       cobra5272.c
+ * Place:      uClinux-dist/linux-2.4.x/drivers/mtd/maps/
+ * Author:     Heiko Degenhardt (linux@sentec-elektronik.de)
+ * Contents:   Flash layout of the COBRA5272 board.
+ * Version:    v01.00
+ * Date:       Mon Mar 25 09:01:01 CET 2002
+ * ______________________________________________________________________
+ *
+ * CHANGES
+ * 020325   v01.00 Creation from physmap.c
+ *          (hede)
+ * ______________________________________________________________________
+ *
+ *  This program is free software; you can redistribute  it and/or
+ *  modify it under  the terms of  the GNU General  Public License as
+ *  published by the Free Software Foundation;  either version 2 of
+ *  the  License, or (at your option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR
+ *  IMPLIED WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED
+ *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED.  IN NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE
+ *  FOR ANY   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   TO,
+ *  PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE, DATA,
+ *  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ *  SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License
+ *  along with this program; if not, write  to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Mappings of chips in memory of the senTec COBRA5272 board.
+ * 
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+
+#define WINDOW_ADDR 0xffe00000
+#define WINDOW_SIZE 0x200000
+#define BUSWIDTH 2
+
+static struct mtd_info *mymtd;
+
+__u8 cb5272map_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 cb5272map_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 cb5272map_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void cb5272map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void cb5272map_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cb5272map_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cb5272map_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cb5272map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info cb5272map_map = {
+	name: "Physically mapped flash of COBRA5272",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8: cb5272map_read8,
+	read16: cb5272map_read16,
+	read32: cb5272map_read32,
+	copy_from: cb5272map_copy_from,
+	write8: cb5272map_write8,
+	write16: cb5272map_write16,
+	write32: cb5272map_write32,
+	copy_to: cb5272map_copy_to
+};
+
+/*
+ * MTD 'PARTITIONING' STUFF 
+ */
+#define NUM_PARTITIONS 10
+static struct mtd_partition nettel_partitions[NUM_PARTITIONS] = {
+        {
+                name: "boot (16K)",
+                size: 0x4000,
+                offset: 0
+        },
+        {
+                name: "kernel (512K)",
+                size: 0x80000,
+                offset: 0x80000
+        },
+        {
+                name: "rootfs (1024K)",
+                size: 0x100000,
+                offset: 0x100000
+        },
+	{
+                name: "spare (8K)",
+                size: 0x2000,
+                offset: 0x4000
+        },
+        {
+                name: "spare (8K)",
+                size: 0x2000,
+                offset: 0x6000
+        },
+        {
+                name: "spare (256K)",
+                size: 0x40000,
+                offset: 0x40000
+        },
+        {
+                name: "complete (2048K)",
+                size: 0x200000,
+                offset: 0x0
+        },
+        {
+                name: "boot J13 (256K)",
+                size: 0x40000,
+                offset: 0x100000
+        },
+        {
+                name: "kernel J13 (512K)",
+                size: 0x80000,
+                offset: 0x140000
+        },
+        {
+                name: "rootfs J13 (256K)",
+                size: 0x40000,
+                offset: 0x1c0000
+        }
+};
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_cb5272map init_module
+#define cleanup_cb5272map cleanup_module
+#endif
+
+int __init init_cb5272map(void)
+{
+  	printk(KERN_NOTICE "cb5272map flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	cb5272map_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!cb5272map_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &cb5272map_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+		return add_mtd_partitions(mymtd, nettel_partitions, NUM_PARTITIONS);
+	}
+
+	iounmap((void *)cb5272map_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_cb5272map(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (cb5272map_map.map_priv_1) {
+		iounmap((void *)cb5272map_map.map_priv_1);
+		cb5272map_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_cb5272map);
+module_exit(cleanup_cb5272map);
+
Index: linux-2.4.27/drivers/mtd/maps/cobra5282.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/cobra5282.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,221 @@
+/*
+ * This file is "heavily based" ;) on physmap.c, which I copied
+ * and changed to suit my needs! But to show who is responsible
+ * for the file I included the new copyright. I don't know if that
+ * is the correct way, so if this should be a problem, please
+ * email me! 
+ * 
+ * (C) 2004 senTec Elektronik GmbH, Heiko Degenhardt
+ * <linux@sentec-elektronik.de>
+ * 
+ * ----------------------------------------------------------------------
+ * File:       cobra5282.c
+ * Place:      uClinux-dist/linux-2.4.x/drivers/mtd/maps/
+ * Author:     Heiko Degenhardt (linux@sentec-elektronik.de)
+ *             Wolfgang Elsner (linux@sentec-elektronik.de)
+ * Contents:   Flash layout of the COBRA5282 board.
+ * Version:    v01.00
+ * Date:       
+ * ______________________________________________________________________
+ *
+ * CHANGES
+ * 040324   v01.00 Creation from cobra5272.c
+ *          (woel)
+ * ______________________________________________________________________
+ *
+ *  This program is free software; you can redistribute  it and/or
+ *  modify it under  the terms of  the GNU General  Public License as
+ *  published by the Free Software Foundation;  either version 2 of
+ *  the  License, or (at your option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR
+ *  IMPLIED WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED
+ *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED.  IN NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE
+ *  FOR ANY   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   TO,
+ *  PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE, DATA,
+ *  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ *  SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License
+ *  along with this program; if not, write  to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Mappings of chips in memory of the senTec COBRA5282 board.
+ * 
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+
+#define WINDOW_ADDR 0xffc00000
+#define WINDOW_SIZE 0x400000
+#define BUSWIDTH 2
+
+static struct mtd_info *mymtd;
+
+__u8 cb5282map_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 cb5282map_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 cb5282map_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void cb5282map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void cb5282map_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cb5282map_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cb5282map_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void cb5282map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info cb5282map_map = {
+	name: "Physically mapped flash of COBRA5282",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8: cb5282map_read8,
+	read16: cb5282map_read16,
+	read32: cb5282map_read32,
+	copy_from: cb5282map_copy_from,
+	write8: cb5282map_write8,
+	write16: cb5282map_write16,
+	write32: cb5282map_write32,
+	copy_to: cb5282map_copy_to
+};
+
+/*
+ * MTD 'PARTITIONING' STUFF 
+ */
+#define NUM_PARTITIONS 10
+static struct mtd_partition nettel_partitions[NUM_PARTITIONS] = {
+        {
+                name: "boot (16K)",
+                size: 0x4000,
+                offset: 0
+        },
+        {
+                name: "kernel (512K)",
+                size: 0x80000,
+                offset: 0x80000
+        },
+        {
+                name: "rootfs (1024K)",
+                size: 0x100000,
+                offset: 0x100000
+        },
+	{
+                name: "spare (8K)",
+                size: 0x2000,
+                offset: 0x4000
+        },
+        {
+                name: "spare (8K)",
+                size: 0x2000,
+                offset: 0x6000
+        },
+        {
+                name: "spare (256K)",
+                size: 0x40000,
+                offset: 0x40000
+        },
+        {
+                name: "complete (2048K)",
+                size: 0x200000,
+                offset: 0x0
+        },
+        {
+                name: "boot J13 (256K)",
+                size: 0x40000,
+                offset: 0x100000
+        },
+        {
+                name: "kernel J13 (512K)",
+                size: 0x80000,
+                offset: 0x140000
+        },
+        {
+                name: "rootfs J13 (256K)",
+                size: 0x40000,
+                offset: 0x1c0000
+        }
+};
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_cb5282map init_module
+#define cleanup_cb5282map cleanup_module
+#endif
+
+int __init init_cb5282map(void)
+{
+  	printk(KERN_NOTICE "cb5282map flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	cb5282map_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!cb5282map_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &cb5282map_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+		return add_mtd_partitions(mymtd, nettel_partitions, NUM_PARTITIONS);
+	}
+
+	iounmap((void *)cb5282map_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_cb5282map(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (cb5282map_map.map_priv_1) {
+		iounmap((void *)cb5282map_map.map_priv_1);
+		cb5282map_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_cb5282map);
+module_exit(cleanup_cb5282map);
+
Index: linux-2.4.27/drivers/mtd/maps/coyote.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/coyote.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,222 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+
+#include <linux/notifier.h>
+
+#define WINDOW_ADDR 	0x50000000
+#define BUSWIDTH 	2
+#define WINDOW_SIZE	0x01000000
+
+#ifndef __ARMEB__
+#define	B_0(h)	((h) & 0xFF)
+#define	B_1(h)	(((h) >> 8) & 0xFF)
+#else
+#define	B_0(h)	(((h) >> 8) & 0xFF)
+#define	B_1(h)	((h) & 0xFF)
+#endif
+
+static __u16 coyote_read16(struct map_info *map, unsigned long ofs)
+{
+    return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+/*
+ * The IXP425 expansion bus only allows 16-bit wide acceses
+ * when attached to a 16-bit wide device (such as the 28F128J3A),
+ * so we can't use a memcpy_fromio as it does byte acceses.
+ */
+static void coyote_copy_from(struct map_info *map, void *to,
+    unsigned long from, ssize_t len)
+{
+	int i;
+	u8 *dest = (u8*)to;
+	u16 *src = (u16 *)(map->map_priv_1 + from);
+	u16 data;
+
+	for(i = 0; i < (len / 2); i++) {
+		data = src[i];
+		dest[i * 2] = B_0(data);
+		dest[i * 2 + 1] = B_1(data);
+	}
+
+	if(len & 1)
+		dest[len - 1] = B_0(src[i]);
+}
+
+static void coyote_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+    *(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static struct map_info coyote_map = {
+	name: 		"IXP425 Residential Gateway Demo Platform Flash",
+	buswidth: 	BUSWIDTH,
+	read16:		coyote_read16,
+	copy_from:	coyote_copy_from,
+	write16:	coyote_write16,
+};
+
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+static struct mtd_partition *parsed_parts;
+#endif
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+/*
+ *	Set the Intel flash back to read mode as MTD may leave it in command mode
+ */
+
+static int coyote_reboot_notifier(
+	struct notifier_block *nb,
+	unsigned long val,
+	void *v)
+{
+	struct cfi_private *cfi = coyote_map.fldrv_priv;
+	int i;
+	
+	for (i = 0; cfi && i < cfi->numchips; i++)
+		cfi_send_gen_cmd(0xff, 0x55, cfi->chips[i].start, &coyote_map,
+				cfi, cfi->device_type, NULL);
+
+	return(NOTIFY_OK);
+}
+
+static struct notifier_block coyote_notifier_block = {
+	coyote_reboot_notifier, NULL, 0
+};
+
+#endif
+
+
+static struct mtd_partition coyote_partitions[] = {
+    {
+	name:	"image",
+	offset:	0x00040000,
+	size:	0x00400000, /* 4M for linux kernel + cramfs + initrd image */
+    },
+    {
+	name:	"user",
+	offset:	0x00440000,
+	size:	0x00B80000, /* Rest of flash space minus redboot configuration
+	                     * sectors (-256k) at the end of flash
+			     */
+    },
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *coyote_mtd;
+static struct resource *mtd_resource;
+
+static void coyote_exit(void)
+{
+    if (coyote_mtd)
+    {
+	del_mtd_partitions(coyote_mtd);
+	map_destroy(coyote_mtd);
+    }
+    if (coyote_map.map_priv_1)
+	iounmap((void *)coyote_map.map_priv_1);
+    if (mtd_resource)
+	release_mem_region(WINDOW_ADDR, WINDOW_SIZE);
+    
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+    if (parsed_parts)
+	kfree(parsed_parts);
+#endif
+
+    /* Disable flash write */
+    *IXP425_EXP_CS0 &= ~IXP425_FLASH_WRITABLE;
+}
+
+static int __init coyote_init(void)
+{
+    int res, npart;
+
+    /* Enable flash write */
+    *IXP425_EXP_CS0 |= IXP425_FLASH_WRITABLE;
+
+    coyote_map.map_priv_1 = 0;
+    mtd_resource = 
+	request_mem_region(WINDOW_ADDR, WINDOW_SIZE, "IXP425 Residential Gateway Demo Platform Flash");
+    if (!mtd_resource)
+    {
+	printk(KERN_ERR "IXP425 Residential Gateway Demo Platform Flash: Could not request mem region.\n" );
+	res = -ENOMEM;
+	goto Error;
+    }
+
+    coyote_map.map_priv_1 =
+	(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+    if (!coyote_map.map_priv_1)
+    {
+	printk("IXP425 Residential Gateway Demo Platform Flash: Failed to map IO region. (ioremap)\n");
+	res = -EIO;
+	goto Error;
+    }
+    coyote_map.size = WINDOW_SIZE;
+
+
+    /* 
+     * Probe for the CFI complaint chip
+     * suposed to be 28F128J3A
+     */
+    coyote_mtd = do_map_probe("cfi_probe", &coyote_map);
+    if (!coyote_mtd)
+    {
+	res = -ENXIO;
+	goto Error;
+    }
+    coyote_mtd->module = THIS_MODULE;
+   
+    /* Initialize flash partiotions 
+     * Note: Redeboot partition info table can be parsed by MTD, and used
+     *       instead of hard-coded partions. TBD
+     */
+
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+    /* Try to parse RedBoot partitions */
+    npart = parse_redboot_partitions(coyote_mtd, &parsed_parts, 0);
+    if (npart > 0)
+    {
+	/* found "npart" RedBoot partitions */
+	
+	res = add_mtd_partitions(coyote_mtd, parsed_parts, npart);
+    }
+    else   
+	res = -EIO;
+
+    if (res)
+#endif
+    {
+	printk("Using predefined MTD partitions.\n");
+	/* RedBoot partitions not found - use hardcoded partition table */
+	res = add_mtd_partitions(coyote_mtd, coyote_partitions,
+	    NB_OF(coyote_partitions));
+    }
+
+    if (res)
+	goto Error;
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	register_reboot_notifier(&coyote_notifier_block);
+#endif
+
+    return res;
+Error:
+    coyote_exit();
+    return res;
+}
+
+module_init(coyote_init);
+module_exit(coyote_exit);
+
+MODULE_DESCRIPTION("MTD map driver for IXP425 Residential Gateway Demo Platform");
+
Index: linux-2.4.27/drivers/mtd/maps/dm270-flash.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/dm270-flash.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,280 @@
+/***********************************************************************
+ * drivers/mtd/maps/dm270-flash.c
+ *
+ *   Flash memory access on TI TMS320DM270 based devices
+ *
+ *   Derived from drivers/mtd/maps/sa1100-flash.c
+ *
+ *   Copyright (C) 2004 InnoMedia Pte Ltd. All rights reserved.
+ *   cheetim_loh@innomedia.com.sg  <www.innomedia.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ * WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ * USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ ***********************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#ifndef CONFIG_ARCH_DM270
+#error This is for DM270 architecture only
+#endif
+
+#define BUSWIDTH 	2
+
+static __u8 dm270_read8(struct map_info *map, unsigned long ofs)
+{
+	return(*((__u8 *) (map->map_priv_1 + ofs)));
+}
+
+static __u16 dm270_read16(struct map_info *map, unsigned long ofs)
+{
+	return(*((__u16 *) (map->map_priv_1 + ofs)));
+}
+
+static __u32 dm270_read32(struct map_info *map, unsigned long ofs)
+{
+	return(*((__u32 *) (map->map_priv_1 + ofs)));
+}
+
+static void dm270_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void dm270_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*((__u8 *) (map->map_priv_1 + adr)) = d;
+}
+
+static void dm270_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*((__u16 *) (map->map_priv_1 + adr)) = d;
+}
+
+static void dm270_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*((__u32 *) (map->map_priv_1 + adr)) = d;
+}
+
+static void dm270_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info dm270_map = {
+	name:		"DM270 flash",
+	read8:		dm270_read8,
+	read16:		dm270_read16,
+	read32:		dm270_read32,
+	copy_from:	dm270_copy_from,
+	write8:		dm270_write8,
+	write16:	dm270_write16,
+	write32:	dm270_write32,
+	copy_to:	dm270_copy_to,
+
+	map_priv_1:	FLASH_MEM_BASE,
+	map_priv_2:	-1,
+};
+
+
+/*
+ * Here are partition information for all known DM270-based devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ *
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must be no more than
+ * the value specified in the "struct map_desc *_io_desc" mapping
+ * definition for the corresponding machine.
+ *
+ * Please keep these in alphabetical order, and formatted as per existing
+ * entries.  Thanks.
+ */
+
+#ifdef CONFIG_ARCH_DM270
+/*
+ * 1 x Toshiba TC58FVB160AFT-70 16-MBIT (2M x 8 bits / 1M x 16 bits) CMOS FLASH MEMORY
+ *   Block erase architecture:
+ *   1 X 16 Kbytes / 2 x 8 Kbytes / 1 x 32 Kbytes / 31 x 64 Kbytes
+ */
+static struct mtd_partition dm270_partitions[] = {
+	{
+		name:		"bootloader",
+		size:		0x20000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"kernel",
+		size:		0xc0000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}, {
+		name:		"rootfs",
+		size:		0x110000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	0,              /* read-write */
+	}, {
+		name:		"bootloader params",
+		size:		0x10000,
+		offset:		MTDPART_OFS_APPEND,
+		mask_flags:	MTD_WRITEABLE,  /* force read-only */
+	}
+};
+#endif
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts, unsigned long fis_origin);
+extern int parse_cmdline_partitions(struct mtd_info *master, struct mtd_partition **pparts, char *);
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init dm270_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0, ret;
+	int parsed_nr_parts = 0;
+	const char *part_type;
+	unsigned long base = -1UL;
+
+	/* Default flash buswidth */
+	dm270_map.buswidth = BUSWIDTH;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+
+#ifdef CONFIG_ARCH_DM270
+	if (machine_is_dm270()) {
+		parts = dm270_partitions;
+		nb_parts = ARRAY_SIZE(dm270_partitions);
+		dm270_map.size = FLASH_SIZE;
+		dm270_map.buswidth = BUSWIDTH;
+		base = FLASH_MEM_BASE;
+	}
+#endif
+
+	/*
+	 * For simple flash devices, use ioremap to map the flash.
+	 */
+	if (base != (unsigned long)-1) {
+		if (!request_mem_region(base, dm270_map.size, "flash")) {
+			printk(KERN_ERR "dm270 flash: Could not request mem region %lx at %lx.\n",
+					dm270_map.size, base);
+			return -ENOMEM;
+		}
+		dm270_map.map_priv_2 = base;
+		dm270_map.map_priv_1 = (unsigned long)
+				ioremap(base, dm270_map.size);
+		if (!dm270_map.map_priv_1) {
+			printk(KERN_ERR "dm270 Flash: Failed to map IO region %lx at %lx.\n",
+					dm270_map.size, base);
+			ret = -EIO;
+			goto out_err;
+		}
+	}
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "DM270 flash: probing %d-bit flash bus\n", dm270_map.buswidth*8);
+	mymtd = do_map_probe("cfi_probe", &dm270_map);
+	ret = -ENXIO;
+	if (!mymtd)
+		goto out_err;
+	mymtd->module = THIS_MODULE;
+
+	/*
+	 * Dynamic partition selection stuff (might override the static ones)
+	 */
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+	if (parsed_nr_parts == 0) {
+		int ret = parse_redboot_partitions(mymtd, &parsed_parts, FLASH_MEM_BASE);
+
+		if (ret > 0) {
+			part_type = "RedBoot";
+			parsed_nr_parts = ret;
+		}
+	}
+#endif
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	if (parsed_nr_parts == 0) {
+		int ret = parse_cmdline_partitions(mymtd, &parsed_parts, "dm270");
+		if (ret > 0) {
+			part_type = "Command Line";
+			parsed_nr_parts = ret;
+		}
+	}
+#endif
+
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+		nb_parts = parsed_nr_parts;
+	}
+
+	if (nb_parts == 0) {
+		printk(KERN_NOTICE "DM270 flash: no partition info available, registering whole flash at once\n");
+		add_mtd_device(mymtd);
+	} else {
+		printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+		add_mtd_partitions(mymtd, parts, nb_parts);
+	}
+	return 0;
+
+ out_err:
+	if (dm270_map.map_priv_2 != -1) {
+		iounmap((void *)dm270_map.map_priv_1);
+		release_mem_region(dm270_map.map_priv_2, dm270_map.size);
+	}
+	return ret;
+}
+
+static void __exit dm270_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+	if (dm270_map.map_priv_2 != -1) {
+		iounmap((void *)dm270_map.map_priv_1);
+		release_mem_region(dm270_map.map_priv_2, dm270_map.size);
+	}
+}
+
+module_init(dm270_mtd_init);
+module_exit(dm270_mtd_cleanup);
+
+MODULE_AUTHOR("Chee Tim Loh");
+MODULE_DESCRIPTION("DM270 CFI map driver");
+MODULE_LICENSE("GPL");
Index: linux-2.4.27/drivers/mtd/maps/dc21285.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/dc21285.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/dc21285.c	2008-03-22 11:19:21.000000000 +0300
@@ -108,7 +108,7 @@
 /* Partition stuff */
 static struct mtd_partition *dc21285_parts;
 		      
-extern int parse_redboot_partitions(struct mtd_info *, struct mtd_partition **);
+extern int parse_redboot_partitions(struct mtd_info *, struct mtd_partition **, unsigned long fis_origin);
 
 int __init init_dc21285(void)
 {
@@ -146,7 +146,7 @@
 		/* partition fixup */
 
 #ifdef CONFIG_MTD_REDBOOT_PARTS
-		nrparts = parse_redboot_partitions(mymtd, &dc21285_parts);
+		nrparts = parse_redboot_partitions(mymtd, &dc21285_parts, 0);
 #endif
 		if (nrparts > 0) {
 			add_mtd_partitions(mymtd, dc21285_parts, nrparts);
Index: linux-2.4.27/drivers/mtd/maps/dnp5280.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/dnp5280.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,189 @@
+/*
+ * This file is "heavily based" ;) on physmap.c, which I copied
+ * and changed to suit my needs! But to show who is responsible
+ * for the file I included the new copyright. I don't know if that
+ * is the correct way, so if this should be a problem, please
+ * email me! 
+ * 
+ * (C) 2003 SSV Embedded Systems <support@ist1.de>
+ * 
+ * ----------------------------------------------------------------------
+ * File:       dnp5280.c
+ * Place:      uClinux-dist/linux-2.4.x/drivers/mtd/maps/
+ * Author:     Heiko Degenhardt. For support please contact
+ *             M. Hasewinkel" <support@ist1.de>
+ * Contents:   Flash layout of the DNP5280 board.
+ * Version:    v01.00
+ * Date:       Thu Sep  4 13:52:19 CEST 2003
+ * ______________________________________________________________________
+ *
+ * CHANGES
+ * 030904   v01.00 Creation from physmap.c
+ *          (hede)
+ * ______________________________________________________________________
+ *
+ *  This program is free software; you can redistribute  it and/or
+ *  modify it under  the terms of  the GNU General  Public License as
+ *  published by the Free Software Foundation;  either version 2 of
+ *  the  License, or (at your option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR
+ *  IMPLIED WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED
+ *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED.  IN NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE
+ *  FOR ANY   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   TO,
+ *  PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE, DATA,
+ *  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ *  SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License
+ *  along with this program; if not, write  to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Mappings of chips in memory of the senTec COBRA5272 board.
+ * 
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+
+#define WINDOW_ADDR 0xff800000
+#define WINDOW_SIZE 0x800000
+#define BUSWIDTH 2
+
+static struct mtd_info *mymtd;
+
+__u8 dnp5280map_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 dnp5280map_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 dnp5280map_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void dnp5280map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void dnp5280map_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dnp5280map_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dnp5280map_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dnp5280map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info dnp5280map_map = {
+	name: "Physically mapped flash of DNP5280",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8: dnp5280map_read8,
+	read16: dnp5280map_read16,
+	read32: dnp5280map_read32,
+	copy_from: dnp5280map_copy_from,
+	write8: dnp5280map_write8,
+	write16: dnp5280map_write16,
+	write32: dnp5280map_write32,
+	copy_to: dnp5280map_copy_to
+};
+
+/*
+ * MTD 'PARTITIONING' STUFF 
+ *
+ * ATTENTION! This is just an example!
+ * 
+ */
+#define NUM_PARTITIONS 3
+
+static struct mtd_partition dnp5280_partitions[NUM_PARTITIONS] = {
+        {
+                name: "dBUG",
+                size: 0x50000,
+                offset: 0
+        },
+        {
+                name: "uClinux",
+                size: 0x2B0000,
+                offset: 0x50000
+        },
+        {
+                name: "flash space",
+                size: 0x500000,
+                offset: 0x300000
+        }
+};
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_dnp5280map init_module
+#define cleanup_dnp5280map cleanup_module
+#endif
+
+int __init init_dnp5280map(void)
+{
+  	printk(KERN_NOTICE "dnp5280map flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	dnp5280map_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!dnp5280map_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &dnp5280map_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+		return add_mtd_partitions(mymtd, dnp5280_partitions, NUM_PARTITIONS);
+	}
+
+	iounmap((void *)dnp5280map_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_dnp5280map(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (dnp5280map_map.map_priv_1) {
+		iounmap((void *)dnp5280map_map.map_priv_1);
+		dnp5280map_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_dnp5280map);
+module_exit(cleanup_dnp5280map);
+
Index: linux-2.4.27/drivers/mtd/maps/dnp5282.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/dnp5282.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,189 @@
+/*
+ * This file is "heavily based" ;) on physmap.c, which I copied
+ * and changed to suit my needs! But to show who is responsible
+ * for the file I included the new copyright. I don't know if that
+ * is the correct way, so if this should be a problem, please
+ * email me! 
+ * 
+ * (C) 2003 SSV Embedded Systems <support@ist1.de>
+ * 
+ * ----------------------------------------------------------------------
+ * File:       dnp5282.c
+ * Place:      uClinux-dist/linux-2.4.x/drivers/mtd/maps/
+ * Author:     Heiko Degenhardt. For support please contact
+ * 				M. Hasewinkel" <support@ist1.de>
+ * Contents:   Flash layout of the DNP5282 board.
+ * Version:    v01.00
+ * Date:       Thu Sep  4 13:52:19 CEST 2003
+ * ______________________________________________________________________
+ *
+ * CHANGES
+ * 030904   v01.00 Creation from physmap.c
+ *          (hede)
+ * ______________________________________________________________________
+ *
+ *  This program is free software; you can redistribute  it and/or
+ *  modify it under  the terms of  the GNU General  Public License as
+ *  published by the Free Software Foundation;  either version 2 of
+ *  the  License, or (at your option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR
+ *  IMPLIED WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED
+ *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED.  IN NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE
+ *  FOR ANY   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   TO,
+ *  PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE, DATA,
+ *  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ *  SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License
+ *  along with this program; if not, write  to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Mappings of chips in memory of the senTec COBRA5272 board.
+ * 
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+
+#define WINDOW_ADDR 0xff800000
+#define WINDOW_SIZE 0x800000
+#define BUSWIDTH 2
+
+static struct mtd_info *mymtd;
+
+__u8 dnp5282map_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 dnp5282map_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 dnp5282map_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void dnp5282map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void dnp5282map_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dnp5282map_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dnp5282map_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void dnp5282map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info dnp5282map_map = {
+	name: "Physically mapped flash of DNP5282",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8: dnp5282map_read8,
+	read16: dnp5282map_read16,
+	read32: dnp5282map_read32,
+	copy_from: dnp5282map_copy_from,
+	write8: dnp5282map_write8,
+	write16: dnp5282map_write16,
+	write32: dnp5282map_write32,
+	copy_to: dnp5282map_copy_to
+};
+
+/*
+ * MTD 'PARTITIONING' STUFF 
+ *
+ * ATTENTION! This is just an example!
+ * 
+ */
+#define NUM_PARTITIONS 3
+
+static struct mtd_partition dnp5282_partitions[NUM_PARTITIONS] = {
+        {
+                name: "vectors (64K)",
+                size: 0x10000,
+                offset: 0
+        },
+        {
+                name: "kernel (2MB)",
+                size: 0x200000,
+                offset: 0x50000
+        },
+        {
+                name: "spare (4MB)",
+                size: 0x400000,
+                offset: 0x40000
+        }
+};
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_dnp5282map init_module
+#define cleanup_dnp5282map cleanup_module
+#endif
+
+int __init init_dnp5282map(void)
+{
+  	printk(KERN_NOTICE "dnp5282map flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	dnp5282map_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!dnp5282map_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &dnp5282map_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+		return add_mtd_partitions(mymtd, dnp5282_partitions, NUM_PARTITIONS);
+	}
+
+	iounmap((void *)dnp5282map_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_dnp5282map(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (dnp5282map_map.map_priv_1) {
+		iounmap((void *)dnp5282map_map.map_priv_1);
+		dnp5282map_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_dnp5282map);
+module_exit(cleanup_dnp5282map);
+
Index: linux-2.4.27/drivers/mtd/maps/dragonix_map.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/dragonix_map.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,147 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define WINDOW_ADDR 0x02200000
+#define WINDOW_SIZE 0x00200000
+#define BUSWIDTH 2
+
+#define __raw_readb readb
+#define __raw_readl readl
+#define __raw_readw readw
+
+static struct mtd_info *mymtd;
+
+
+static __u8 dragonix_read8(struct map_info *map,unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+static __u16 dragonix_read16(struct map_info *map,unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+static __u32 dragonix_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+static void dragonix_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void dragonix_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void dragonix_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void dragonix_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void dragonix_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+/*
+static struct mtd_partition dragonix_partition[]={
+    { 
+	    name: "Dragonix Bootloader", 
+	    offset: 0, 
+	    size:   0x20000,
+    },
+    {
+	   name:"Dragonix Kernel",
+	   offset:0x20000,
+	   size:0x7e0000,
+    },
+    { 
+	    name: "dragonix RamDisk", /////
+	    offset: 0x800000,
+	    size:0x800000, 
+    }
+};
+*/
+
+// Test partition
+static struct mtd_partition dragonix_partition[]={
+    { 
+	    name: "Dragonix Bootloader", 
+	    offset: 0, 
+	    size:   0x200000,
+    }
+};
+
+#define NUM_PARTITIONS (sizeof(dragonix_partition)/sizeof(dragonix_partition[0]))
+
+
+struct map_info dragonix_map = {
+	name: "Dragonix VZ Flash map",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8: dragonix_read8,
+	read16: dragonix_read16,
+	read32: dragonix_read32,
+	copy_from: dragonix_copy_from,
+	write8: dragonix_write8,
+	write16: dragonix_write16,
+	write32: dragonix_write32,
+	copy_to: dragonix_copy_to,
+};
+
+
+static  int __init init_dragonix(void)
+{
+	printk(KERN_NOTICE "Dragonix VZ mapping:size %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	dragonix_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	printk("ZEUS:dragonix_map.map_priv_1=%x\n",dragonix_map.map_priv_1);
+	if (!dragonix_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	
+	mymtd = do_map_probe("cfi_probe", &dragonix_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_partitions( mymtd, dragonix_partition, NUM_PARTITIONS );
+
+		add_mtd_device(mymtd);
+		printk("ZEUS:right end of init_dragonix(I mean flash)\n");
+		return 0;
+	}
+	
+	iounmap((void *)dragonix_map.map_priv_1);
+	printk("ZEUS:so its the wrong end of init_dragonix(flash)\n");
+	return -ENXIO;
+
+}
+
+mod_exit_t cleanup_dragonix(void)
+{
+	if (mymtd) {
+		del_mtd_device(mymtd);
+		map_destroy(mymtd);
+	}
+	if (dragonix_map.map_priv_1) {
+		iounmap((void *)dragonix_map.map_priv_1);
+		dragonix_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_dragonix);
+module_exit(cleanup_dragonix);
Index: linux-2.4.27/drivers/mtd/maps/epxa10db-flash.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/epxa10db-flash.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/epxa10db-flash.c	2008-03-22 11:19:21.000000000 +0300
@@ -43,7 +43,7 @@
 
 static struct mtd_info *mymtd;
 
-extern int parse_redboot_partitions(struct mtd_info *, struct mtd_partition **);
+extern int parse_redboot_partitions(struct mtd_info *, struct mtd_partition **, unsigned long fis_origin);
 static int epxa_default_partitions(struct mtd_info *master, struct mtd_partition **pparts);
 
 static __u8 epxa_read8(struct map_info *map, unsigned long ofs)
@@ -136,7 +136,7 @@
 	}
 
 #ifdef CONFIG_MTD_REDBOOT_PARTS
-	nr_parts = parse_redboot_partitions(mymtd, &parts);
+	nr_parts = parse_redboot_partitions(mymtd, &parts, 0);
 
 	if (nr_parts > 0) {
 		add_mtd_partitions(mymtd, parts, nr_parts);
Index: linux-2.4.27/drivers/mtd/maps/feith.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/feith.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,394 @@
+/****************************************************************************/
+/*
+ * Flash memory access on Feith Sensor to Image GmbH devices
+ * Copyright (C) Feith Sensor to Image GmbH, Roman Wagner <rw@feith.de>
+ *
+ * Mostly hijacked from nettel-uc.c
+ * Copyright (C) Lineo, <davidm@moreton.com.au>
+ */
+/****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/fs.h>
+
+#include <asm/io.h>
+#include <asm/delay.h>
+
+/****************************************************************************/
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+#define SIZE_2MB	(2 * 1024 * 1024)
+#define SIZE_4MB	(4 * 1024 * 1024)
+#define SIZE_6MB	(6 * 1024 * 1024)
+#define SIZE_8MB	(8 * 1024 * 1024)
+
+#define FLASH_BASE	0xf0000000
+#define	BUS_WIDTH	2
+
+/*
+ *	If you set AUTO_PROBE,  then we will just use the biggest device
+ *	we can find
+ */
+#undef AUTO_PROBE
+
+/****************************************************************************/
+
+static __u8 Feith_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 Feith_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 Feith_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void Feith_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void Feith_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void Feith_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void Feith_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void Feith_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+/****************************************************************************/
+
+static struct map_info Feith_flash_map = {
+	name:		"Flash",
+	read8:		Feith_read8,
+	read16:		Feith_read16,
+	read32:		Feith_read32,
+	copy_from:	Feith_copy_from,
+	write8:		Feith_write8,
+	write16:	Feith_write16,
+	write32:	Feith_write32,
+	copy_to:	Feith_copy_to,
+};
+
+static struct map_info Feith_ram_map = {
+	name:		"RAM",
+	read8:		Feith_read8,
+	read16:		Feith_read16,
+	read32:		Feith_read32,
+	copy_from:	Feith_copy_from,
+	write8:		Feith_write8,
+	write16:	Feith_write16,
+	write32:	Feith_write32,
+	copy_to:	Feith_copy_to,
+};
+
+static struct mtd_info *ram_mtdinfo;
+static struct mtd_info *flash_mtdinfo;
+
+/****************************************************************************/
+
+static struct mtd_partition Feith_romfs[] = {
+	{ name: "romfs", offset: 0 }
+};
+
+/****************************************************************************/
+/*
+ *	The layout of our flash,  note the order of the names,  this
+ *	means we use the same major/minor for the same purpose on all
+ *	layouts (when possible)
+ */
+
+#if defined(CONFIG_CLEOPATRA) || defined(CONFIG_SCALES)
+static struct mtd_partition Feith_2mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",        offset: 0x00006000, size:   0x00002000 },
+	{ name: "Image",      offset: 0x00020000, size:   0x001c0000 },
+	{ name: "Config",     offset: 0x00010000, size:   0x00010000 },
+	{ name: "Flash",      offset: 0x00000000, size:   0x00200000 },
+	{ name: "Spare",      offset: 0x00008000, size:   0x00008000 },
+	{ name: "Config User",offset: 0x001e0000, size:   0x00020000 }
+};
+
+static struct mtd_partition Feith_4mb[] = {
+	{ name: "Bootloader",  offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",    offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",         offset: 0x00006000, size:   0x00002000 },
+	{ name: "Image",       offset: 0x00020000, size:   0x001c0000 },
+	{ name: "Config",      offset: 0x00010000, size:   0x00010000 },
+	{ name: "Flash",       offset: 0x00000000, size:   0x00200000 },
+	{ name: "Spare",       offset: 0x00008000, size:   0x00008000 },
+	{ name: "Config User", offset: 0x001e0000, size:   0x00020000 },
+	{ name: "User Block 1",offset: 0x00200000, size:   0x00180000 },
+	{ name: "User Block 2",offset: 0x00380000, size:   0x00080000 }
+};
+
+static struct mtd_partition Feith_6mb[] = {
+	{ name: "Bootloader",  offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",    offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",         offset: 0x00006000, size:   0x00002000 },
+	{ name: "Image",       offset: 0x00020000, size:   0x001c0000 },
+	{ name: "Config",      offset: 0x00010000, size:   0x00010000 },
+	{ name: "Flash",       offset: 0x00000000, size:   0x00200000 },
+	{ name: "Spare",       offset: 0x00008000, size:   0x00008000 },
+	{ name: "Config User", offset: 0x001e0000, size:   0x00020000 },
+	{ name: "User Block 1",offset: 0x00200000, size:   0x00180000 },
+	{ name: "User Block 2",offset: 0x00380000, size:   0x00080000 },
+	{ name: "User Block 3",offset: 0x00400000, size:   0x00200000 }
+};
+#endif
+
+#if defined(CONFIG_CANCAM)
+static struct mtd_partition Feith_8mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00010000 },
+	{ name: "Bootargs",   offset: 0x00010000, size:   0x00010000 },
+	{ name: "MAC",        offset: 0x00020000, size:   0x00010000 },
+	{ name: "Image",      offset: 0x00050000, size:   0x001b0000 },
+	{ name: "Config",     offset: 0x00040000, size:   0x00010000 },
+	{ name: "Flash",      offset: 0x00000000, size:   0x00800000 },
+	{ name: "Spare",      offset: 0x00030000, size:   0x00010000 },
+	{ name: "Config User",offset: 0x00200000, size:   0x00600000 }
+};
+#endif
+
+
+/****************************************************************************/
+/*
+ * Find the MTD device with the given name
+ */
+
+static struct mtd_info *get_mtd_named(char *name)
+{
+	int i;
+	struct mtd_info *mtd;
+
+	for (i = 0; i < MAX_MTD_DEVICES; i++) {
+		mtd = get_mtd_device(NULL, i);
+		if (mtd) {
+			if (strcmp(mtd->name, name) == 0)
+				return(mtd);
+			put_mtd_device(mtd);
+		}
+	}
+	return(NULL);
+}
+
+/****************************************************************************/
+
+static int
+Feith_point(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char **mtdbuf)
+{
+	struct map_info *map = (struct map_ptr *) mtd->priv;
+	*mtdbuf = map->map_priv_1 + from;
+	*retlen = len;
+	return(0);
+}
+
+/****************************************************************************/
+
+static int __init
+Feith_probe(int ram, unsigned long addr, int size, int buswidth)
+{
+	struct mtd_info *mymtd;
+	struct map_info *map_ptr;
+
+	if (ram)
+		map_ptr = &Feith_ram_map;
+	else
+		map_ptr = &Feith_flash_map;
+
+	map_ptr->buswidth = buswidth;
+	map_ptr->map_priv_2 = addr;
+	map_ptr->size = size;
+
+	printk(KERN_NOTICE "Feith MTD %s probe(0x%lx,%d,%d): %lx at %lx\n",
+			ram ? "ram" : "flash",
+			addr, size, buswidth, map_ptr->size, map_ptr->map_priv_2);
+
+	map_ptr->map_priv_1 = (unsigned long)
+			ioremap_nocache(map_ptr->map_priv_2, map_ptr->size);
+
+	if (!map_ptr->map_priv_1) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+
+	if (!ram) {
+		mymtd = do_map_probe("cfi_probe", map_ptr);
+	} else {
+		mymtd = do_map_probe("map_ram", map_ptr);
+	}
+
+	if (!mymtd) {
+		iounmap((void *)map_ptr->map_priv_1);
+		return -ENXIO;
+	}
+
+	mymtd->module = THIS_MODULE;
+	mymtd->point = Feith_point;
+	mymtd->priv = map_ptr;
+
+	if (ram) {
+		ram_mtdinfo = mymtd;
+		add_mtd_partitions(mymtd, Feith_romfs, NB_OF(Feith_romfs));
+		return(0);
+	}
+
+	flash_mtdinfo = mymtd;
+	switch (size) {
+	case SIZE_2MB:
+		add_mtd_partitions(mymtd, Feith_2mb, NB_OF(Feith_2mb));
+		break;
+	case SIZE_4MB:
+		add_mtd_partitions(mymtd, Feith_4mb, NB_OF(Feith_4mb));
+		break;
+	case SIZE_6MB:
+		add_mtd_partitions(mymtd, Feith_6mb, NB_OF(Feith_6mb));
+		break;
+#if defined(CONFIG_CANCAM)
+	case SIZE_8MB:
+		add_mtd_partitions(mymtd, Feith_8mb, NB_OF(Feith_8mb));
+		break;
+#endif
+	}
+
+	return 0;
+}
+
+/****************************************************************************/
+
+int __init Feith_mtd_init(void)
+{
+	int rc = -1;
+	struct mtd_info *mtd;
+	extern char _ebss;
+
+	/*
+	 * I hate this ifdef stuff,  but our HW doesn't always have
+	 * the same chipsize as the map that we use
+	 */
+#if defined(CONFIG_CANCAM)
+#if defined(CONFIG_FLASH8MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = Feith_probe(0, FLASH_BASE, SIZE_8MB, BUS_WIDTH);
+#endif
+#endif
+
+#if defined(CONFIG_FLASH6MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = Feith_probe(0, FLASH_BASE, SIZE_6MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH4MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = Feith_probe(0, FLASH_BASE, SIZE_4MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH2MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = Feith_probe(0, FLASH_BASE, SIZE_2MB, BUS_WIDTH);
+#endif
+
+	/*
+	 * Map in the filesystem from RAM last so that,  if the filesystem
+	 * is not in RAM for some reason we do not change the minor/major
+	 * for the flash devices
+	 */
+#ifndef CONFIG_ROMFS_FROM_ROM
+	if (0 != Feith_probe(1, (unsigned long) &_ebss,
+			PAGE_ALIGN(* (unsigned long *)((&_ebss) + 8)), 4))
+		printk("Failed to probe RAM filesystem 1\n");
+#else
+	{
+		unsigned long start_area;
+		unsigned char *sp, *ep;
+		size_t len;
+
+		start_area = (unsigned long) &_ebss;
+
+		if (strncmp((char *) start_area, "-rom1fs-", 8) != 0) {
+			mtd = get_mtd_named("Image");
+			if (mtd && mtd->point) {
+				if ((*mtd->point)(mtd, 0, mtd->size, &len, &sp) == 0) {
+					ep = sp + len;
+					while (sp < ep && strncmp(sp, "-rom1fs-", 8) != 0)
+						sp++;
+					if (sp < ep)
+						start_area = (unsigned long) sp;
+				}
+			}
+			if (mtd)
+				put_mtd_device(mtd);
+		}
+		if (0 != Feith_probe(1, start_area,
+				PAGE_ALIGN(* (unsigned long *)(start_area + 8)), 4))
+			printk("Failed to probe RAM filesystem 2\n");
+	}
+#endif
+	
+	mtd = get_mtd_named("romfs");
+	if (mtd) {
+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+		put_mtd_device(mtd);
+	}
+
+	return(rc);
+}
+
+/****************************************************************************/
+
+static void __exit Feith_mtd_cleanup(void)
+{
+	if (flash_mtdinfo) {
+		del_mtd_partitions(flash_mtdinfo);
+		map_destroy(flash_mtdinfo);
+		flash_mtdinfo = NULL;
+	}
+	if (ram_mtdinfo) {
+		del_mtd_partitions(ram_mtdinfo);
+		map_destroy(ram_mtdinfo);
+		ram_mtdinfo = NULL;
+	}
+	if (Feith_ram_map.map_priv_1) {
+		iounmap((void *)Feith_ram_map.map_priv_1);
+		Feith_ram_map.map_priv_1 = 0;
+	}
+	if (Feith_flash_map.map_priv_1) {
+		iounmap((void *)Feith_flash_map.map_priv_1);
+		Feith_flash_map.map_priv_1 = 0;
+	}
+}
+
+/****************************************************************************/
+
+module_init(Feith_mtd_init);
+module_exit(Feith_mtd_cleanup);
+
+/****************************************************************************/
Index: linux-2.4.27/drivers/mtd/maps/iq80310.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/iq80310.c	2002-08-03 04:39:44.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/iq80310.c	2008-03-22 11:19:21.000000000 +0300
@@ -107,7 +107,7 @@
 static struct mtd_info *mymtd;
 static struct mtd_partition *parsed_parts;
 
-extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts, unsigned long fis_origin);
 
 static int __init init_iq80310(void)
 {
@@ -130,7 +130,7 @@
 
 #ifdef CONFIG_MTD_REDBOOT_PARTS
 	if (parsed_nr_parts == 0) {
-		int ret = parse_redboot_partitions(mymtd, &parsed_parts);
+		int ret = parse_redboot_partitions(mymtd, &parsed_parts, 0);
 
 		if (ret > 0) {
 			part_type = "RedBoot";
Index: linux-2.4.27/drivers/mtd/maps/ixp425.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/ixp425.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,216 @@
+/*
+ * drivers/mtd/maps
+ *
+ * MTD Map file for IXP425 based systems
+ *
+ * Original Author: Intel Corporation
+ * Maintainer: Deepak Saxena <dsaxena@mvista.com>
+ *
+ * Copyright 2002 Intel Corporation
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ioport.h>
+#include <linux/reboot.h>
+#include <asm/io.h>
+
+#define WINDOW_ADDR 	0x50000000
+#define BUSWIDTH 	2
+#define WINDOW_SIZE	0x01000000
+
+#ifndef __ARMEB__
+#define	B0(h)	((h) & 0xFF)
+#define	B1(h)	(((h) >> 8) & 0xFF)
+#else
+#define	B0(h)	(((h) >> 8) & 0xFF)
+#define	B1(h)	((h) & 0xFF)
+#endif
+
+static __u16 ixp425_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+/*
+ * The IXP425 expansion bus only allows 16-bit wide acceses
+ * when attached to a 16-bit wide device (such as the 28F128J3A),
+ * so we can't use a memcpy_fromio as it does byte acceses.
+ */
+static void ixp425_copy_from(struct map_info *map, void *to,
+    unsigned long from, ssize_t len)
+{
+	int i;
+	u8 *dest = (u8*)to;
+	u16 *src = (u16 *)(map->map_priv_1 + from);
+	u16 data;
+
+	for(i = 0; i < (len / 2); i++) {
+		data = src[i];
+		dest[i * 2] = B0(data);
+		dest[i * 2 + 1] = B1(data);
+	}
+
+	if(len & 1)
+		dest[len - 1] = B0(src[i]);
+}
+
+static void ixp425_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static struct map_info ixp425_map = {
+	name: 		"IXP425 Flash",
+	buswidth: 	BUSWIDTH,
+	read16:		ixp425_read16,
+	copy_from:	ixp425_copy_from,
+	write16:	ixp425_write16,
+};
+
+/*
+ * Put flash back in read mode so RedBoot can boot properly.
+ */
+int ixp425_mtd_reboot(struct notifier_block *n, unsigned long code, void *p)
+{
+	if (code != SYS_RESTART)
+		return NOTIFY_DONE;
+
+	ixp425_write16(&ixp425_map, 0xff, 0x55 * 0x2);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block ixp425_mtd_notifier = {
+	notifier_call:ixp425_mtd_reboot,
+	next:NULL,
+	priority:0
+};
+
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+static struct mtd_partition *parsed_parts;
+#endif
+
+static struct mtd_partition ixp425_partitions[] = {
+	{
+		name:	"image",
+		offset:	0x00040000,
+		size:	0x00400000, 
+    	},
+	{
+		name:	"user",
+		offset:	0x00440000,
+		size:	0x00B80000, /* Rest of flash space minus redboot 
+				     * configuration sectors (-256k)    
+				     */
+	},
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *ixp425_mtd;
+static struct resource *mtd_resource;
+
+static void ixp425_exit(void)
+{
+    if(ixp425_mtd){
+	del_mtd_partitions(ixp425_mtd);
+	map_destroy(ixp425_mtd);
+    }
+    if (ixp425_map.map_priv_1)
+	iounmap((void *)ixp425_map.map_priv_1);
+    if (mtd_resource)
+	release_mem_region(WINDOW_ADDR, WINDOW_SIZE);
+    
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+    if (parsed_parts)
+	kfree(parsed_parts);
+#endif
+
+    unregister_reboot_notifier(&ixp425_mtd_notifier);
+
+    /* Disable flash write */
+    *IXP425_EXP_CS0 &= ~IXP425_FLASH_WRITABLE;
+}
+
+static int __init ixp425_init(void)
+{
+    int res = -1, npart;
+
+    /* Enable flash write */
+    *IXP425_EXP_CS0 |= IXP425_FLASH_WRITABLE;
+
+    ixp425_map.map_priv_1 = 0;
+    mtd_resource = 
+	request_mem_region(WINDOW_ADDR, WINDOW_SIZE, "ixp425 Flash");
+    if(!mtd_resource) {
+	printk(KERN_ERR "ixp425 flash: Could not request mem region.\n" );
+	res = -ENOMEM;
+	goto Error;
+    }
+
+    ixp425_map.map_priv_1 =
+	(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+    if (!ixp425_map.map_priv_1) {
+	printk("ixp425 Flash: Failed to map IO region. (ioremap)\n");
+	res = -EIO;
+	goto Error;
+    }
+    ixp425_map.size = WINDOW_SIZE;
+
+
+    /* 
+     * Probe for the CFI complaint chip
+     * suposed to be 28F128J3A
+     */
+    ixp425_mtd = do_map_probe("cfi_probe", &ixp425_map);
+    if (!ixp425_mtd) {
+	res = -ENXIO;
+	goto Error;
+    }
+    ixp425_mtd->module = THIS_MODULE;
+   
+    /* Initialize flash partiotions 
+     * Note: Redeboot partition info table can be parsed by MTD, and used
+     *       instead of hard-coded partions. TBD
+     */
+
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+    /* Try to parse RedBoot partitions */
+    npart = parse_redboot_partitions(ixp425_mtd, &parsed_parts, 0);
+    if (npart > 0) 
+	res = add_mtd_partitions(ixp425_mtd, parsed_parts, npart);
+    else   
+	res = -EIO;
+#endif
+
+    if (res) {
+	printk("Using static MTD partitions.\n");
+	/* RedBoot partitions not found - use hardcoded partition table */
+	res = add_mtd_partitions(ixp425_mtd, ixp425_partitions,
+	    NB_OF(ixp425_partitions));
+    }
+
+    if (res)
+	goto Error;
+
+    register_reboot_notifier(&ixp425_mtd_notifier);
+
+    return res;
+Error:
+    ixp425_exit();
+    return res;
+}
+
+module_init(ixp425_init);
+module_exit(ixp425_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD map driver for ixp425 evaluation board");
+
Index: linux-2.4.27/drivers/mtd/maps/keyTechnology.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/keyTechnology.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,311 @@
+/****************************************************************************/
+/*
+ * Flash memory access on Key Technology devices
+ * Copyright (C) Key Technology, Inc. <ktreis@keyww.com>
+ *
+ * Mostly hijacked from nettel-uc.c
+ * Copyright (C) Lineo, <davidm@moreton.com.au>
+ */
+/****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/fs.h>
+
+#include <asm/io.h>
+#include <asm/delay.h>
+
+/****************************************************************************/
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+#define SIZE_2MB	(2 * 1024 * 1024)
+#define SIZE_8MB	(8 * 1024 * 1024)
+
+/*
+ *	If you set AUTO_PROBE,  then we will just use the biggest device
+ *	we can find
+ */
+#undef AUTO_PROBE
+
+/****************************************************************************/
+
+static __u8 keyTechnology_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 keyTechnology_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 keyTechnology_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void keyTechnology_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void keyTechnology_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void keyTechnology_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void keyTechnology_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void keyTechnology_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+/****************************************************************************/
+
+static struct map_info keyTechnology_flash_map = {
+	name:		"Flash",
+	read8:		keyTechnology_read8,
+	read16:		keyTechnology_read16,
+	read32:		keyTechnology_read32,
+	copy_from:	keyTechnology_copy_from,
+	write8:		keyTechnology_write8,
+	write16:	keyTechnology_write16,
+	write32:	keyTechnology_write32,
+	copy_to:	keyTechnology_copy_to,
+};
+
+static struct map_info keyTechnology_ram_map = {
+	name:		"RAM",
+	read8:		keyTechnology_read8,
+	read16:		keyTechnology_read16,
+	read32:		keyTechnology_read32,
+	copy_from:	keyTechnology_copy_from,
+	write8:		keyTechnology_write8,
+	write16:	keyTechnology_write16,
+	write32:	keyTechnology_write32,
+	copy_to:	keyTechnology_copy_to,
+};
+
+static struct mtd_info *ram_mtdinfo;
+static struct mtd_info *flash_mtdinfo;
+
+/****************************************************************************/
+
+static struct mtd_partition keyTechnology_romfs[] = {
+	{ name: "romfs", offset: 0 }
+};
+
+/****************************************************************************/
+/*
+ *	The layout of our flash,  note the order of the names,  this
+ *	means we use the same major/minor for the same purpose on all
+ *	layouts (when possible)
+ */
+
+static struct mtd_partition keyTechnology_2mb[] = {
+	{ name: "bootloader",	offset: 0x00000000, size: 0x00004000 },
+	{ name: "ethernet",		offset: 0x00004000, size: 0x00002000 },
+	{ name: "cmdline",		offset: 0x00006000, size: 0x00002000 },
+	{ name: "kernel+romfs",	offset: 0x00040000, size: 0x000c0000 },
+	{ name: "config",		offset: 0x00100000, size: 0x00100000 }
+};
+
+/****************************************************************************/
+/*
+ * Find the MTD device with the given name
+ */
+
+static struct mtd_info *get_mtd_named(char *name)
+{
+	int i;
+	struct mtd_info *mtd;
+
+	for (i = 0; i < MAX_MTD_DEVICES; i++) {
+		mtd = get_mtd_device(NULL, i);
+		if (mtd) {
+			if (strcmp(mtd->name, name) == 0)
+				return(mtd);
+			put_mtd_device(mtd);
+		}
+	}
+	return(NULL);
+}
+
+/****************************************************************************/
+
+static int
+keyTechnology_point(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char **mtdbuf)
+{
+	struct map_info *map = (struct map_ptr *) mtd->priv;
+	*mtdbuf = map->map_priv_1 + from;
+	*retlen = len;
+	return(0);
+}
+
+/****************************************************************************/
+
+static int __init
+keyTechnology_probe(int ram, unsigned long addr, int size, int buswidth)
+{
+	struct mtd_info *mymtd;
+	struct map_info *map_ptr;
+
+	if (ram)
+		map_ptr = &keyTechnology_ram_map;
+	else
+		map_ptr = &keyTechnology_flash_map;
+
+	map_ptr->buswidth = buswidth;
+	map_ptr->map_priv_2 = addr;
+	map_ptr->size = size;
+
+	printk(KERN_NOTICE "Key MTD %s probe(0x%lx,%d,%d): %lx at %lx\n",
+			ram ? "ram" : "flash",
+			addr, size, buswidth, map_ptr->size, map_ptr->map_priv_2);
+
+	map_ptr->map_priv_1 = (unsigned long)
+			ioremap_nocache(map_ptr->map_priv_2, map_ptr->size);
+
+	if (!map_ptr->map_priv_1) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+
+	if (!ram) {
+		mymtd = do_map_probe("cfi_probe", map_ptr);
+	} else {
+		mymtd = do_map_probe("map_ram", map_ptr);
+	}
+
+	if (!mymtd) {
+		iounmap((void *)map_ptr->map_priv_1);
+		return -ENXIO;
+	}
+		
+	mymtd->module = THIS_MODULE;
+	mymtd->point = keyTechnology_point;
+	mymtd->priv = map_ptr;
+
+	if (ram) {
+		ram_mtdinfo = mymtd;
+		add_mtd_partitions(mymtd, keyTechnology_romfs, NB_OF(keyTechnology_romfs));
+		return(0);
+	}
+
+	flash_mtdinfo = mymtd;
+	switch (size) {
+	case SIZE_2MB:
+		add_mtd_partitions(mymtd, keyTechnology_2mb, NB_OF(keyTechnology_2mb));
+		break;
+	}
+
+	return 0;
+}
+
+/****************************************************************************/
+
+int __init keyTechnology_mtd_init(void)
+{
+	int rc = -1;
+	struct mtd_info *mtd;
+	extern char _ebss;
+
+#if defined(CONFIG_FLASH2MB) || defined(AUTO_PROBE)
+	if (rc != 0)
+		rc = keyTechnology_probe(0, 0xffe00000, SIZE_2MB, 2);
+#endif
+
+	/*
+	 * Map in the filesystem from RAM last so that,  if the filesystem
+	 * is not in RAM for some reason we do not change the minor/major
+	 * for the flash devices
+	 */
+#ifndef CONFIG_ROMFS_FROM_ROM
+	if (0 != keyTechnology_probe(1, (unsigned long) &_ebss,
+			PAGE_ALIGN(* (unsigned long *)((&_ebss) + 8)), 4))
+		printk("Failed to probe RAM filesystem\n");
+#else
+	{
+		unsigned long start_area;
+		unsigned char *sp, *ep;
+		size_t len;
+
+		start_area = (unsigned long) &_ebss;
+
+		if (strncmp((char *) start_area, "-rom1fs-", 8) != 0) {
+			mtd = get_mtd_named("Image");
+			if (mtd && mtd->point) {
+				if ((*mtd->point)(mtd, 0, mtd->size, &len, &sp) == 0) {
+					ep = sp + len;
+					while (sp < ep && strncmp(sp, "-rom1fs-", 8) != 0)
+						sp++;
+					if (sp < ep)
+						start_area = (unsigned long) sp;
+				}
+			}
+			if (mtd)
+				put_mtd_device(mtd);
+		}
+		if (0 != keyTechnology_probe(1, start_area,
+				PAGE_ALIGN(* (unsigned long *)(start_area + 8)), 4))
+			printk("Failed to probe RAM filesystem\n");
+	}
+#endif
+	
+	mtd = get_mtd_named("romfs");
+	if (mtd) {
+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+		put_mtd_device(mtd);
+	}
+
+	return(rc);
+}
+
+/****************************************************************************/
+
+static void __exit keyTechnology_mtd_cleanup(void)
+{
+	if (flash_mtdinfo) {
+		del_mtd_partitions(flash_mtdinfo);
+		map_destroy(flash_mtdinfo);
+		flash_mtdinfo = NULL;
+	}
+	if (ram_mtdinfo) {
+		del_mtd_partitions(ram_mtdinfo);
+		map_destroy(ram_mtdinfo);
+		ram_mtdinfo = NULL;
+	}
+	if (keyTechnology_ram_map.map_priv_1) {
+		iounmap((void *)keyTechnology_ram_map.map_priv_1);
+		keyTechnology_ram_map.map_priv_1 = 0;
+	}
+	if (keyTechnology_flash_map.map_priv_1) {
+		iounmap((void *)keyTechnology_flash_map.map_priv_1);
+		keyTechnology_flash_map.map_priv_1 = 0;
+	}
+}
+
+/****************************************************************************/
+
+module_init(keyTechnology_mtd_init);
+module_exit(keyTechnology_mtd_cleanup);
+
+/****************************************************************************/
Index: linux-2.4.27/drivers/mtd/maps/keywest.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/keywest.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,184 @@
+/*
+ * Flash memory access on SH/KeyWest based devices
+ * (C) 2001 Lineo
+ * (C) 2002,2003 SnapGear, davidm@snapgear.com
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/delay.h>
+
+#ifndef CONFIG_SUPERH
+#error This is for SH architecture only
+#endif
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static __u8 keywest_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 keywest_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 keywest_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void keywest_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void keywest_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void keywest_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void keywest_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void keywest_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info keywest_map = {
+	name:		"KeyWest/BigSur flash",
+	read8:		keywest_read8,
+	read16:		keywest_read16,
+	read32:		keywest_read32,
+	copy_from:	keywest_copy_from,
+	write8:		keywest_write8,
+	write16:	keywest_write16,
+	write32:	keywest_write32,
+	copy_to:	keywest_copy_to,
+	size:       0x00400000,			/* 32 Mbytes */
+};
+
+static struct mtd_partition keywest_partitions[] = {
+	{
+		name: "Bootloader",
+		offset: 0x00000000,
+		size:   0x00080000
+	},
+	{
+		name: "Bootargs",
+		offset: 0x00080000,
+		size:   0x00080000
+	},
+	{
+		name: "Config",
+		offset: 0x00180000,
+		size:   0x00080000
+	},
+	{
+		name: "Spare",
+		offset: 0x00100000,
+		size:   0x00080000
+	},
+	{
+		name: "kernel/root",
+		offset: 0x00200000,
+		size:   0x00e00000
+	},
+	{
+		name: "Full flash",
+		offset: 0
+	}
+};
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+static int __init keywest_probe(unsigned long addr, int buswidth)
+{
+	keywest_map.buswidth = buswidth;
+	keywest_map.map_priv_2 = addr;
+
+	printk(KERN_NOTICE "KeyWest flash probe(0x%x,%d): %lx at %lx\n",
+			addr, buswidth, keywest_map.size, keywest_map.map_priv_2);
+
+	keywest_map.map_priv_1 = (unsigned long)
+			ioremap_nocache(keywest_map.map_priv_2, keywest_map.size);
+
+	if (!keywest_map.map_priv_1) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &keywest_map);
+	if(!mymtd)
+		mymtd = do_map_probe("jedec_probe", &keywest_map);
+
+	if (!mymtd) {
+		printk("No flash/rom found !\n");
+		iounmap((void *)keywest_map.map_priv_1);
+		return -ENXIO;
+	}
+		
+	mymtd->module = THIS_MODULE;
+	add_mtd_partitions(mymtd, keywest_partitions, NB_OF(keywest_partitions));
+	return 0;
+}
+
+int __init keywest_mtd_init(void)
+{
+	unsigned short r;
+	int rc;
+
+#if defined(CONFIG_SH_KEYWEST)
+	/*
+	 *	Need to enable flash writes to ID chips etc
+	 *	Port D(2) is our target,  set it to '1'
+	 */
+	r = * (unsigned short *) 0xa4000106;
+	r &= ~0x0030;
+	r |=  0x0010;
+	* (unsigned short *) 0xa4000106 = r;
+	* (unsigned char *) 0xa4000126 |= 0x04;
+#elif defined(CONFIG_SH_BIGSUR)
+	/*
+	 *	Need to enable flash writes to ID chips etc
+	 */
+	* (unsigned char *) 0xb1fffb00 = 0x08;
+#endif
+
+	rc = keywest_probe(0x0000000, 4); /* boot from FLASH */
+	if (rc != 0)
+		rc = keywest_probe(0x8000000, 4); /* otherwise boot from ROM */
+	return(rc);
+}
+
+static void __exit keywest_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (keywest_map.map_priv_1) {
+		iounmap((void *)keywest_map.map_priv_1);
+		keywest_map.map_priv_1 = 0;
+	}
+}
+
+module_init(keywest_mtd_init);
+module_exit(keywest_mtd_cleanup);
Index: linux-2.4.27/drivers/mtd/maps/m5272c3.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/m5272c3.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,215 @@
+/*
+ *
+ * Normal mappings of chips in physical memory
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+
+#define WINDOW_ADDR 0xffe00000
+#define WINDOW_SIZE 0x200000
+#define BUSWIDTH 2
+
+extern char* ppcboot_getenv(char* v);
+
+static struct mtd_info *mymtd;
+
+__u8 m5272c3_read8(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 m5272c3_read16(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 m5272c3_read32(struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void m5272c3_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void m5272c3_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void m5272c3_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void m5272c3_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void m5272c3_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info m5272c3_map = {
+	name: "MCF5272C3 flash device",
+	size: WINDOW_SIZE,
+	buswidth: BUSWIDTH,
+	read8: m5272c3_read8,
+	read16: m5272c3_read16,
+	read32: m5272c3_read32,
+	copy_from: m5272c3_copy_from,
+	write8: m5272c3_write8,
+	write16: m5272c3_write16,
+	write32: m5272c3_write32,
+	copy_to: m5272c3_copy_to
+};
+
+/*
+ * MTD 'PARTITIONING' STUFF 
+ */
+
+#ifndef CONFIG_PPCBOOT
+
+static struct mtd_partition m5272c3_partitions[] = {
+        {
+                name: "kernel (768K)",
+                size: 0xc0000,
+                offset: 0x40000
+        },
+        {
+                name: "rootfs (1024K)",
+                size: 0x100000,
+                offset: 0x100000
+        },
+	{
+                name: "environment (8K)",
+                size: 0x2000,
+                offset: 0x4000
+        }
+};
+
+#else
+
+#define M5272C3_MAX_PARTITIONS 8
+#define M5272C3_MAX_PARTARGENTRIES 3
+#define M5272C3_PTABLE_BUFSIZE 256
+static struct mtd_partition m5272c3_partitions[M5272C3_MAX_PARTITIONS];
+static int m5272c3_partitions_cnt=0;
+static char* m5272c3_emptyentry = "";
+
+static void read_m5272c3_partitiontable(void) {
+  char* envptable=ppcboot_getenv("ptable");
+  if(envptable) {
+    char ptable[M5272C3_PTABLE_BUFSIZE],*p,*pt;
+    int pcnt,acnt,i;
+    char *ptableargentry[M5272C3_MAX_PARTITIONS][M5272C3_MAX_PARTARGENTRIES];
+    
+    strncpy(ptable,envptable,M5272C3_PTABLE_BUFSIZE-1);
+    ptable[M5272C3_PTABLE_BUFSIZE-1]=0;
+
+    for(pcnt=0;pcnt<M5272C3_MAX_PARTITIONS;pcnt++) {
+      for(acnt=0;acnt<M5272C3_MAX_PARTARGENTRIES;acnt++) {
+	ptableargentry[pcnt][acnt]=m5272c3_emptyentry;
+      };
+    };
+
+    pcnt=acnt=0;
+    p=pt=ptable;
+    while(1) {
+      if((*p == ',') || (*p == ':') || (*p == 0)) {
+	if(pcnt<M5272C3_MAX_PARTITIONS) {      
+	  if(acnt<M5272C3_MAX_PARTARGENTRIES)
+	    ptableargentry[pcnt][acnt++]=pt;
+	  if((*p == ':') || ( *p == 0 ))
+	    { acnt=0; pcnt++; };
+	  if( *p == 0 )
+	    break;
+	  pt=p+1;
+	};
+	*p=0;
+      };
+      p++;
+    };
+
+    for(i=0;i<pcnt;i++) {
+      m5272c3_partitions[i].name=
+	(char*)kmalloc(strlen(ptableargentry[i][0])+1,GFP_KERNEL);
+      strcpy(m5272c3_partitions[i].name,ptableargentry[i][0]);
+      m5272c3_partitions[i].size=
+	simple_strtoul(ptableargentry[i][1],0,16)*0x1000;
+      m5272c3_partitions[i].offset=
+	simple_strtoul(ptableargentry[i][2],0,16)*0x1000;
+    };
+    
+    m5272c3_partitions_cnt=pcnt;
+  };
+};
+
+#endif
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_m5272c3 init_module
+#define cleanup_m5272c3 cleanup_module
+#endif
+
+int __init init_m5272c3(void)
+{
+       	printk(KERN_NOTICE "m5272c3 flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	m5272c3_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+
+	if (!m5272c3_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &m5272c3_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+#ifdef CONFIG_PPCBOOT
+                read_m5272c3_partitiontable();
+		if(m5272c3_partitions_cnt) {
+		  return add_mtd_partitions(mymtd, m5272c3_partitions, m5272c3_partitions_cnt);
+		}
+		else {
+		  return  -ENXIO;
+		};
+#else
+		return add_mtd_partitions(mymtd, m5272c3_partitions,
+					  sizeof(m5272c3_partitions) /
+					  sizeof(struct mtd_partition));
+#endif
+	}
+
+	iounmap((void *)m5272c3_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_m5272c3(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (m5272c3_map.map_priv_1) {
+		iounmap((void *)m5272c3_map.map_priv_1);
+		m5272c3_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_m5272c3);
+module_exit(cleanup_m5272c3);
+
Index: linux-2.4.27/drivers/mtd/maps/mbvanilla-flash.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/mbvanilla-flash.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,436 @@
+/****************************************************************************/
+/*
+ * Flash memory access on uClinux mbvanilla Microblaze systems
+ * Copyright (C) 2003,      John Williams <jwilliams@itee.uq.edu.au>
+ *  based upon NETTEL_uc support, which is 
+ * Copyright (C) 2001-2002, David McCullough <davidm@snapgear.com>
+ */
+/****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/reboot.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nftl.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+
+#include <linux/fs.h>
+
+#include <asm/io.h>
+#include <asm/delay.h>
+
+/****************************************************************************/
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+#define SIZE_128K	(128 * 1024)
+#define SIZE_1MB	(1024 * 1024)
+#define SIZE_2MB	(2 * 1024 * 1024)
+#define SIZE_4MB	(4 * 1024 * 1024)
+#define SIZE_8MB	(8 * 1024 * 1024)
+
+#ifdef CONFIG_MBVANILLA
+#define FLASH_BASE	0xff000000
+#define	BUS_WIDTH	4
+#endif
+
+/****************************************************************************/
+
+static __u8 mbvanilla_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 mbvanilla_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 mbvanilla_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void mbvanilla_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void mbvanilla_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void mbvanilla_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void mbvanilla_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void mbvanilla_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+/****************************************************************************/
+
+static struct map_info mbvanilla_flash_map = {
+	name:		"Flash",
+	read8:		mbvanilla_read8,
+	read16:		mbvanilla_read16,
+	read32:		mbvanilla_read32,
+	copy_from:	mbvanilla_copy_from,
+	write8:		mbvanilla_write8,
+	write16:	mbvanilla_write16,
+	write32:	mbvanilla_write32,
+	copy_to:	mbvanilla_copy_to,
+};
+
+static struct map_info mbvanilla_ram_map = {
+	name:		"RAM",
+	read8:		mbvanilla_read8,
+	read16:		mbvanilla_read16,
+	read32:		mbvanilla_read32,
+	copy_from:	mbvanilla_copy_from,
+	write8:		mbvanilla_write8,
+	write16:	mbvanilla_write16,
+	write32:	mbvanilla_write32,
+	copy_to:	mbvanilla_copy_to,
+};
+
+static struct mtd_info *ram_mtdinfo;
+static struct mtd_info *flash_mtdinfo;
+
+/****************************************************************************/
+
+static struct mtd_partition mbvanilla_romfs[] = {
+	{ name: "Romfs", offset: 0 }
+};
+
+/****************************************************************************/
+/*
+ *	The layout of our flash,  note the order of the names,  this
+ *	means we use the same major/minor for the same purpose on all
+ *	layouts (when possible)
+ */
+
+static struct mtd_partition mbvanilla_128k[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00004000 },
+	{ name: "MAC",        offset: 0x00008000, size:   0x00004000 },
+	{ name: "Config",     offset: 0x00010000, size:   0x00010000 },
+	{ name: "Spare",      offset: 0x0000c000, size:   0x00004000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+static struct mtd_partition mbvanilla_1mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",        offset: 0x00006000, size:   0x00002000 },
+	{ name: "Config",     offset: 0x000f0000, size:   0x00010000 },
+	{ name: "Spare",      offset: 0x00008000, size:   0x00008000 },
+	{ name: "Image",      offset: 0x00010000, size:   0x000e0000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+static struct mtd_partition mbvanilla_2mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",        offset: 0x00006000, size:   0x00002000 },
+	{ name: "Config",     offset: 0x00010000, size:   0x00010000 },
+	{ name: "Spare",      offset: 0x00008000, size:   0x00008000 },
+	{ name: "Image",      offset: 0x00020000, size:   0x001e0000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+static struct mtd_partition mbvanilla_4mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",        offset: 0x00006000, size:   0x00002000 },
+	{ name: "Config",     offset: 0x00010000, size:   0x00010000 },
+	{ name: "Spare",      offset: 0x00008000, size:   0x00008000 },
+	{ name: "Image",      offset: 0x00020000, size:   0x001e0000 },
+	{ name: "Flash",      offset: 0x00000000, size:   0x00200000 },
+	{ name: "Image2",     offset: 0x00220000, size:   0x001e0000 },
+	{ name: "Flash2",     offset: 0 }
+};
+
+static struct mtd_partition mbvanilla_8mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00020000 },
+	{ name: "Bootargs",   offset: 0x00020000, size:   0x00020000 },
+	{ name: "MAC",        offset: 0x00040000, size:   0x00020000 },
+	{ name: "Config",     offset: 0x00080000, size:   0x00080000 },
+	{ name: "Spare",      offset: 0x00060000, size:   0x00020000 },
+	{ name: "Image",      offset: 0x00100000, size:   0x00200000 },
+	{ name: "JFFS2",      offset: 0x00300000, size:   0x00500000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+/****************************************************************************/
+/*
+ * Find the MTD device with the given name
+ */
+
+static struct mtd_info *get_mtd_named(char *name)
+{
+	int i;
+	struct mtd_info *mtd;
+
+	for (i = 0; i < MAX_MTD_DEVICES; i++) {
+		mtd = get_mtd_device(NULL, i);
+		if (mtd) {
+			if (strcmp(mtd->name, name) == 0)
+				return(mtd);
+			put_mtd_device(mtd);
+		}
+	}
+	return(NULL);
+}
+
+/****************************************************************************/
+#ifdef CONFIG_MTD_CFI_INTELEXT
+/*
+ *	Set the Intel flash back to read mode as MTD may leave it in command mode
+ */
+
+static int mbvanilla_reboot_notifier(
+	struct notifier_block *nb,
+	unsigned long val,
+	void *v)
+{
+	struct cfi_private *cfi = mbvanilla_flash_map.fldrv_priv;
+	int i;
+	
+	for (i = 0; cfi && i < cfi->numchips; i++)
+		cfi_send_gen_cmd(0xff, 0x55, cfi->chips[i].start, &mbvanilla_flash_map,
+				cfi, cfi->device_type, NULL);
+
+	return(NOTIFY_OK);
+}
+
+static struct notifier_block mbvanilla_notifier_block = {
+	mbvanilla_reboot_notifier, NULL, 0
+};
+
+#endif
+
+/****************************************************************************/
+
+static int
+mbvanilla_point(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char **mtdbuf)
+{
+	struct map_info *map = (struct map_info *) mtd->priv;
+	*mtdbuf = (u_char *) (map->map_priv_1 + (int)from);
+	*retlen = len;
+	return(0);
+}
+
+static void
+mbvanilla_unpoint (struct mtd_info *mtd, u_char *addr, loff_t from, size_t len)
+{
+}
+
+/****************************************************************************/
+
+static int __init
+mbvanilla_probe(int ram, unsigned long addr, int size, int buswidth)
+{
+	struct mtd_info *mymtd;
+	struct map_info *map_ptr;
+
+	if (ram)
+		map_ptr = &mbvanilla_ram_map;
+	else
+		map_ptr = &mbvanilla_flash_map;
+
+	map_ptr->buswidth = buswidth;
+	map_ptr->map_priv_2 = addr;
+	map_ptr->size = size;
+
+	printk(KERN_NOTICE "MBVanilla %s probe(0x%lx,%d,%d): %lx at %lx\n",
+			ram ? "ram" : "flash",
+			addr, size, buswidth, map_ptr->size, map_ptr->map_priv_2);
+
+	map_ptr->map_priv_1 = (unsigned long)
+			ioremap_nocache(map_ptr->map_priv_2, map_ptr->size);
+
+	if (!map_ptr->map_priv_1) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+
+	if (!ram) {
+		mymtd = do_map_probe("cfi_probe", map_ptr);
+		if (!mymtd)
+			mymtd = do_map_probe("jedec_probe", map_ptr);
+	} else
+		mymtd = do_map_probe("map_ram", map_ptr);
+
+	if (!mymtd) {
+		iounmap((void *)map_ptr->map_priv_1);
+		return -ENXIO;
+	}
+		
+	mymtd->module = THIS_MODULE;
+	mymtd->point = mbvanilla_point;
+	mymtd->unpoint = mbvanilla_unpoint;
+	mymtd->priv = map_ptr;
+
+	if (ram) {
+		ram_mtdinfo = mymtd;
+		add_mtd_partitions(mymtd, mbvanilla_romfs, NB_OF(mbvanilla_romfs));
+		return(0);
+	}
+
+	flash_mtdinfo = mymtd;
+	switch (size) {
+	case SIZE_128K:
+		add_mtd_partitions(mymtd, mbvanilla_128k, NB_OF(mbvanilla_128k));
+		break;
+	case SIZE_1MB:
+		add_mtd_partitions(mymtd, mbvanilla_1mb, NB_OF(mbvanilla_1mb));
+		break;
+	case SIZE_2MB:
+		add_mtd_partitions(mymtd, mbvanilla_2mb, NB_OF(mbvanilla_2mb));
+		break;
+	case SIZE_4MB:
+		add_mtd_partitions(mymtd, mbvanilla_4mb, NB_OF(mbvanilla_4mb));
+		break;
+	case SIZE_8MB:
+		add_mtd_partitions(mymtd, mbvanilla_8mb, NB_OF(mbvanilla_8mb));
+		break;
+	}
+
+	return 0;
+}
+
+/****************************************************************************/
+
+int __init mbvanilla_mtd_init(void)
+{
+	int rc = -1;
+	struct mtd_info *mtd;
+	extern char _ebss;
+
+	/*
+	 * I hate this ifdef stuff,  but our HW doesn't always have
+	 * the same chipsize as the map that we use
+	 */
+#if defined(CONFIG_FLASH8MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = mbvanilla_probe(0, FLASH_BASE, SIZE_8MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH4MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = mbvanilla_probe(0, FLASH_BASE, SIZE_4MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH2MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = mbvanilla_probe(0, FLASH_BASE, SIZE_2MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH1MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = mbvanilla_probe(0, FLASH_BASE, SIZE_1MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH128K) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = mbvanilla_probe(0, FLASH_BASE, SIZE_128K, BUS_WIDTH);
+#endif
+
+#ifdef CONFIG_MBVANILLA
+	/*
+	 * Map in the filesystem from RAM last so that,  if the filesystem
+	 * is not in RAM for some reason we do not change the minor/major
+	 * for the flash devices
+	 */
+#ifndef CONFIG_SEARCH_ROMFS
+	if (0 != mbvanilla_probe(1, (unsigned long) &_ebss,
+			PAGE_ALIGN(* (unsigned long *)((&_ebss) + 8)),4))
+		printk("Failed to probe RAM filesystem\n");
+#else
+	{
+		unsigned long start_area;
+		unsigned char *sp, *ep;
+		size_t len;
+
+		printk("Probing for ROMFS...\n");
+		start_area = (unsigned long) &_ebss;
+
+		if (strncmp((char *) start_area, "-rom1fs-", 8) != 0) {
+			mtd = get_mtd_named("Image");
+			if (mtd && mtd->point) {
+				if ((*mtd->point)(mtd, 0, mtd->size, &len, &sp) == 0) {
+					ep = sp + len;
+					while (sp < ep && strncmp(sp, "-rom1fs-", 8) != 0)
+						sp++;
+					if (sp < ep)
+						start_area = (unsigned long) sp;
+				}
+			}
+			if (mtd)
+				put_mtd_device(mtd);
+		}
+		if (0 != mbvanilla_probe(1, start_area,
+				PAGE_ALIGN(* (unsigned long *)(start_area + 8)), 4))
+			printk("Failed to probe RAM filesystem\n");
+	}
+#endif
+	
+	mtd = get_mtd_named("Romfs");
+	if (mtd) {
+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+		put_mtd_device(mtd);
+	}
+#endif
+
+	return(rc);
+}
+
+/****************************************************************************/
+
+static void __exit mbvanilla_mtd_cleanup(void)
+{
+	if (flash_mtdinfo) {
+		del_mtd_partitions(flash_mtdinfo);
+		map_destroy(flash_mtdinfo);
+		flash_mtdinfo = NULL;
+	}
+	if (ram_mtdinfo) {
+		del_mtd_partitions(ram_mtdinfo);
+		map_destroy(ram_mtdinfo);
+		ram_mtdinfo = NULL;
+	}
+	if (mbvanilla_ram_map.map_priv_1) {
+		iounmap((void *)mbvanilla_ram_map.map_priv_1);
+		mbvanilla_ram_map.map_priv_1 = 0;
+	}
+	if (mbvanilla_flash_map.map_priv_1) {
+		iounmap((void *)mbvanilla_flash_map.map_priv_1);
+		mbvanilla_flash_map.map_priv_1 = 0;
+	}
+}
+
+/****************************************************************************/
+
+module_init(mbvanilla_mtd_init);
+module_exit(mbvanilla_mtd_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("John Williams <jwilliams@itee.uq.edu.au>");
+MODULE_DESCRIPTION("Microblaze/MBVanilla FLASH support for uClinux");
+
+/****************************************************************************/
Index: linux-2.4.27/drivers/mtd/maps/nettel-uc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/nettel-uc.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,576 @@
+/****************************************************************************/
+/*
+ * Flash memory access on uClinux SnapGear like devices
+ * Copyright (C) 2001-2002, David McCullough <davidm@snapgear.com>
+ */
+/****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/reboot.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nftl.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+
+#include <linux/fs.h>
+
+#include <asm/io.h>
+#include <asm/delay.h>
+
+/****************************************************************************/
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+#define SIZE_128K	(1  *  128 * 1024)
+#define SIZE_1MB	(1  * 1024 * 1024)
+#define SIZE_2MB	(2  * 1024 * 1024)
+#define SIZE_4MB	(4  * 1024 * 1024)
+#define SIZE_8MB	(8  * 1024 * 1024)
+#define SIZE_16MB	(16 * 1024 * 1024)
+
+#ifdef CONFIG_UCDIMM
+#define FLASH_BASE	0x10c00000
+#define	BUS_WIDTH	2
+#ifdef CONFIG_RAMKERNEL
+#define ROMFS_LOC	((&__rom_start) + ((&_edata) - (&__ram_start)))
+extern char __rom_start, _edata, __ram_start;
+#else
+#define ROMFS_LOC	(&_edata)
+extern char _edata;
+#endif
+#endif
+
+#ifdef CONFIG_COLDFIRE
+#define FLASH_BASE	0xf0000000
+#define	BUS_WIDTH	2
+#endif
+
+#ifdef CONFIG_SUPERH
+#define FLASH_BASE	0x00000000
+#define	BUS_WIDTH	1
+#endif
+
+#ifdef CONFIG_MIPS32
+#define FLASH_BASE	0x1f000000
+#define	BUS_WIDTH	4
+#endif
+
+#ifndef ROMFS_LOC
+extern char _ebss;
+#define ROMFS_LOC	(&_ebss)
+#endif
+
+/****************************************************************************/
+
+static __u8 nettel_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 nettel_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 nettel_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void nettel_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void nettel_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void nettel_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void nettel_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void nettel_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+/****************************************************************************/
+
+static struct map_info nettel_flash_map = {
+	name:		"Flash",
+	read8:		nettel_read8,
+	read16:		nettel_read16,
+	read32:		nettel_read32,
+	copy_from:	nettel_copy_from,
+	write8:		nettel_write8,
+	write16:	nettel_write16,
+	write32:	nettel_write32,
+	copy_to:	nettel_copy_to,
+};
+
+static struct map_info nettel_ram_map = {
+	name:		"RAM",
+	read8:		nettel_read8,
+	read16:		nettel_read16,
+	read32:		nettel_read32,
+	copy_from:	nettel_copy_from,
+	write8:		nettel_write8,
+	write16:	nettel_write16,
+	write32:	nettel_write32,
+	copy_to:	nettel_copy_to,
+};
+
+static struct mtd_info *ram_mtdinfo;
+static struct mtd_info *flash_mtdinfo;
+
+/****************************************************************************/
+
+static struct mtd_partition nettel_romfs[] = {
+	{ name: "Romfs", offset: 0 }
+};
+
+/****************************************************************************/
+/*
+ *	The layout of our flash,  note the order of the names,  this
+ *	means we use the same major/minor for the same purpose on all
+ *	layouts (when possible)
+ */
+
+static struct mtd_partition nettel_128k[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00004000 },
+	{ name: "MAC",        offset: 0x00008000, size:   0x00004000 },
+	{ name: "Config",     offset: 0x00010000, size:   0x00010000 },
+	{ name: "Spare",      offset: 0x0000c000, size:   0x00004000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+static struct mtd_partition nettel_1mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",        offset: 0x00006000, size:   0x00002000 },
+	{ name: "Config",     offset: 0x000f0000, size:   0x00010000 },
+	{ name: "Spare",      offset: 0x00008000, size:   0x00008000 },
+	{ name: "Image",      offset: 0x00010000, size:   0x000e0000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+#ifndef CONFIG_UCDIMM
+
+static struct mtd_partition nettel_2mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",        offset: 0x00006000, size:   0x00002000 },
+	{ name: "Config",     offset: 0x00010000, size:   0x00010000 },
+	{ name: "Spare",      offset: 0x00008000, size:   0x00008000 },
+	{ name: "Image",      offset: 0x00020000, size:   0x001e0000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+#ifdef CONFIG_SH_SECUREEDGE5410
+
+static struct mtd_partition nettel_4mb[] = {
+	{ name: "Boot data",  offset: 0x00000000, size:   0x00020000 },
+	{ name: "Config",     offset: 0x00020000, size:   0x00040000 },
+	{ name: "Image",      offset: 0x00060000, size:   0x00000000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+static struct mtd_partition nettel_8mb[] = {
+	{ name: "Boot data",  offset: 0x00000000, size:   0x00020000 },
+	{ name: "Config",     offset: 0x00020000, size:   0x00080000 },
+	{ name: "Image",      offset: 0x000a0000, size:   0x00000000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+#else
+
+static struct mtd_partition nettel_4mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00004000 },
+	{ name: "Bootargs",   offset: 0x00004000, size:   0x00002000 },
+	{ name: "MAC",        offset: 0x00006000, size:   0x00002000 },
+	{ name: "Config",     offset: 0x00010000, size:   0x00010000 },
+	{ name: "Spare",      offset: 0x00008000, size:   0x00008000 },
+	{ name: "Image",      offset: 0x00020000, size:   0x001e0000 },
+	{ name: "Flash",      offset: 0x00000000, size:   0x00200000 },
+	{ name: "Image2",     offset: 0x00220000, size:   0x001e0000 },
+	{ name: "Flash2",     offset: 0 }
+};
+
+static struct mtd_partition nettel_8mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00020000 },
+	{ name: "Bootargs",   offset: 0x00020000, size:   0x00020000 },
+	{ name: "MAC",        offset: 0x00040000, size:   0x00020000 },
+	{ name: "Config",     offset: 0x00080000, size:   0x00080000 },
+	{ name: "Spare",      offset: 0x00060000, size:   0x00020000 },
+	{ name: "Image",      offset: 0x00100000, size:   0x00700000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+#endif
+
+#else /* CONFIG_UCDIMM */
+
+static struct mtd_partition nettel_2mb[] = {
+	{ name: "Bootloader", offset: 0x00000000, size:   0x00010000,
+	                                          mask_flags: MTD_WRITEABLE },
+	{ name: "Image",      offset: 0x00010000, size:   0x00190000 },
+	{ name: "Spare",      offset: 0x001a0000, size:   0x00060000 },
+	{ name: "Flash",      offset: 0 }
+};
+
+#define nettel_4mb nettel_2mb
+#define nettel_8mb nettel_2mb
+
+#endif
+
+#ifdef CONFIG_MIPS_VEGAS
+static struct mtd_partition nettel_16mb[] = {
+	{ name: "Bootloader",  offset: 0x00c00000, size:   0x00020000 },
+	{ name: "Bootargs",    offset: 0x00c20000, size:   0x00020000 },
+	{ name: "MAC",         offset: 0x00c40000, size:   0x00020000 },
+	{ name: "Config",      offset: 0x00c60000, size:   0x003a0000 },
+	{ name: "Image",       offset: 0x00000000, size:   0x00c00000 },
+	{ name: "Flash",       offset: 0 }
+};
+#else
+static struct mtd_partition nettel_16mb[] = {
+	{ name: "Boot data",  offset: 0x00000000, size:   0x00020000 },
+	{ name: "Config",     offset: 0x00020000, size:   0x00100000 },
+	{ name: "Image",      offset: 0x00120000, size:   0x00000000 },
+	{ name: "Flash",      offset: 0 }
+};
+#endif
+
+/****************************************************************************/
+/*
+ * Find the MTD device with the given name
+ */
+
+static struct mtd_info *get_mtd_named(char *name)
+{
+	int i;
+	struct mtd_info *mtd;
+
+	for (i = 0; i < MAX_MTD_DEVICES; i++) {
+		mtd = get_mtd_device(NULL, i);
+		if (mtd) {
+			if (strcmp(mtd->name, name) == 0)
+				return(mtd);
+			put_mtd_device(mtd);
+		}
+	}
+	return(NULL);
+}
+
+/****************************************************************************/
+#ifdef CONFIG_MTD_CFI_INTELEXT
+/*
+ *	Set the Intel flash back to read mode as MTD may leave it in command mode
+ */
+
+static int nettel_reboot_notifier(
+	struct notifier_block *nb,
+	unsigned long val,
+	void *v)
+{
+	struct cfi_private *cfi = nettel_flash_map.fldrv_priv;
+	int i;
+	
+	for (i = 0; cfi && i < cfi->numchips; i++)
+		cfi_send_gen_cmd(0xff, 0x55, cfi->chips[i].start, &nettel_flash_map,
+				cfi, cfi->device_type, NULL);
+
+	return(NOTIFY_OK);
+}
+
+static struct notifier_block nettel_notifier_block = {
+	nettel_reboot_notifier, NULL, 0
+};
+
+#endif
+
+/****************************************************************************/
+
+static int
+nettel_point(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char **mtdbuf)
+{
+	struct map_info *map = (struct map_info *) mtd->priv;
+	*mtdbuf = (u_char *) (map->map_priv_1 + (int)from);
+	*retlen = len;
+	return(0);
+}
+
+static void
+nettel_unpoint(struct mtd_info *mtd, u_char *addr, loff_t from, size_t len)
+{
+}
+
+/****************************************************************************/
+
+static int __init
+nettel_probe(int ram, unsigned long addr, int size, int buswidth)
+{
+	struct mtd_info *mymtd;
+	struct map_info *map_ptr;
+
+	if (ram)
+		map_ptr = &nettel_ram_map;
+	else
+		map_ptr = &nettel_flash_map;
+
+	map_ptr->buswidth = buswidth;
+	map_ptr->map_priv_2 = addr;
+	map_ptr->size = size;
+
+	printk(KERN_NOTICE "SnapGear %s probe(0x%lx,%d,%d): %lx at %lx\n",
+			ram ? "ram" : "flash",
+			addr, size, buswidth, map_ptr->size, map_ptr->map_priv_2);
+
+	if (ram)
+		map_ptr->map_priv_1 = addr;
+	else
+		map_ptr->map_priv_1 = (unsigned long) ioremap_nocache(map_ptr->map_priv_2, map_ptr->size);
+
+	if (!map_ptr->map_priv_1) {
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+
+	if (!ram) {
+		mymtd = do_map_probe("cfi_probe", map_ptr);
+		if (!mymtd)
+			mymtd = do_map_probe("jedec_probe", map_ptr);
+	} else
+		mymtd = do_map_probe("map_ram", map_ptr);
+
+	if (!mymtd) {
+		iounmap((void *)map_ptr->map_priv_1);
+		return -ENXIO;
+	}
+		
+	mymtd->module  = THIS_MODULE;
+	mymtd->point   = nettel_point;
+	mymtd->unpoint = nettel_unpoint;
+	mymtd->priv    = map_ptr;
+
+	if (ram) {
+		ram_mtdinfo = mymtd;
+		add_mtd_partitions(mymtd, nettel_romfs, NB_OF(nettel_romfs));
+		return(0);
+	}
+
+	flash_mtdinfo = mymtd;
+	switch (size) {
+	case SIZE_128K:
+		add_mtd_partitions(mymtd, nettel_128k, NB_OF(nettel_128k));
+		break;
+	case SIZE_1MB:
+		add_mtd_partitions(mymtd, nettel_1mb, NB_OF(nettel_1mb));
+		break;
+	case SIZE_2MB:
+		add_mtd_partitions(mymtd, nettel_2mb, NB_OF(nettel_2mb));
+		break;
+	case SIZE_4MB:
+		add_mtd_partitions(mymtd, nettel_4mb, NB_OF(nettel_4mb));
+		break;
+	case SIZE_8MB:
+		add_mtd_partitions(mymtd, nettel_8mb, NB_OF(nettel_8mb));
+		break;
+	case SIZE_16MB:
+		add_mtd_partitions(mymtd, nettel_16mb, NB_OF(nettel_16mb));
+		break;
+	}
+
+	return 0;
+}
+
+/****************************************************************************/
+
+int __init nettel_mtd_init(void)
+{
+	int rc = -1;
+	struct mtd_info *mtd;
+
+	/*
+	 * I hate this ifdef stuff,  but our HW doesn't always have
+	 * the same chipsize as the map that we use
+	 */
+#if defined(CONFIG_FLASH16MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = nettel_probe(0, FLASH_BASE, SIZE_16MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH8MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = nettel_probe(0, FLASH_BASE, SIZE_8MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH4MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = nettel_probe(0, FLASH_BASE, SIZE_4MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH2MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = nettel_probe(0, FLASH_BASE, SIZE_2MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH1MB) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = nettel_probe(0, FLASH_BASE, SIZE_1MB, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_FLASH128K) || defined(CONFIG_FLASHAUTO)
+	if (rc != 0)
+		rc = nettel_probe(0, FLASH_BASE, SIZE_128K, BUS_WIDTH);
+#endif
+
+#if defined(CONFIG_COLDFIRE) || defined(CONFIG_UCDIMM)
+	/*
+	 * Map in the filesystem from RAM last so that,  if the filesystem
+	 * is not in RAM for some reason we do not change the minor/major
+	 * for the flash devices
+	 */
+#ifndef CONFIG_ROMFS_FROM_ROM
+	if (0 != nettel_probe(1, (unsigned long) ROMFS_LOC,
+			PAGE_ALIGN(* (unsigned long *)(ROMFS_LOC + 8)), 4))
+		printk("Failed to probe RAM filesystem\n");
+#else
+	{
+		unsigned long start_area;
+		unsigned char *sp, *ep;
+
+		size_t len;
+
+		start_area = (unsigned long) ROMFS_LOC;
+
+		if (strncmp((char *) start_area, "-rom1fs-", 8) != 0) {
+			mtd = get_mtd_named("Image");
+			if (mtd && mtd->point) {
+				if ((*mtd->point)(mtd, 0, mtd->size, &len, &sp) == 0) {
+					ep = sp + len;
+					while (sp < ep && strncmp(sp, "-rom1fs-", 8) != 0)
+						sp++;
+					if (sp < ep)
+						start_area = (unsigned long) sp;
+				}
+			}
+			if (mtd)
+				put_mtd_device(mtd);
+		}
+		if (0 != nettel_probe(1, start_area,
+				PAGE_ALIGN(* (unsigned long *)(start_area + 8)), 4))
+			printk("Failed to probe RAM filesystem\n");
+	}
+#endif
+	
+	mtd = get_mtd_named("Romfs");
+	if (mtd) {
+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+		put_mtd_device(mtd);
+	}
+#endif
+
+#if defined(CONFIG_SH_SECUREEDGE5410) || defined(CONFIG_MIPS_VEGAS)
+{
+	extern int _end;
+	unsigned long magic;
+	unsigned char *cp = (char *) &_end;
+
+	memcpy(&magic, cp, sizeof(magic));
+	if (memcmp(cp, "-rom1fs-", 8) == 0) {
+#ifndef CONFIG_BLK_DEV_INITRD
+		/* romfs */ ;
+		nettel_probe(1, (unsigned long) cp,
+				PAGE_ALIGN(* (unsigned long *)(cp + 8)), 4);
+		mtd = get_mtd_named("Romfs");
+		if (mtd) {
+			ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+			put_mtd_device(mtd);
+		} else
+			printk("%s: Failed to find & make romfs root filesystem\n",
+					__FUNCTION__);
+#endif
+	} else if (magic == 0x28cd3d45) {
+#ifndef CONFIG_BLK_DEV_INITRD
+		/* cramfs */ ;
+		nettel_probe(1, (unsigned long) cp,
+				PAGE_ALIGN(* (unsigned long *)(cp + 4)), 4);
+		mtd = get_mtd_named("Romfs");
+		if (mtd) {
+			ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+			put_mtd_device(mtd);
+		} else
+			printk("%s: Failed to find & make cramfs root filesystem\n",
+					__FUNCTION__);
+#endif
+	} else {
+		mtd = get_mtd_named("Image");
+		if (mtd) {
+			ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+			put_mtd_device(mtd);
+		}
+#if defined(CONFIG_NFTL) || defined(CONFIG_INFTL)
+		else
+			ROOT_DEV = MKDEV(NFTL_MAJOR, 1);
+#endif
+	}
+}
+#endif
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	register_reboot_notifier(&nettel_notifier_block);
+#endif
+
+	return(rc);
+}
+
+/****************************************************************************/
+
+static void __exit nettel_mtd_cleanup(void)
+{
+	if (flash_mtdinfo) {
+		del_mtd_partitions(flash_mtdinfo);
+		map_destroy(flash_mtdinfo);
+		flash_mtdinfo = NULL;
+	}
+	if (ram_mtdinfo) {
+		del_mtd_partitions(ram_mtdinfo);
+		map_destroy(ram_mtdinfo);
+		ram_mtdinfo = NULL;
+	}
+	if (nettel_ram_map.map_priv_1) {
+		iounmap((void *)nettel_ram_map.map_priv_1);
+		nettel_ram_map.map_priv_1 = 0;
+	}
+	if (nettel_flash_map.map_priv_1) {
+		iounmap((void *)nettel_flash_map.map_priv_1);
+		nettel_flash_map.map_priv_1 = 0;
+	}
+}
+
+/****************************************************************************/
+
+module_init(nettel_mtd_init);
+module_exit(nettel_mtd_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David McCullough <davidm@snapgear.com>");
+MODULE_DESCRIPTION("SnapGear/SecureEdge FLASH support for uClinux");
+
+/****************************************************************************/
Index: linux-2.4.27/drivers/mtd/maps/nettel.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/nettel.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/nettel.c	2008-03-22 11:19:21.000000000 +0300
@@ -212,67 +212,16 @@
 	nettel_reboot_notifier, NULL, 0
 };
 
-/*
- *	Erase the configuration file system.
- *	Used to support the software reset button.
- */
-static void nettel_erasecallback(struct erase_info *done)
-{
-	wait_queue_head_t *wait_q = (wait_queue_head_t *)done->priv;
-	wake_up(wait_q);
-}
-
-static struct erase_info nettel_erase;
-
-int nettel_eraseconfig(void)
-{
-	struct mtd_info *mtd;
-	DECLARE_WAITQUEUE(wait, current);
-	wait_queue_head_t wait_q;
-	int ret;
-
-	init_waitqueue_head(&wait_q);
-	mtd = get_mtd_device(NULL, 2);
-	if (mtd) {
-		nettel_erase.mtd = mtd;
-		nettel_erase.callback = nettel_erasecallback;
-		nettel_erase.callback = 0;
-		nettel_erase.addr = 0;
-		nettel_erase.len = mtd->size;
-		nettel_erase.priv = (u_long) &wait_q;
-		nettel_erase.priv = 0;
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		add_wait_queue(&wait_q, &wait);
-
-		ret = MTD_ERASE(mtd, &nettel_erase);
-		if (ret) {
-			set_current_state(TASK_RUNNING);
-			remove_wait_queue(&wait_q, &wait);
-			put_mtd_device(mtd);
-			return(ret);
-		}
-
-		schedule();  /* Wait for erase to finish. */
-		remove_wait_queue(&wait_q, &wait);
-		
-		put_mtd_device(mtd);
-	}
-
-	return(0);
-}
-
-#else
-
-int nettel_eraseconfig(void)
-{
-	return(0);
-}
 
 #endif
 
 /****************************************************************************/
 
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define nettel_init init_module
+#define nettel_cleanup cleanup_module
+#endif
+
 int __init nettel_init(void)
 {
 	volatile unsigned long *amdpar;
Index: linux-2.4.27/drivers/mtd/maps/ocelot.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/ocelot.c	2001-10-05 02:14:59.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/ocelot.c	2008-03-22 11:19:21.000000000 +0300
@@ -20,7 +20,7 @@
 #define NVRAM_WINDOW_SIZE 0x00007FF0
 #define NVRAM_BUSWIDTH 1
 
-extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts, unsigned long fis_origin);
 
 static unsigned int cacheflush = 0;
 
@@ -156,7 +156,7 @@
 	add_mtd_device(nvram_mtd);
 
 	flash_mtd->module = THIS_MODULE;
-	nr_parts = parse_redboot_partitions(flash_mtd, &parsed_parts);
+	nr_parts = parse_redboot_partitions(flash_mtd, &parsed_parts, 0);
 
 	if (nr_parts)
 		add_mtd_partitions(flash_mtd, parsed_parts, nr_parts);
Index: linux-2.4.27/drivers/mtd/maps/physmap.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/physmap.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/physmap.c	2008-03-22 11:19:21.000000000 +0300
@@ -119,6 +119,12 @@
 {
 	static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", "map_rom", 0 };
 	const char **type;
+#ifdef CONFIG_MTD_PARTITIONS
+	int nb_parts = 0, parsed_nr_parts = 0;
+	struct mtd_partition *parts;
+	const char *part_type;
+	static struct mtd_partition *parsed_parts;
+#endif
 
        	printk(KERN_NOTICE "physmap flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
 	physmap_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
@@ -147,6 +153,14 @@
 			       "Using command line partition definition\n");
 			add_mtd_partitions (mymtd, mtd_parts, mtd_parts_nb);
 		}
+
+		if (parsed_nr_parts == 0) {
+			int ret = parse_cmdline_partitions(mymtd, &parsed_parts, "physmap");
+			if (ret > 0) {
+				part_type = "Command Line";
+				parsed_nr_parts = ret;
+			}
+		}
 #else
 		if (NUM_PARTITIONS != 0) 
 		{
@@ -154,9 +168,24 @@
 			       "Using physmap partition definition\n");
 			add_mtd_partitions (mymtd, physmap_partitions, NUM_PARTITIONS);
 		}
+#endif /* CONFIG_MTD_CMDLINE_PARTS */
+
+		if (parsed_nr_parts > 0) {
+			parts = parsed_parts;
+			nb_parts = parsed_nr_parts;
+		}
+
+		if (nb_parts == 0) {
+			printk(KERN_NOTICE "physmap: no partition info available, "
+					"registering whole flash at once\n");
+			add_mtd_device(mymtd);
+		} else {
+			printk(KERN_NOTICE "physmap: Using %s partition definition\n",
+					part_type);
+			add_mtd_partitions(mymtd, parts, nb_parts);
+		}
+#endif /* CONFIG_MTD_PARTITIONS */
 
-#endif
-#endif
 		return 0;
 	}
 
Index: linux-2.4.27/drivers/mtd/maps/sa1100-flash.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/sa1100-flash.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/sa1100-flash.c	2008-03-22 11:19:21.000000000 +0300
@@ -765,8 +765,8 @@
 };
 #endif
 
-extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
-extern int parse_bootldr_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts, unsigned long fis_origin);
+extern int parse_cmdline_partitions(struct mtd_info *master, struct mtd_partition **pparts);
 
 static struct mtd_partition *parsed_parts;
 static struct mtd_info *mymtd;
@@ -964,7 +964,7 @@
 	 */
 #ifdef CONFIG_MTD_REDBOOT_PARTS
 	if (parsed_nr_parts == 0) {
-		int ret = parse_redboot_partitions(mymtd, &parsed_parts);
+		int ret = parse_redboot_partitions(mymtd, &parsed_parts, 0);
 
 		if (ret > 0) {
 			part_type = "RedBoot";
Index: linux-2.4.27/drivers/mtd/maps/se4000.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/se4000.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,176 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+
+#define WINDOW_ADDR 	0x50000000
+#define BUSWIDTH 	2
+#define WINDOW_SIZE	0x01000000
+
+#ifndef __ARMEB__
+#define	B0(h)	((h) & 0xFF)
+#define	B1(h)	(((h) >> 8) & 0xFF)
+#else
+#define	B0(h)	(((h) >> 8) & 0xFF)
+#define	B1(h)	((h) & 0xFF)
+#endif
+
+static __u16 se4000_read16(struct map_info *map, unsigned long ofs)
+{
+    return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+/*
+ * The IXP425 expansion bus only allows 16-bit wide acceses
+ * when attached to a 16-bit wide device (such as the 28F128J3A),
+ * so we can't use a memcpy_fromio as it does byte acceses.
+ */
+static void se4000_copy_from(struct map_info *map, void *to,
+    unsigned long from, ssize_t len)
+{
+	int i;
+	u8 *dest = (u8*)to;
+	u16 *src = (u16 *)(map->map_priv_1 + from);
+	u16 data;
+
+	for (i = 0; i < (len / 2); i++) {
+		data = src[i];
+		dest[i * 2] = B0(data);
+		dest[i * 2 + 1] = B1(data);
+	}
+
+	if (len & 1)
+		dest[len - 1] = B0(src[i]);
+}
+
+static void se4000_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+    *(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static struct map_info se4000_map = {
+	name: 		"SnapGear SE4000 Flash",
+	buswidth: 	BUSWIDTH,
+	read16:		se4000_read16,
+	copy_from:	se4000_copy_from,
+	write16:	se4000_write16,
+};
+
+static struct mtd_partition *parsed_parts;
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+/*
+ * Set the Intel flash back to read mode as MTD may leave it in command mode
+ */
+
+static int se4000_reboot_notifier(
+	struct notifier_block *nb,
+	unsigned long val,
+	void *v)
+{
+	struct cfi_private *cfi = se4000_map.fldrv_priv;
+	int i;
+	
+	for (i = 0; cfi && i < cfi->numchips; i++)
+		cfi_send_gen_cmd(0xff, 0x55, cfi->chips[i].start, &se4000_map,
+			cfi, cfi->device_type, NULL);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block se4000_notifier_block = {
+	se4000_reboot_notifier, NULL, 0
+};
+
+#endif
+
+
+static struct mtd_info *se4000_mtd;
+static struct resource *mtd_resource;
+
+static void se4000_exit(void)
+{
+    if (se4000_mtd) {
+	del_mtd_partitions(se4000_mtd);
+	map_destroy(se4000_mtd);
+    }
+    if (se4000_map.map_priv_1)
+	iounmap((void *)se4000_map.map_priv_1);
+    if (mtd_resource)
+	release_mem_region(WINDOW_ADDR, WINDOW_SIZE);
+  
+    if (parsed_parts)
+	kfree(parsed_parts);
+
+    /* Disable flash write */
+    *IXP425_EXP_CS0 &= ~IXP425_FLASH_WRITABLE;
+}
+
+static int __init se4000_init(void)
+{
+    int res, npart;
+
+    /* Enable flash write */
+    *IXP425_EXP_CS0 |= IXP425_FLASH_WRITABLE;
+
+    se4000_map.map_priv_1 = 0;
+    mtd_resource = request_mem_region(WINDOW_ADDR, WINDOW_SIZE, "SnapGear SE4000");
+    if (!mtd_resource) {
+	printk(KERN_ERR "SE4000: request_mem_region() failed\n" );
+	res = -ENOMEM;
+	goto Error;
+    }
+
+    se4000_map.map_priv_1 = (unsigned long) ioremap(WINDOW_ADDR, WINDOW_SIZE);
+    if (!se4000_map.map_priv_1) {
+	printk(KERN_ERR "SE4000: ioremap() failed\n");
+	res = -EIO;
+	goto Error;
+    }
+    se4000_map.size = WINDOW_SIZE;
+
+    /* 
+     * Probe for the CFI complaint chip
+     * suposed to be 28F128J3A
+     */
+    se4000_mtd = do_map_probe("cfi_probe", &se4000_map);
+    if (!se4000_mtd) {
+	res = -ENXIO;
+	goto Error;
+    }
+    se4000_mtd->module = THIS_MODULE;
+   
+    /* Try to parse RedBoot partitions */
+    npart = parse_redboot_partitions(se4000_mtd, &parsed_parts, 0);
+    if (npart > 0) {
+	/* found "npart" RedBoot partitions */
+	res = add_mtd_partitions(se4000_mtd, parsed_parts, npart);
+    } else {
+	res = -EIO;
+    }
+
+    if (res)
+	goto Error;
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	register_reboot_notifier(&se4000_notifier_block);
+#endif
+
+    return res;
+Error:
+    se4000_exit();
+    return res;
+}
+
+module_init(se4000_init);
+module_exit(se4000_exit);
+
+MODULE_DESCRIPTION("MTD map driver for SnapGear SE4000");
+
Index: linux-2.4.27/drivers/mtd/maps/sedsios.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/sedsios.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,257 @@
+/****************************************************************************/
+/*
+ * Flash memory access on uClinux SIOS III like devices
+ * Copyright (C) 2001-2002, David McCullough <davidm@snapgear.com>
+ * Copyright (C) 2004, SED Systems <hamilton@sedsystems.ca>
+ */
+/****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/reboot.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nftl.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+
+#include <linux/fs.h>
+
+#include <asm/io.h>
+#include <asm/delay.h>
+/****************************************************************************/
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+#define SIZE_128K	(1  *  128 * 1024)
+#define SIZE_1MB	(1  * 1024 * 1024)
+#define SIZE_2MB	(2  * 1024 * 1024)
+#define SIZE_4MB	(4  * 1024 * 1024)
+#define SIZE_8MB	(8  * 1024 * 1024)
+#define SIZE_16MB	(16 * 1024 * 1024)
+
+#define FLASH_BASE	0x7fc00000
+#define	BUS_WIDTH	2
+/****************************************************************************/
+
+static __u8 sedcfc_read8(struct map_info *map, unsigned long ofs)
+{
+	return *(__u8 *)(map->map_priv_1 + ofs);
+}
+
+static __u16 sedcfc_read16(struct map_info *map, unsigned long ofs)
+{
+	return *(__u16 *)(map->map_priv_1 + ofs);
+}
+
+static __u32 sedcfc_read32(struct map_info *map, unsigned long ofs)
+{
+	return *(__u32 *)(map->map_priv_1 + ofs);
+}
+
+static void sedcfc_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void sedcfc_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	*(__u8 *)(map->map_priv_1 + adr) = d;
+}
+
+static void sedcfc_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	*(__u16 *)(map->map_priv_1 + adr) = d;
+}
+
+static void sedcfc_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	*(__u32 *)(map->map_priv_1 + adr) = d;
+}
+
+static void sedcfc_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+/****************************************************************************/
+
+static struct map_info sedcfc_flash_map =
+{
+	name:		"Flash",
+	read8:		sedcfc_read8,
+	read16:		sedcfc_read16,
+	read32:		sedcfc_read32,
+	copy_from:	sedcfc_copy_from,
+	write8:		sedcfc_write8,
+	write16:	sedcfc_write16,
+	write32:	sedcfc_write32,
+	copy_to:	sedcfc_copy_to,
+};
+
+static struct mtd_info *flash_mtdinfo;
+
+/****************************************************************************/
+/*
+ *	The layout of our flash,  note the order of the names,  this
+ *	means we use the same major/minor for the same purpose on all
+ *	layouts (when possible)
+ */
+static struct mtd_partition sedcfc_4mb[] =
+{
+	{ name: "Colilo",     offset: 0x00000000, size:   0x00010000 },
+	{ name: "Kernel",     offset: 0x00010000, size:   0x00070000 },
+	{ name: "RootFS",     offset: 0x00080000, size:   0x00180000 },
+	{ name: "SEDFS",      offset: 0x00200000, size:   0x00200000 }
+};
+
+/****************************************************************************/
+/*
+ * Find the MTD device with the given name
+ */
+
+static struct mtd_info *get_mtd_named(char *name)
+{
+	int i;
+	struct mtd_info *mtd;
+
+	for (i = 0; i < MAX_MTD_DEVICES; i++)
+	{
+		mtd = get_mtd_device(NULL, i);
+		if (mtd)
+		{
+			if (strcmp(mtd->name, name) == 0)
+				return(mtd);
+			put_mtd_device(mtd);
+		}
+	}
+	return(NULL);
+}
+
+/****************************************************************************/
+static int sedcfc_point(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char **mtdbuf)
+{
+	struct map_info *map = (struct map_info *) mtd->priv;
+	*mtdbuf = (u_char *) (map->map_priv_1 + (int)from);
+	*retlen = len;
+	return(0);
+}
+/****************************************************************************/
+static void
+sedcfc_unpoint(struct mtd_info *mtd, u_char *addr, loff_t from, size_t len)
+{
+}
+/****************************************************************************/
+static int __init
+sedcfc_probe(int ram, unsigned long addr, int size, int buswidth)
+{
+	struct mtd_info *mymtd;
+	struct map_info *map_ptr;
+	struct mtd_info *mtd;
+
+	map_ptr = &sedcfc_flash_map;
+
+	map_ptr->buswidth = buswidth;
+	map_ptr->map_priv_2 = addr;
+	map_ptr->size = size;
+
+	printk(KERN_NOTICE "SED SIOS III Core flash probe(0x%lx,%d,%d): %lx at %lx\n",
+			addr, size, buswidth, map_ptr->size,
+			map_ptr->map_priv_2);
+
+	map_ptr->map_priv_1 = (unsigned long)
+		ioremap_nocache(map_ptr->map_priv_2, map_ptr->size);
+
+	if (!map_ptr->map_priv_1)
+	{
+		printk("Failed to ioremap_nocache\n");
+		return -EIO;
+	}
+
+	mymtd = do_map_probe("amd_flash", map_ptr);
+
+	if(!mymtd)
+	{
+		printk("Failed to find device doing amd_flash,"
+				" trying cfi_probe\n");
+		mymtd = do_map_probe("cfi_probe", map_ptr);
+	}
+
+	if (!mymtd)
+	{
+		printk("Failed to find device doing cfi_probe\n");
+		iounmap((void *)map_ptr->map_priv_1);
+		return -ENXIO;
+	}
+
+	mymtd->module  = THIS_MODULE;
+	mymtd->point   = sedcfc_point;
+	mymtd->unpoint = sedcfc_unpoint;
+	mymtd->priv    = map_ptr;
+
+	flash_mtdinfo = mymtd;
+	switch (size)
+	{
+		case SIZE_4MB:
+			add_mtd_partitions(mymtd, sedcfc_4mb,
+					NB_OF(sedcfc_4mb));
+			break;
+	}
+	mtd = get_mtd_named("RootFS");
+	if (mtd)
+	{
+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+		put_mtd_device(mtd);
+	}
+	else
+	{
+		printk("Root device not set\n");
+	}
+
+	return 0;
+}
+
+/****************************************************************************/
+
+int __init sedcfc_mtd_init(void)
+{
+	int rc = -1;
+	struct mtd_info *mtd;
+
+	printk(KERN_NOTICE "Initializing flash devices for filesystems\n");
+
+	rc = sedcfc_probe(0, FLASH_BASE, SIZE_4MB, BUS_WIDTH);
+	
+	mtd = get_mtd_named("RootFS");
+	if (mtd)
+	{
+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+		put_mtd_device(mtd);
+	}
+	return(rc);
+}
+/****************************************************************************/
+static void __exit sedcfc_mtd_cleanup(void)
+{
+	if (flash_mtdinfo)
+	{
+		del_mtd_partitions(flash_mtdinfo);
+		map_destroy(flash_mtdinfo);
+		flash_mtdinfo = NULL;
+	}
+	if (sedcfc_flash_map.map_priv_1)
+	{
+		iounmap((void *)sedcfc_flash_map.map_priv_1);
+		sedcfc_flash_map.map_priv_1 = 0;
+	}
+}
+/****************************************************************************/
+module_init(sedcfc_mtd_init);
+module_exit(sedcfc_mtd_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David McCullough <davidm@snapgear.com>");
+MODULE_DESCRIPTION("SED SIOS III Flash support for uClinux");
+/****************************************************************************/
Index: linux-2.4.27/drivers/mtd/maps/snaparm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/snaparm.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,241 @@
+/****************************************************************************/
+
+/*
+ *      snaparm.c -- mappings for SnapGear ARM based boards
+ *
+ *      (C) Copyright 2000-2003, Greg Ungerer (gerg@snapgear.com)
+ *      (C) Copyright 2001-2003, SnapGear (www.snapgear.com)
+ *
+ *	I expect most SnapGear ARM based boards will have similar
+ *	flash arrangements. So this map driver can handle them all.
+ */
+
+/****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+#include <linux/reboot.h>
+#include <asm/io.h>
+
+/****************************************************************************/
+
+static struct mtd_info *sg_mtd;
+
+/****************************************************************************/
+
+/*
+ *	Define physical addresss flash is mapped at. Will be different on
+ *	different boards.
+ */
+#if CONFIG_ARCH_SE4000
+#define	FLASH_ADDR	0x50000000		/* Physical flash address */
+#define	FLASH_SIZE	0x00800000		/* Maximum flash size */
+#endif
+
+#if CONFIG_ARCH_KS8695
+#define	FLASH_ADDR	0x02000000		/* Physical flash address */
+#define	FLASH_SIZE	0x00800000		/* Maximum flash size */
+#endif
+
+/****************************************************************************/
+
+static __u8 sg_read8(struct map_info *map, unsigned long ofs)
+{
+	return(readb(map->map_priv_1 + ofs));
+}
+
+static __u16 sg_read16(struct map_info *map, unsigned long ofs)
+{
+	return(readw(map->map_priv_1 + ofs));
+}
+
+static __u32 sg_read32(struct map_info *map, unsigned long ofs)
+{
+	return(readl(map->map_priv_1 + ofs));
+}
+
+static void sg_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+static void sg_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void sg_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void sg_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void sg_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+/****************************************************************************/
+
+/*
+ *	Intel FLASH setup. This is the only flash device, it is the entire
+ *	non-volatile storage (no IDE CF or hard drive or anything else).
+ */
+
+static struct map_info sg_map = {
+	name: "SnapGear Intel/StrataFlash",
+	size: 0x800000,
+	buswidth: 1,
+	read8: sg_read8,
+	read16: sg_read16,
+	read32: sg_read32,
+	copy_from: sg_copy_from,
+	write8: sg_write8,
+	write16: sg_write16,
+	write32: sg_write32,
+	copy_to: sg_copy_to
+};
+
+static struct mtd_partition sg_partitions[] = {
+	{
+		name: "SnapGear Boot Loader",
+		offset: 0,
+		size: 0x00020000
+	},
+	{
+		name: "SnapGear non-volatile configuration",
+		offset: 0x00020000,
+		size: 0x00020000
+	},
+	{
+		name: "SnapGear image",
+		offset: 0x40000,
+		size: 0x003c0000
+	},
+};
+
+/****************************************************************************/
+
+#define NUM_PARTITIONS	(sizeof(sg_partitions)/sizeof(sg_partitions[0]))
+
+/****************************************************************************/
+
+/*
+ *	Set the Intel flash back to read mode. Sometimes MTD leaves the
+ *	flash in status mode, and if you reboot there is no code to
+ *	execute (the flash devices do not get a RESET) :-(
+ */
+static int sg_reboot_notifier(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct cfi_private *cfi = sg_map.fldrv_priv;
+	unsigned long b;
+
+	/* Make sure all FLASH chips are put back into read mode */
+	for (b = 0; (b < sg_partitions[2].size); b += 0x400000) {
+		cfi_send_gen_cmd(0xff, 0x55, b, &sg_map, cfi,
+			cfi->device_type, NULL);
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block sg_notifier_block = {
+	sg_reboot_notifier, NULL, 0
+};
+
+/****************************************************************************/
+
+/*
+ *	Find the MTD device with the given name.
+ */
+
+static int sg_getmtdindex(char *name)
+{
+	struct mtd_info *mtd;
+	int i, index;
+
+	index = -1;
+	for (i = 0; (i < MAX_MTD_DEVICES); i++) {
+		mtd = get_mtd_device(NULL, i);
+		if (mtd) {
+			if (strcmp(mtd->name, name) == 0)
+				index = mtd->index;
+			put_mtd_device(mtd);
+			if (index >= 0)
+				break;
+		}
+	}
+	return index;
+}
+
+/****************************************************************************/
+
+int __init sg_init(void)
+{
+	int index, rc;
+
+	printk("SNAPGEAR: MTD flash setup\n");
+
+	/*
+	 *	Map flash into our virtual address space.
+	 */
+	sg_map.map_priv_1 = (unsigned long)
+		ioremap_nocache(FLASH_ADDR, FLASH_SIZE);
+	if (!sg_map.map_priv_1) {
+		printk("SNAPGEAR: failed to ioremap() flash\n");
+		return -EIO;
+	}
+
+	if ((sg_mtd = do_map_probe("cfi_probe", &sg_map)) == NULL)
+		return -ENXIO;
+
+	printk(KERN_NOTICE "SNAPGEAR: %s device size = %dK\n",
+		sg_mtd->name, sg_mtd->size>>10);
+
+	sg_mtd->module = THIS_MODULE;
+	register_reboot_notifier(&sg_notifier_block);
+	rc =  add_mtd_partitions(sg_mtd, sg_partitions, NUM_PARTITIONS);
+
+#ifndef CONFIG_BLK_DEV_INITRD
+	index = sg_getmtdindex("SnapGear image");
+	if (index >= 0)
+		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, index);
+#endif
+
+	return rc;
+}
+
+/****************************************************************************/
+
+void __exit sg_cleanup(void)
+{
+	unregister_reboot_notifier(&sg_notifier_block);
+	if (sg_mtd) {
+		del_mtd_partitions(sg_mtd);
+		map_destroy(sg_mtd);
+	}
+	if (sg_map.map_priv_1) {
+		iounmap((void *)sg_map.map_priv_1);
+		sg_map.map_priv_1 = 0;
+	}
+}
+
+/****************************************************************************/
+
+module_init(sg_init);
+module_exit(sg_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Greg Ungerer <gerg@snapgear.com>");
+MODULE_DESCRIPTION("SnapGear/ARM flash support");
+
+/****************************************************************************/
Index: linux-2.4.27/drivers/mtd/maps/snapgeode.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/snapgeode.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,277 @@
+/****************************************************************************/
+
+/*
+ *      snapgeode.c -- mappings for SnapGear GEODE based boards
+ *
+ *      (C) Copyright 2000-2003, Greg Ungerer (gerg@snapgear.com)
+ *      (C) Copyright 2001-2003, SnapGear (www.snapgear.com)
+ */
+
+/****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/cfi.h>
+#include <linux/reboot.h>
+#include <asm/io.h>
+
+/****************************************************************************/
+
+static struct mtd_info *sg_mtd;
+
+/****************************************************************************/
+
+static __u8 sg_read8(struct map_info *map, unsigned long ofs)
+{
+	return(readb(map->map_priv_1 + ofs));
+}
+
+static __u16 sg_read16(struct map_info *map, unsigned long ofs)
+{
+	return(readw(map->map_priv_1 + ofs));
+}
+
+static __u32 sg_read32(struct map_info *map, unsigned long ofs)
+{
+	return(readl(map->map_priv_1 + ofs));
+}
+
+static void sg_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+static void sg_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void sg_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void sg_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void sg_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+/****************************************************************************/
+#ifdef CONFIG_MTD_CFI_INTELEXT
+/****************************************************************************/
+
+/*
+ *	Intel FLASH setup. This is the only flash device, it is the entire
+ *	non-volatile storage (no IDE CF or hard drive).
+ */
+
+static struct map_info sg_map = {
+	name: "SnapGear Intel/StrataFlash",
+	size: 0x800000,
+	buswidth: 1,
+	read8: sg_read8,
+	read16: sg_read16,
+	read32: sg_read32,
+	copy_from: sg_copy_from,
+	write8: sg_write8,
+	write16: sg_write16,
+	write32: sg_write32,
+	copy_to: sg_copy_to
+};
+
+static struct mtd_partition sg_partitions[] = {
+	{
+		name: "SnapGear kernel",
+		offset: 0,
+		size: 0x000e0000
+	},
+	{
+		name: "SnapGear filesystem",
+		offset: 0x00100000,
+	},
+	{
+		name: "SnapGear config",
+		offset: 0x000e0000,
+		size: 0x00020000
+	},
+	{
+		name: "SnapGear Intel/StrataFlash",
+		offset: 0
+	},
+	{
+		name: "SnapGear BIOS Config",
+		offset: 0x007e0000,
+		size: 0x00020000
+	},
+	{
+		name: "SnapGear BIOS",
+		offset: 0x007e0000,
+		size: 0x00020000
+	},
+};
+
+#define	PROBE	"cfi_probe"
+
+/****************************************************************************/
+#else
+/****************************************************************************/
+
+/*
+ *	If only an AMD flash is fitted then it is the BIOS/boot loader.
+ *	Primary non-volatile storage must be via some ither IDE mechanism
+ *	(either compact flash [CF] or real hard drive).
+ */
+
+static struct map_info sg_map = {
+	name: "SnapGear AMD/Flash",
+	size: 0x800000,
+	buswidth: 1,
+	read8: sg_read8,
+	read16: sg_read16,
+	read32: sg_read32,
+	copy_from: sg_copy_from,
+	write8: sg_write8,
+	write16: sg_write16,
+	write32: sg_write32,
+	copy_to: sg_copy_to
+};
+
+static struct mtd_partition sg_partitions[] = {
+	{
+		name: "SnapGear BIOS config",
+		offset: 0x00000000,
+		size: 0x00010000
+	},
+	{
+		name: "SnapGear BIOS",
+		offset: 0x00010000,
+		size: 0x00010000
+	},
+	{
+		name: "SnapGear AMD/Flash",
+		offset: 0
+	},
+};
+
+#define	PROBE	"jedec_probe"
+
+/****************************************************************************/
+#endif
+/****************************************************************************/
+
+#define NUM_PARTITIONS	(sizeof(sg_partitions)/sizeof(sg_partitions[0]))
+
+/****************************************************************************/
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+
+/*
+ *	Set the Intel flash back to read mode. Sometimes MTD leaves the
+ *	flash in status mode, and if you reboot there is no code to
+ *	execute (the flash devices do not get a RESET) :-(
+ */
+static int sg_reboot_notifier(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct cfi_private *cfi = sg_map.fldrv_priv;
+	unsigned long b;
+
+	/* Make sure all FLASH chips are put back into read mode */
+	for (b = 0; (b < sg_partitions[3].size); b += 0x100000) {
+		cfi_send_gen_cmd(0xff, 0x55, b, &sg_map, cfi,
+			cfi->device_type, NULL);
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block sg_notifier_block = {
+	sg_reboot_notifier, NULL, 0
+};
+
+#endif /* CONFIG_MTD_CFI_INTELEXT */
+
+/****************************************************************************/
+
+int __init sg_init(void)
+{
+	printk("SNAPGEAR: MTD BIOS setup\n");
+
+	/*
+	 *	On the GEODE the ROM CS stays mapped into high memory.
+	 *	So we look for it at the top of the 32bit address space.
+	 */
+	sg_map.map_priv_1 = (unsigned long)
+		ioremap_nocache(0xff800000, 0x800000);
+	if (!sg_map.map_priv_1) {
+		printk("SNAPGEAR: failed to ioremap() ROMCS\n");
+		return -EIO;
+	}
+
+	if ((sg_mtd = do_map_probe(PROBE, &sg_map)) == NULL)
+		return -ENXIO;
+
+	printk(KERN_NOTICE "SNAPGEAR: %s device size = %dK\n",
+		sg_mtd->name, sg_mtd->size>>10);
+
+	sg_mtd->module = THIS_MODULE;
+
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	sg_partitions[1].size = sg_mtd->size -
+		(sg_partitions[1].offset + sg_mtd->erasesize);
+	if (sg_mtd->size > 0x800000) {
+		sg_partitions[4].offset += sg_mtd->size - 0x800000;
+		sg_partitions[5].offset += sg_mtd->size - 0x800000;
+	}
+	register_reboot_notifier(&sg_notifier_block);
+#ifndef CONFIG_BLK_DEV_INITRD
+	ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, 1);
+#endif
+#else
+	/*
+	 * Setup the partitions, second from top 64KiB and top 64KiB
+	 */
+	if (sg_mtd->size > 0x20000) {
+		sg_partitions[0].offset += sg_mtd->size - 0x20000;
+		sg_partitions[1].offset += sg_mtd->size - 0x20000;
+	}
+#endif /* !CONFIG_MTD_CFI_INTELEXT */
+
+	return add_mtd_partitions(sg_mtd, sg_partitions, NUM_PARTITIONS);
+}
+
+/****************************************************************************/
+
+void __exit sg_cleanup(void)
+{
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	unregister_reboot_notifier(&sg_notifier_block);
+#endif
+	if (sg_mtd) {
+		del_mtd_partitions(sg_mtd);
+		map_destroy(sg_mtd);
+	}
+	if (sg_map.map_priv_1) {
+		iounmap((void *)sg_map.map_priv_1);
+		sg_map.map_priv_1 = 0;
+	}
+}
+
+/****************************************************************************/
+
+module_init(sg_init);
+module_exit(sg_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Greg Ungerer <gerg@snapgear.com>");
+MODULE_DESCRIPTION("SnapGear/GEODE flash support");
+
+/****************************************************************************/
Index: linux-2.4.27/drivers/mtd/maps/solutionengine.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/maps/solutionengine.c	2002-08-03 04:39:44.000000000 +0400
+++ linux-2.4.27/drivers/mtd/maps/solutionengine.c	2008-03-22 11:19:21.000000000 +0300
@@ -18,7 +18,7 @@
 #include <linux/config.h>
 
 
-extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts, unsigned long fis_origin);
 
 __u32 soleng_read32(struct map_info *map, unsigned long ofs)
 {
@@ -110,7 +110,7 @@
 	}
 
 #ifdef CONFIG_MTD_REDBOOT_PARTS
-	nr_parts = parse_redboot_partitions(flash_mtd, &parsed_parts);
+	nr_parts = parse_redboot_partitions(flash_mtd, &parsed_parts, 0);
 	if (nr_parts > 0)
 		printk(KERN_NOTICE "Found RedBoot partition table.\n");
 	else if (nr_parts < 0)
Index: linux-2.4.27/drivers/mtd/maps/suzaku.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/mtd/maps/suzaku.c	2008-03-22 11:19:21.000000000 +0300
@@ -0,0 +1,202 @@
+/*
+ * drivers/mtd/maps/suzaku.c
+ *
+ * Copyright (C) 2003, 2004 Atmark Techno, Inc.
+ *
+ * Yasushi SHOJI <yashi@atmark-techno.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/types.h>
+#include <linux/ioport.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+MODULE_AUTHOR("Atmark Techno, Inc.");
+MODULE_DESCRIPTION("Suzaku Flash map driver");
+MODULE_LICENSE("GPL v2");
+
+#define FLASH_START 0xff000000
+#define FLASH_SIZE  0x00400000
+#define FLASH_WIDTH 2
+
+__u16 suzaku_read16(struct map_info *map, unsigned long ofs)
+{
+        return readw(map->map_priv_1 + ofs);
+}
+
+void suzaku_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+        writew(d, map->map_priv_1 + adr);
+}
+
+void suzaku_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+        memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void suzaku_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+        memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *flash_mtd;
+
+struct map_info suzaku_flash_map = {
+        .name      = "flash",
+        .size      = FLASH_SIZE,
+        .buswidth  = FLASH_WIDTH,
+
+        .read16    = suzaku_read16,
+        .copy_from = suzaku_copy_from,
+
+        .write16   = suzaku_write16,
+        .copy_to   = suzaku_copy_to,
+};
+
+/*
+ *      0x0 +-------------+
+ *          |    FPGA     |
+ *  0x80000 +-------------+
+ *          |    Boot     |
+ *  0xa0000 +------+------+
+ *          |      | Kern |
+ * 0x210000 | IMG  +------+
+ *          |      | User |
+ * 0x3f0000 +------+------+
+ *          |   Config    |
+ *          +-------------+
+ */
+/*
+ * Do _NOT_ change the order of first four entries. These entries are
+ * fixed and assinged to fixed minor numbers.
+ */
+#define CONFIG_SUZAKU_FLASH_TOP
+#if defined(CONFIG_SUZAKU_FLASH_TOP)
+struct mtd_partition suzaku_partitions[] = {
+        { .name = "Flash/All",        .size = 0x00400000, .offset = 0, },
+        { .name = "Flash/FPGA",       .size = 0x00080000, .offset = 0, },
+        { .name = "Flash/Bootloader", .size = 0x00020000, .offset = 0x00080000, },
+        { .name = "Flash/Config",     .size = 0x00010000, .offset = 0x003F0000, },
+        { .name = "Flash/Image",      .size = 0x00350000, .offset = 0x000A0000, },
+        { .name = "Flash/Kernel",     .size = 0x00170000, .offset = 0x000A0000, },
+        { .name = "Flash/User",       .size = 0x001E0000, .offset = 0x00210000, },
+};
+#else
+struct mtd_partition suzaku_partitions[] = {
+        { .name = "Flash/Bootloader", .size = 0x00008000, .offset = 0,},
+        { .name = "Flash/Reserved",   .size = 0x00008000, .offset = MTDPART_OFS_APPEND, },
+        { .name = "Flash/User",       .size = 0x00370000, .offset = MTDPART_OFS_APPEND, },
+        { .name = "Flash/FPGA",       .size = 0x00080000, .offset = MTDPART_OFS_APPEND, },
+};
+#endif
+
+struct resource suzaku_flash_resource = {
+        .name  = "flash",
+        .start = FLASH_START,
+        .end   = FLASH_START + FLASH_SIZE - 1,
+        .flags = IORESOURCE_IO | IORESOURCE_BUSY,
+};
+
+static int __init init_suzaku_flash (void)
+{
+        struct mtd_partition *parts;
+        int nb_parts = 0;
+        int err;
+        
+        parts = suzaku_partitions;
+        nb_parts = NB_OF(suzaku_partitions);
+        
+        if (request_resource (&ioport_resource, &suzaku_flash_resource)) {
+                printk(KERN_NOTICE "Failed to reserve Suzaku Flash space\n");
+                err = -EBUSY;
+                goto out;
+        }
+        
+        suzaku_flash_map.map_priv_1 = (unsigned long)ioremap(FLASH_START, FLASH_SIZE);
+        if (!suzaku_flash_map.map_priv_1) {
+                printk(KERN_NOTICE "Failed to ioremap Suzaku Flash space\n");
+                err = -EIO;
+                goto out_resource;
+        }
+
+        flash_mtd = do_map_probe("cfi_probe", &suzaku_flash_map);
+        if (!flash_mtd) {
+                flash_mtd = do_map_probe("map_rom", &suzaku_flash_map);
+        }
+        if (!flash_mtd) {
+                printk("FLASH probe failed\n");
+                err = -ENXIO;
+                goto out_ioremap;
+        }
+
+        flash_mtd->module = THIS_MODULE;
+        
+        if (add_mtd_partitions(flash_mtd, parts, nb_parts)) {
+                printk("FLASH partitions addition failed\n");
+                err = -ENOMEM;
+                goto out_probe;
+        }
+                
+        return 0;
+
+out_probe:
+        map_destroy(flash_mtd);
+        flash_mtd = 0;
+out_ioremap:
+        iounmap((void *)suzaku_flash_map.map_priv_1);
+out_resource:
+        release_resource (&suzaku_flash_resource);
+out:
+        return err;
+}
+
+static int __init init_suzaku_maps(void)
+{
+        printk(KERN_INFO "Suzaku MTD mappings:\n  Flash 0x%x at 0x%x\n", 
+               FLASH_SIZE, FLASH_START);
+
+        init_suzaku_flash();
+        
+        return 0;
+}
+
+static void __exit cleanup_suzaku_maps(void)
+{
+        if (flash_mtd) {
+                del_mtd_partitions(flash_mtd);
+                map_destroy(flash_mtd);
+                iounmap((void *)suzaku_flash_map.map_priv_1);
+                release_resource (&suzaku_flash_resource);
+        }
+}
+
+module_init(init_suzaku_maps);
+module_exit(cleanup_suzaku_maps);
Index: linux-2.4.27/drivers/mtd/mtdblock.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/mtdblock.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/mtdblock.c	2008-03-22 11:19:21.000000000 +0300
@@ -566,6 +566,30 @@
 	}
 }
 
+
+#ifdef MAGIC_ROM_PTR
+static int
+mtdblock_romptr(kdev_t dev, struct vm_area_struct * vma)
+{
+	struct mtd_info *mtd;
+	u_char *ptr;
+	size_t len;
+
+	mtd = __get_mtd_device(NULL, MINOR(dev));
+
+	if (!mtd->point)
+		return -ENOSYS; /* Can't do it, No function to point to correct addr */
+
+	if ((*mtd->point)(mtd,vma->vm_offset,vma->vm_end-vma->vm_start,&len,&ptr) != 0)
+		return -ENOSYS;
+
+	vma->vm_start = (unsigned long) ptr;
+	vma->vm_end = vma->vm_start + len;
+	return 0;
+}
+#endif
+
+
 #if LINUX_VERSION_CODE < 0x20326
 static struct file_operations mtd_fops =
 {
@@ -573,6 +597,9 @@
 	ioctl: mtdblock_ioctl,
 	release: mtdblock_release,
 	read: block_read,
+#ifdef MAGIC_ROM_PTR
+	romptr: mtdblock_romptr,
+#endif
 	write: block_write
 };
 #else
@@ -583,6 +610,9 @@
 #endif
 	open: mtdblock_open,
 	release: mtdblock_release,
+#ifdef MAGIC_ROM_PTR
+	romptr: mtdblock_romptr,
+#endif
 	ioctl: mtdblock_ioctl
 };
 #endif
@@ -636,6 +666,8 @@
 		return -EAGAIN;
 	}
 #endif
+	DEBUG(MTD_DEBUG_LEVEL3,
+		"init_mtdblock: allocated major number %d.\n", MTD_BLOCK_MAJOR);
 	
 	/* We fill it in at open() time. */
 	for (i=0; i< MAX_MTD_DEVICES; i++) {
Index: linux-2.4.27/drivers/mtd/mtdblock_ro.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/mtdblock_ro.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/mtdblock_ro.c	2008-03-22 11:19:21.000000000 +0300
@@ -241,6 +241,30 @@
 	}
 }
 
+
+#ifdef MAGIC_ROM_PTR
+static int
+mtdblock_romptr(kdev_t dev, struct vm_area_struct * vma)
+{
+	struct mtd_info *mtd;
+	u_char *ptr;
+	size_t len;
+
+	mtd = __get_mtd_device(NULL, MINOR(dev));
+
+	if (!mtd->point)
+		return -ENOSYS; /* Can't do it, No function to point to correct addr */
+
+	if ((*mtd->point)(mtd,vma->vm_offset,vma->vm_end-vma->vm_start,&len,&ptr) != 0)
+		return -ENOSYS;
+
+	vma->vm_start = (unsigned long) ptr;
+	vma->vm_end = vma->vm_start + len;
+	return 0;
+}
+#endif
+
+
 #if LINUX_VERSION_CODE < 0x20326
 static struct file_operations mtd_fops =
 {
@@ -248,6 +272,9 @@
 	ioctl: mtdblock_ioctl,
 	release: mtdblock_release,
 	read: block_read,
+#ifdef MAGIC_ROM_PTR
+	romptr: mtdblock_romptr,
+#endif
 	write: block_write
 };
 #else
@@ -258,6 +285,9 @@
 #endif
 	open: mtdblock_open,
 	release: mtdblock_release,
+#ifdef MAGIC_ROM_PTR
+	romptr: mtdblock_romptr,
+#endif
 	ioctl: mtdblock_ioctl
 };
 #endif
@@ -271,6 +301,9 @@
 		       MTD_BLOCK_MAJOR);
 		return -EAGAIN;
 	}
+	DEBUG(MTD_DEBUG_LEVEL3,
+		"init_mtdblock: allocated major number %d (read only).\n", 
+		MTD_BLOCK_MAJOR);
 	
 	/* We fill it in at open() time. */
 	for (i=0; i< MAX_MTD_DEVICES; i++) {
Index: linux-2.4.27/drivers/mtd/mtdchar.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/mtdchar.c	2004-08-08 03:26:04.000000000 +0400
+++ linux-2.4.27/drivers/mtd/mtdchar.c	2008-03-22 11:19:21.000000000 +0300
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/mtd/mtd.h>
 #include <linux/slab.h>
+#include <asm/semaphore.h>
 
 #ifdef CONFIG_DEVFS_FS
 #include <linux/devfs_fs_kernel.h>
@@ -115,7 +116,8 @@
 /* FIXME: This _really_ needs to die. In 2.5, we should lock the
    userspace buffer down and use it directly with readv/writev.
 */
-#define MAX_KMALLOC_SIZE 0x20000
+#define MAX_KMALLOC_SIZE 0x2000
+
 
 static ssize_t mtd_read(struct file *file, char *buf, size_t count,loff_t *ppos)
 {
@@ -176,10 +178,13 @@
 	return total_retlen;
 } /* mtd_read */
 
+char *write_kbuf;
+int write_kbuf_len;
+struct semaphore write_kbuf_sem;
+
 static ssize_t mtd_write(struct file *file, const char *buf, size_t count,loff_t *ppos)
 {
 	struct mtd_info *mtd = (struct mtd_info *)file->private_data;
-	char *kbuf;
 	size_t retlen;
 	size_t total_retlen=0;
 	loff_t pos = *ppos;
@@ -526,7 +531,7 @@
 
 		
 	default:
-		DEBUG(MTD_DEBUG_LEVEL0, "Invalid ioctl %x (MEMGETINFO = %x)\n", cmd, MEMGETINFO);
+		DEBUG(MTD_DEBUG_LEVEL0, "Invalid ioctl %x (MEMGETINFO = %lx)\n", cmd, MEMGETINFO);
 		ret = -ENOTTY;
 	}
 
@@ -600,6 +605,24 @@
 	}
 #endif
 
+	/* XXX
+	 * Allocate and buffer and init spinlock.
+	 */
+	sema_init(&write_kbuf_sem, 1);
+
+	down(&write_kbuf_sem);
+	write_kbuf_len = 0x2000;
+	write_kbuf = kmalloc(write_kbuf_len, GFP_KERNEL);
+	if (!write_kbuf) {
+		write_kbuf_len = 0x0;
+		up(&write_kbuf_sem);
+		return -ENOMEM;
+	}
+	up(&write_kbuf_sem);
+	
+	DEBUG(MTD_DEBUG_LEVEL3,
+		"init_mtdchar: allocated major number %d.\n", MTD_CHAR_MAJOR);
+
 	return 0;
 }
 
Index: linux-2.4.27/drivers/mtd/nftlcore.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/nftlcore.c	2003-06-13 18:51:34.000000000 +0400
+++ linux-2.4.27/drivers/mtd/nftlcore.c	2008-03-22 11:19:21.000000000 +0300
@@ -704,25 +704,192 @@
 	return 0xffff;
 }
 
+/* Given a Virtual Unit Chain, see if it can be deleted, and if so do it. */
+static void NFTL_trydeletechain(struct NFTLrecord *nftl, unsigned thisVUC)
+{
+	unsigned char BlockUsed[MAX_SECTORS_PER_UNIT];
+	unsigned char BlockFreeFound[MAX_SECTORS_PER_UNIT];
+	unsigned int thisEUN;
+	int block;
+	unsigned int status;
+	int silly;
+	struct nftl_bci bci;
+	size_t retlen;
+
+	memset(BlockUsed, 0, sizeof(BlockUsed));
+	memset(BlockFreeFound, 0, sizeof(BlockFreeFound));
+
+	thisEUN = nftl->EUNtable[thisVUC];
+	if (thisEUN == BLOCK_NIL) {
+		printk(KERN_WARNING "Trying to delete non-existent "
+		       "Virtual Unit Chain %d!\n", thisVUC);
+		return;
+	}
+	
+	/* Scan through the Erase Units to determine whether any data is in
+	   each of the 512-byte blocks within the Chain.
+	*/
+	silly = MAX_LOOPS;
+	while (thisEUN < nftl->nb_blocks) {
+		for (block = 0; block < nftl->EraseSize/512; block++) {
+			if (BlockFreeFound[block])
+				continue;
+
+			if (MTD_READOOB(nftl->mtd,
+					(thisEUN * nftl->EraseSize) + (block * 512),
+					8 , &retlen, (char *)&bci) < 0)
+				status = SECTOR_IGNORE;
+			else
+				status = bci.Status | bci.Status1;
+
+			switch(status) {
+			case SECTOR_FREE:
+				BlockFreeFound[block] = 1;
+				break;
+			case SECTOR_USED:
+				BlockUsed[block] = 1;
+				break;
+			case SECTOR_DELETED:
+				BlockUsed[block] = 0;
+				break;
+			case SECTOR_IGNORE:
+				break;
+			default:
+				printk("Unknown status for block %d in EUN %d: %x\n",
+				       block, thisEUN, status);
+			}
+		}
+
+		if (!silly--) {
+			printk(KERN_WARNING "Infinite loop in Virtual Unit Chain 0x%x\n",
+			       thisVUC);
+			return;
+		}
+		
+		thisEUN = nftl->ReplUnitTable[thisEUN];
+	}
+
+	for (block = 0; block < nftl->EraseSize/512; block++)
+		if (BlockUsed[block])
+			return;
+
+	/* For each block in the chain free it and make it available
+	 * for future use
+	 */
+	DEBUG(MTD_DEBUG_LEVEL1, "Deleting empty VUC %d\n", thisVUC);
+	thisEUN = nftl->EUNtable[thisVUC];
+	while (thisEUN < nftl->nb_blocks) {
+		unsigned int EUNtmp;
+
+		EUNtmp = nftl->ReplUnitTable[thisEUN];
+
+		if (NFTL_formatblock(nftl, thisEUN) < 0) {
+			/* could not erase : mark block as reserved
+			 * FixMe: Update Bad Unit Table on disk
+			 */
+			nftl->ReplUnitTable[thisEUN] = BLOCK_RESERVED;
+		} else {
+			/* correctly erased : mark it as free */
+			nftl->ReplUnitTable[thisEUN] = BLOCK_FREE;
+			nftl->numfreeEUNs++;
+		}
+		thisEUN = EUNtmp;
+	}
+	
+	nftl->EUNtable[thisVUC] = BLOCK_NIL;
+}
+
+static int NFTL_deleteblock(struct NFTLrecord *nftl, unsigned block)
+{
+	u16 lastgoodEUN;
+	u16 thisEUN = nftl->EUNtable[block / (nftl->EraseSize / 512)];
+	unsigned long blockofs = (block * 512) & (nftl->EraseSize - 1);
+	unsigned int status;
+	int silly = MAX_LOOPS;
+	size_t retlen;
+	struct nftl_bci bci;
+
+	lastgoodEUN = BLOCK_NIL;
+
+	if (thisEUN != BLOCK_NIL) {
+		while (thisEUN < nftl->nb_blocks) {
+			if (MTD_READOOB(nftl->mtd, (thisEUN * nftl->EraseSize) + blockofs,
+					8, &retlen, (char *)&bci) < 0)
+				status = SECTOR_IGNORE;
+			else
+				status = bci.Status | bci.Status1;
+
+			switch (status) {
+			case SECTOR_FREE:
+				/* no modification of a sector should follow a free sector */
+				goto the_end;
+			case SECTOR_DELETED:
+				lastgoodEUN = BLOCK_NIL;
+				break;
+			case SECTOR_USED:
+				lastgoodEUN = thisEUN;
+				break;
+			case SECTOR_IGNORE:
+				break;
+			default:
+				printk("Unknown status for block %d in EUN %d: %x\n",
+				       block, thisEUN, status);
+				break;
+			}
+
+			if (!silly--) {
+				printk(KERN_WARNING "Infinite loop in Virtual Unit Chain 0x%x\n",
+				       block / (nftl->EraseSize / 512));
+				return 1;
+			}
+			thisEUN = nftl->ReplUnitTable[thisEUN];
+		}
+	}
+
+ the_end:
+	if (lastgoodEUN != BLOCK_NIL) {
+		loff_t ptr = (lastgoodEUN * nftl->EraseSize) + blockofs;
+		size_t retlen;
+
+		if (MTD_READOOB(nftl->mtd, ptr, 8, &retlen, (char *)&bci) < 0)
+			return -EIO;
+		bci.Status = bci.Status1 = SECTOR_DELETED;
+		if (MTD_WRITEOOB(nftl->mtd, ptr, 8, &retlen, (char *)&bci) < 0)
+			return -EIO;
+		NFTL_trydeletechain(nftl, block / (nftl->EraseSize / 512));
+	}
+	return 0;
+}
+
 static int NFTL_writeblock(struct NFTLrecord *nftl, unsigned block, char *buffer)
 {
 	u16 writeEUN;
 	unsigned long blockofs = (block * 512) & (nftl->EraseSize - 1);
 	size_t retlen;
 	u8 eccbuf[6];
+	char *p, *pend;
 
-	writeEUN = NFTL_findwriteunit(nftl, block);
+	/* Is block all zero? */
+	pend = buffer+512;
+	for (p=buffer; p<pend && !*p; p++);
+
+	if (p<pend) {
+		writeEUN = NFTL_findwriteunit(nftl, block);
+
+		if (writeEUN == BLOCK_NIL) {
+			printk(KERN_WARNING
+					"NFTL_writeblock(): Cannot find block to write to\n");
+			/* If we _still_ haven't got a block to use, we're screwed */
+			return 1;
+		}
 
-	if (writeEUN == BLOCK_NIL) {
-		printk(KERN_WARNING
-		       "NFTL_writeblock(): Cannot find block to write to\n");
-		/* If we _still_ haven't got a block to use, we're screwed */
-		return 1;
+		MTD_WRITEECC(nftl->mtd, (writeEUN * nftl->EraseSize) + blockofs,
+				512, &retlen, (char *)buffer, (char *)eccbuf,
+				NAND_ECC_DISKONCHIP);
+		/* no need to write SECTOR_USED flags since they are written in mtd_writeecc */
 	}
-
-	MTD_WRITEECC(nftl->mtd, (writeEUN * nftl->EraseSize) + blockofs,
-		     512, &retlen, (char *)buffer, (char *)eccbuf, NAND_ECC_DISKONCHIP);
-        /* no need to write SECTOR_USED flags since they are written in mtd_writeecc */
+	else
+		NFTL_deleteblock(nftl, block);
 
 	return 0;
 }
@@ -799,6 +966,22 @@
 	if (!nftl) return -EINVAL;
 
 	switch (cmd) {
+#if 0
+	case NFTL_IOCTL_DELETE_SECTOR: {
+		unsigned int dev;
+		int res;
+
+		if (arg >= part_table[dev].nr_sects)
+			return -EINVAL;
+		arg += part_table[MINOR(inode->i_rdev)].start_sect;
+		DEBUG(MTD_DEBUG_LEVEL3, "Waiting for mutex\n");
+		down(&nftl->mutex);
+		DEBUG(MTD_DEBUG_LEVEL3, "Got mutex\n");
+		res = NFTL_deleteblock(nftl, arg);
+		up(&nftl->mutex);
+		return res;
+	}
+#endif
 	case HDIO_GETGEO: {
 		struct hd_geometry g;
 
@@ -1060,7 +1243,7 @@
 	int i;
 
 #ifdef PRERELEASE 
-	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.87 $, nftlmount.c %s\n", nftlmountrev);
+	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.1.1.1 $, nftlmount.c %s\n", nftlmountrev);
 #endif
 
 	if (register_blkdev(MAJOR_NR, "nftl", &nftl_fops)){
Index: linux-2.4.27/drivers/mtd/redboot.c
===================================================================
--- linux-2.4.27.orig/drivers/mtd/redboot.c	2001-11-10 01:01:22.000000000 +0300
+++ linux-2.4.27/drivers/mtd/redboot.c	2008-03-22 11:19:21.000000000 +0300
@@ -34,7 +34,7 @@
 	return 1;
 }
 
-int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts)
+int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts, unsigned long fis_origin)
 {
 	int nrparts = 0;
 	struct fis_image_desc *buf;
@@ -44,20 +44,25 @@
 	size_t retlen;
 	char *names;
 	int namelen = 0;
+	char *nullname;
+	int nulllen = 0;
+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+	static char nullstring[] = "unallocated";
+#endif
 
-	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	buf = kmalloc(master->erasesize, GFP_KERNEL);
 
 	if (!buf)
 		return -ENOMEM;
 
 	/* Read the start of the last erase block */
 	ret = master->read(master, master->size - master->erasesize,
-			   PAGE_SIZE, &retlen, (void *)buf);
+			   master->erasesize, &retlen, (void *)buf);
 
 	if (ret)
 		goto out;
 
-	if (retlen != PAGE_SIZE) {
+	if (retlen != master->erasesize) {
 		ret = -EIO;
 		goto out;
 	}
@@ -75,7 +80,7 @@
 		goto out;
 	}
 
-	for (i = 0; i < PAGE_SIZE / sizeof(struct fis_image_desc); i++) {
+	for (i = 0; i < master->erasesize / sizeof(struct fis_image_desc); i++) {
 		struct fis_list *new_fl, **prev;
 
 		if (buf[i].name[0] == 0xff)
@@ -90,7 +95,11 @@
 			goto out;
 		}
 		new_fl->img = &buf[i];
-		buf[i].flash_base &= master->size-1;
+		if (fis_origin) {
+			buf[i].flash_base -= fis_origin;
+		} else {
+			buf[i].flash_base &= master->size-1;
+		}
 
 		/* I'm sure the JFFS2 code has done me permanent damage.
 		 * I now think the following is _normal_
@@ -103,42 +112,67 @@
 
 		nrparts++;
 	}
-	if (fl->img->flash_base)
+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+	if (fl->img->flash_base) {
 		nrparts++;
+		nulllen = sizeof(nullstring);
+	}
 
 	for (tmp_fl = fl; tmp_fl->next; tmp_fl = tmp_fl->next) {
-		if (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize < tmp_fl->next->img->flash_base)
+		if (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize <= tmp_fl->next->img->flash_base) {
 			nrparts++;
+			nulllen = sizeof(nullstring);
+		}
 	}
-	parts = kmalloc(sizeof(*parts)*nrparts + namelen, GFP_KERNEL);
+#endif
+	parts = kmalloc(sizeof(*parts)*nrparts + nulllen + namelen, GFP_KERNEL);
 
 	if (!parts) {
 		ret = -ENOMEM;
 		goto out;
 	}
-	names = (char *)&parts[nrparts];
-	memset(parts, 0, sizeof(*parts)*nrparts + namelen);
+
+	memset(parts, 0, sizeof(*parts)*nrparts + nulllen + namelen);
+
+	nullname = (char *)&parts[nrparts];
+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+	if (nulllen > 0) {
+		strcpy(nullname, nullstring);
+	}
+#endif
+	names = nullname + nulllen;
+
 	i=0;
 
+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
 	if (fl->img->flash_base) {
-	       parts[0].name = "unallocated space";
-	       parts[0].size = fl->img->flash_base;
-	       parts[0].offset = 0;
+		parts[0].name = nullname;
+		parts[0].size = fl->img->flash_base;
+		parts[0].offset = 0;
+		i++;
 	}
+#endif
 	for ( ; i<nrparts; i++) {
 		parts[i].size = fl->img->size;
 		parts[i].offset = fl->img->flash_base;
 		parts[i].name = names;
 
 		strcpy(names, fl->img->name);
+		if (!memcmp(names, "RedBoot", 8) ||
+				!memcmp(names, "RedBoot config", 15) ||
+				!memcmp(names, "FIS directory", 14)) {
+			parts[i].mask_flags = MTD_WRITEABLE;
+		}
 		names += strlen(names)+1;
 
-		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize < fl->next->img->flash_base) {
+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
 			i++;
 			parts[i].offset = parts[i-1].size + parts[i-1].offset;
 			parts[i].size = fl->next->img->flash_base - parts[i].offset;
-			parts[i].name = "unallocated space";
+			parts[i].name = nullname;
 		}
+#endif
 		tmp_fl = fl;
 		fl = fl->next;
 		kfree(tmp_fl);
