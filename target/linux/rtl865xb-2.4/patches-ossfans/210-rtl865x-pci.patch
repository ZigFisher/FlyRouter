Index: linux-2.4.27/arch/mips/lib/ide-no.c
===================================================================
--- linux-2.4.27.orig/arch/mips/lib/ide-no.c	2008-03-25 14:53:41.000000000 +0300
+++ linux-2.4.27/arch/mips/lib/ide-no.c	2008-03-25 14:55:36.000000000 +0300
@@ -13,20 +13,110 @@
 #include <linux/ide.h>
 #include <asm/hdreg.h>
 #include <asm/ptrace.h>
+#include "../realtek/rtl865x/pci.h"
+#define REG32(reg)	(*(volatile unsigned int *)(reg))
+#define PDC20265 0x0d30105a //device ID & vendor ID
+extern int rtl865x_isLinuxIncompliantEndianMode;
 
 static int no_ide_default_irq(ide_ioreg_t base)
 {
+	if(base) return 5;
 	return 0;
 }
 
 static ide_ioreg_t no_ide_default_io_base(int index)
 {
+	unsigned int haveIDE=0;	
+
+#ifdef CONFIG_RTL865XB_PCI_SLOT0
+	if(!rtl865x_isLinuxIncompliantEndianMode)
+	{
+		if(cpu_to_le32(REG32(PCI_SLOT0_CONFIG_BASE))==PDC20265) haveIDE=PCI_SLOT0_CONFIG_BASE;
+	}
+	else
+	{		
+		if(REG32(PCI_SLOT0_CONFIG_BASE)==PDC20265) haveIDE=PCI_SLOT0_CONFIG_BASE;	
+	}
+#endif
+
+#ifdef CONFIG_RTL865XB_PCI_SLOT1
+	if(!rtl865x_isLinuxIncompliantEndianMode)
+	{
+		if(cpu_to_le32(REG32(PCI_SLOT1_CONFIG_BASE))==PDC20265) haveIDE=PCI_SLOT1_CONFIG_BASE;
+	}
+	else
+	{
+		if(REG32(PCI_SLOT1_CONFIG_BASE)==PDC20265) haveIDE=PCI_SLOT1_CONFIG_BASE;	
+	}
+#endif
+
+#ifdef CONFIG_RTL865XB_PCI_SLOT2
+	if(!rtl865x_isLinuxIncompliantEndianMode)
+	{
+		if(cpu_to_le32(REG32(PCI_SLOT2_CONFIG_BASE))==PDC20265) haveIDE=PCI_SLOT2_CONFIG_BASE;
+	}
+	else
+	{
+		if(REG32(PCI_SLOT2_CONFIG_BASE)==PDC20265) haveIDE=PCI_SLOT2_CONFIG_BASE;	
+	}
+#endif
+
+#ifdef CONFIG_RTL865XB_PCI_SLOT3
+	if(!rtl865x_isLinuxIncompliantEndianMode)
+	{
+		if(cpu_to_le32(REG32(PCI_SLOT3_CONFIG_BASE))==PDC20265) haveIDE=PCI_SLOT3_CONFIG_BASE;
+	}
+	else
+	{
+		if(REG32(PCI_SLOT3_CONFIG_BASE)==PDC20265) haveIDE=PCI_SLOT3_CONFIG_BASE;	
+	}
+#endif
+
+	if(haveIDE)
+	{
+		if(!rtl865x_isLinuxIncompliantEndianMode)
+		{
+			switch (index) {
+				case 0:	return cpu_to_le32(REG32(haveIDE+0x10))&0xfffffffc;
+				case 1:	return cpu_to_le32(REG32(haveIDE+0x18))&0xfffffffc;
+				default:			
+					return 0;
+			}
+		}
+		else
+		{
+			switch (index) {
+				case 0:	return REG32(haveIDE+0x10)&0xfffffffc;
+				case 1:	return REG32(haveIDE+0x18)&0xfffffffc;
+				default:			
 	return 0;
+			}			
+		}
+	}
+	return 0; //only for primany ide controller
 }
 
 static void no_ide_init_hwif_ports (hw_regs_t *hw, ide_ioreg_t data_port,
                                     ide_ioreg_t ctrl_port, int *irq)
 {
+
+	ide_ioreg_t reg = data_port;
+	int i;
+	if(data_port)
+	{
+		for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+			hw->io_ports[i] = reg;
+			reg ++;
+		}
+		if (ctrl_port) {
+			hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+		} else {	
+			hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x80;
+		}
+		if (irq != NULL)
+			*irq = 0;
+		hw->io_ports[IDE_IRQ_OFFSET] = 0;
+	}
 }
 
 struct ide_ops no_ide_ops = {
Index: linux-2.4.27/arch/mips/pci/pci.c
===================================================================
--- linux-2.4.27.orig/arch/mips/pci/pci.c	2008-03-25 14:53:41.000000000 +0300
+++ linux-2.4.27/arch/mips/pci/pci.c	2008-03-25 14:55:36.000000000 +0300
@@ -129,7 +129,7 @@
 	return pcibios_enable_resources(dev, mask);
 }
 
-#ifdef CONFIG_NEW_PCI
+#if defined(CONFIG_NEW_PCI) || defined(CONFIG_RTL865X)
 /*
  * Named PCI new and about to die before it's old :-)
  *
Index: linux-2.4.27/arch/mips/realtek/rtl865x/pci.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/arch/mips/realtek/rtl865x/pci.c	2008-03-25 19:43:03.000000000 +0300
@@ -0,0 +1,277 @@
+#include <linux/config.h>
+
+/*
+ *  arch/mips/realtek/rtl865x/pci.c
+ *
+ *  Copyright (C) 2004 Hsin-I Wu (hiwu@realtek.com.tw)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+
+
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/paccess.h>
+#include <asm/pci_channel.h>
+#include <asm-mips/rtl865x/interrupt.h>
+#include "pci.h"
+
+int rtl865x_isLinuxIncompliantEndianMode=1;//Default assume 8650B
+
+
+#define REG8(offset)	(*(volatile unsigned char *)(offset))
+#define REG16(offset)	(*(volatile unsigned short *)(offset))
+#define REG32(offset)	(*(volatile unsigned long *)(offset))
+
+#define PCI_ILEV 5
+
+#define PCI_SLOT_NUMBER 4
+#if (PCI_SLOT_NUMBER < 1) || (PCI_SLOT_NUMBER > 4)
+#error "wrong range of PCI_SLOT_NUMBER, rtl865xB should between 1 and 4"
+#endif
+
+static void __init quirk_pci_bridge(struct pci_dev *dev)
+{
+
+}
+
+int rtl_pci_isLinuxCompliantEndianMode(void)
+{
+   	rtl865x_isLinuxIncompliantEndianMode=!((*(volatile unsigned int *)(0xbd012064))&2);
+	if(!rtl865x_isLinuxIncompliantEndianMode)
+		printk("PCI is LE\n");
+	else
+		printk("PCI is BE\n");
+	return ((*(volatile unsigned int *)(0xbd012064))&2);
+}
+
+//struct pci_fixup pcibios_fixups[] = {	{ PCI_FIXUP_HEADER, PCI_ANY_ID, PCI_ANY_ID, quirk_pci_bridge },	{ 0 }};
+
+
+
+/* sort resource by its size */
+void bubble_sort(int space_size[PCI_SLOT_NUMBER*8*6][2], int num)
+{
+  int i, j;
+  int tmp_swap[2];
+
+    for (i=0;i<num-1;i++) {
+    	for (j=i;j<num-1;j++) {
+          if (space_size[j][1]<space_size[j+1][1]) {
+            tmp_swap[0] = space_size[j][0];
+            tmp_swap[1] = space_size[j][1];
+            space_size[j][0] = space_size[j+1][0];
+            space_size[j][1] = space_size[j+1][1];
+            space_size[j+1][0] = tmp_swap[0];
+            space_size[j+1][1] = tmp_swap[1];
+          };
+        };
+    };
+}
+
+
+
+int rtl_pci_reset(){
+             u32 tmp, divisor, scr;
+	u32 ratio[]={5,5,4,5,4,4,3,2};//check Datasheet SCR and MACCR.
+    tmp = REG32(0xbc803000)&0xFCFF8FFF;
+    REG32(0xbc803004)=0;
+	scr=(REG32(0xbc803004)>>16)&7;
+		REG32(0xbc803000) = tmp|(1<<15);//reset PCI bridge
+             divisor=ratio[scr];
+	//patch: set PCI clk = /6
+	//divisor=5;
+    REG32(0xbc803000) = tmp|(divisor<<12);
+             return divisor;
+}
+
+
+
+
+int pcibios_enable_resources(struct pci_dev *dev)
+{
+	return 0;
+}
+
+#if 0
+static void memdump(unsigned address, unsigned length) {
+	unsigned data, currentaddress, i, j;
+	char c;
+
+	i=0;
+	printk("Memory dump: start address 0x%8.8x , length %d bytes\n\n\r",address,length);
+	printk("Address        Data\n\r");
+
+	while(i<length) {
+		currentaddress = address + i;
+		data = *(unsigned long*)(currentaddress);
+		printk("0x%8.8x:   %8.8x    ",currentaddress,data);
+		for(j=0;j<4;j++) {
+			c = (data >> 8*j) & 0xFF;
+			if(c<0x20 || c>0x7e) {
+				printk("\\%3.3d ",(int)c);
+			} else {
+				printk(" %c   ",c);
+			}
+		}
+		printk("\n\r");
+		i += 4;
+	}
+	printk("\n\rEnd of memory dump.\n\n\r");
+}
+#endif /* if 0 */
+
+/*
+ *  If we set up a device for bus mastering, we need to check the latency
+ *  timer as certain crappy BIOSes forget to set it properly.
+ *
+ *
+ */
+
+
+unsigned int pcibios_assign_all_busses(void)
+{
+	return 0;
+}
+
+
+void __init pcibios_fixup_resources(struct pci_dev *dev)
+{
+#if 1
+	int i;
+	/* Search for the IO base address.. */
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+		unsigned int io_addr = pci_resource_start(dev, i);
+		unsigned int io_size = pci_resource_len(dev, i);
+		unsigned int new_io_addr ;
+		if (!(pci_resource_flags(dev,i) & IORESOURCE_IO))
+			continue;
+		// to work around pci card with IO mappping <64K limitation
+		io_addr &= 0x000fffff;
+		io_addr |= 0x1d500000;
+
+		pci_resource_start(dev, i) = (io_addr - 0x1D010000);
+		pci_resource_end(dev, i) = (io_addr + io_size - 0x1D010000 -1 );
+		new_io_addr = pci_resource_start(dev, i);
+		printk("pcibios_fixup_resources IO form %x to %x\n",io_addr,new_io_addr);
+
+		/* Is it already in use? */
+		if (check_region (new_io_addr, io_size))
+			break;
+	}
+#endif
+}
+
+
+
+void __init pcibios_fixup(void)
+{
+	/* nothing to do here */
+}
+
+void __init pcibios_fixup_irqs(void)
+{
+	struct pci_dev *dev;
+
+	pci_for_each_dev(dev) {
+		dev->irq = 5; // fix irq
+	}
+}
+
+
+ u8 rtl865x_pci_ioread8(u32 addr){
+ 	//For legacy 8650's linux incompliant PCI access endian mode
+	if(rtl865x_isLinuxIncompliantEndianMode){
+		u8 tmp;
+		u8 swap[4]={3,2,1,0};
+		int diff = swap[addr&0x3];
+#ifdef RTL865X_PCI_DEBUG
+		printk("R8 0x%08x->", addr);
+#endif
+		addr=addr&(~0x3);
+#ifdef RTL865X_PCI_DEBUG
+		printk("0x%08x=", addr);
+#endif
+		tmp= *(volatile u8*)(addr+diff);
+#ifdef RTL865X_PCI_DEBUG
+		printk("0x%02x\n", tmp);
+#endif
+		return tmp;
+	}
+	return (*(volatile unsigned char *)(addr));
+}
+
+ u16 rtl865x_pci_ioread16(u32 addr){
+ 	//For legacy 8650's linux incompliant PCI access endian mode
+	if(rtl865x_isLinuxIncompliantEndianMode){
+		u16 tmp;
+		int diff=2-(addr&0x3);
+#ifdef RTL865X_PCI_DEBUG
+		printk("R16 0x%08x->", addr);
+#endif
+		addr=addr&(~0x3);
+#ifdef RTL865X_PCI_DEBUG
+		printk("0x%08x=", addr);
+#endif
+		tmp= *(volatile u16*)(addr+diff);
+#ifdef RTL865X_PCI_DEBUG
+		printk("0x%04x\n", tmp);
+#endif
+		return tmp;
+	}
+	return cpu_to_le16((*(volatile unsigned short *)(addr)));
+}
+
+u32 rtl865x_pci_ioread32(u32 addr){
+ 	//For legacy 8650's linux incompliant PCI access endian mode
+	if(rtl865x_isLinuxIncompliantEndianMode){
+		u32 tmp;
+		tmp= *(volatile u32*)(addr);
+		return tmp;
+	}
+	return cpu_to_le32((*(volatile unsigned int *)(addr)));
+}
+
+
+void rtl865x_pci_iowrite8(u32 addr, u8 val){
+	if(rtl865x_isLinuxIncompliantEndianMode)
+		(*(volatile unsigned char*)(addr|0xa0000000))=val;
+	else
+		(*(volatile unsigned char *)(addr|0xa0000000)) = (val);
+}
+
+ void rtl865x_pci_iowrite16(u32 addr, u16 val){
+	if(rtl865x_isLinuxIncompliantEndianMode)
+		(*(volatile unsigned short*)(addr|0xa0000000))=val;
+	else
+		(*(volatile unsigned short *)(addr|0xa0000000)) = cpu_to_le16(val);
+}
+
+ void rtl865x_pci_iowrite32(u32 addr, u32 val){
+	if(rtl865x_isLinuxIncompliantEndianMode)
+		(*(volatile unsigned long*)(addr|0xa0000000))=val;
+
+	else
+		(*(volatile unsigned long *)(addr|0xa0000000)) = cpu_to_le32(val);
+
+}
+
+EXPORT_SYMBOL(rtl865x_pci_iowrite32);
+EXPORT_SYMBOL(rtl865x_pci_iowrite16);
+EXPORT_SYMBOL(rtl865x_pci_iowrite8);
+EXPORT_SYMBOL(rtl865x_pci_ioread32);
+EXPORT_SYMBOL(rtl865x_pci_ioread16);
+EXPORT_SYMBOL(rtl865x_pci_ioread8);
+
Index: linux-2.4.27/arch/mips/realtek/rtl865x/pci.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/arch/mips/realtek/rtl865x/pci.h	2008-03-25 14:55:36.000000000 +0300
@@ -0,0 +1,53 @@
+#ifndef PCI_H
+#define PCI_H
+
+
+
+struct pci_slot_baseaddr_s {
+	u32 slotNum;
+	u32 addr;
+};
+
+#define PCI_SLOT0_CONFIG_BASE 	   0xBBD40000
+#define PCI_SLOT1_CONFIG_BASE 	   0xBBD80000
+#define PCI_SLOT2_CONFIG_BASE 	   0xBBD10000
+#define PCI_SLOT3_CONFIG_BASE 	   0xBBD20000
+
+#define PCI_SLOT_MEM_BASE 0xBBF00000
+#define PCI_SLOT_IO_BASE  0xBBE00000
+#define PCI_MEM_SPACE_SIZE 0x00100000
+#define PCI_IO_SPACE_SIZE  0x00100000
+
+//PCI configuration space
+#define PCI_CONFIG_VENDER_DEV 	0x0000
+#define PCI_CONFIG_COMMAND 	0x0004
+#define PCI_CONFIG_STATUS  	0x0006
+#define PCI_CONFIG_CLASS_REVISION  	0x0008
+#define PCI_CONFIG_CACHE  	0x000c
+#define PCI_CONFIG_LATENCY 	0x000d
+#define PCI_CONFIG_HEADER_TYPE 	0x000e
+#define PCI_CONFIG_BASE0	0x0010
+#define PCI_CONFIG_BASE1	0x0014
+#define PCI_CONFIG_BASE2	0x0018
+#define PCI_CONFIG_BASE3	0x001c
+#define PCI_CONFIG_BASE4	0x0020
+#define PCI_CONFIG_BASE5	0x0024
+#define PCI_CONFIG_SUBSYSTEMVENDOR 	0x002c
+#define PCI_CONFIG_INT_LINE	0x003c
+#define PCI_CONFIG_INT_PIN	0x003d
+#define PCI_CONFIG_MAXLAN 	0x003f
+#define PCI_CONFIG_MINGNT 	0x003e
+
+//PCI command register flag
+#define CMD_FAST_BACK_TO_BACK	 	(1<<9)
+#define CMD_SERR		 	(1<<8)
+#define CMD_STEP_CONTROL	 	(1<<7)
+#define CMD_PARITY_ERROR_RESPONSE 	(1<<6)
+#define CMD_VGA_PALLETE_SNOOP	 	(1<<5)
+#define CMD_WRITE_AND_INVALIDATE 	(1<<4)
+#define CMD_SPECIAL_CYCLE	 	(1<<3)
+#define CMD_BUS_MASTER			(1<<2)
+#define CMD_MEM_SPACE			(1<<1)
+#define CMD_IO_SPACE			(1<<0)
+
+#endif
Index: linux-2.4.27/drivers/usb/host/sys_pool.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/drivers/usb/host/sys_pool.c	2008-03-25 14:55:36.000000000 +0300
@@ -0,0 +1,429 @@
+/*
+ *	$Id$
+ *
+ *	PCI Bus Services, see include/linux/pci.h for further explanation.
+ *
+ *	Copyright 1993 -- 1997 Drew Eckhardt, Frederic Potter,
+ *	David Mosberger-Tang
+ *
+ *	Copyright 1997 -- 2000 Martin Mares <mj@ucw.cz>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/kmod.h>		/* for hotplug_path */
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/cache.h>
+
+#include <asm/page.h>
+#include <asm/dma.h>	/* isa_dma_bridge_buggy */
+struct rtl_pool {	/* the pool */
+	struct list_head	page_list;
+	spinlock_t		lock;
+	size_t			blocks_per_page;
+	size_t			size;
+	int			flags;
+	size_t			allocation;
+	char			name [32];
+	wait_queue_head_t	waitq;
+};
+
+struct rtl_page {	/* cacheable header for 'allocation' bytes */
+	struct list_head	page_list;
+	void			*vaddr;
+	dma_addr_t		dma;
+	unsigned long		bitmap [0];
+};
+
+#define	POOL_TIMEOUT_JIFFIES	((100 /* msec */ * HZ) / 1000)
+#define	POOL_POISON_BYTE	0xa7
+
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+
+
+#define	POOL_TIMEOUT_JIFFIES	((100 /* msec */ * HZ) / 1000)
+#define	POOL_POISON_BYTE	0xa7
+
+// #define CONFIG_RTLPOOL_DEBUG
+void rtl_free_consistent(size_t size, void *vaddr, dma_addr_t handle)
+{
+	unsigned long addr = (unsigned long) vaddr;
+
+	addr = addr|0xa0000000;//CAC_ADDR(addr);
+	free_pages(addr, get_order(size));
+
+}
+
+
+
+/**
+ * rtl_pool_create - Creates a pool of  consistent memory blocks, for dma.
+ * @name: name of pool, for diagnostics
+ * @size: size of the blocks in this pool.
+ * @align: alignment requirement for blocks; must be a power of two
+ * @allocation: returned blocks won't cross this boundary (or zero)
+ * @flags: SLAB_* flags (not all are supported).
+ *
+ * Returns a rtl allocation pool with the requested characteristics, or
+ * null if one can't be created.  Given one of these pools, rtl_pool_alloc()
+ * may be used to allocate memory.  Such memory will all have "consistent"
+ * DMA mappings, accessible by the device and its driver without using
+ * cache flushing primitives.  The actual size of blocks allocated may be
+ * larger than requested because of alignment.
+ *
+ * If allocation is nonzero, objects returned from rtl_pool_alloc() won't
+ * cross that size boundary.  This is useful for devices which have
+ * addressing restrictions on individual DMA transfers, such as not crossing
+ * boundaries of 4KBytes.
+ */
+void *consistent_alloc(int gfp, size_t size, dma_addr_t *dma_handle)
+{
+	void *ret;
+	gfp = GFP_ATOMIC;
+
+	ret = (void *) __get_free_pages(gfp, get_order(size));
+
+	if (ret != NULL) {
+		memset(ret, 0, size);
+		*(u32*)dma_handle = (u32)virt_to_phys(ret);
+		dma_cache_wback_inv((unsigned long) ret, size);
+		ret =(u32)ret|0xa0000000;// UNCAC_ADDR(ret);
+	}
+
+	return ret;
+
+}
+
+
+void *rtl_alloc_consistent(size_t size, dma_addr_t *dma_handle)
+{
+
+	void *ret;
+	int gfp = GFP_ATOMIC;
+	ret = (void *) __get_free_pages(gfp, get_order(size));
+
+	if (ret != NULL) {
+		memset(ret, 0, size);
+		*(u32*)dma_handle = (u32)virt_to_phys(ret);
+		dma_cache_wback_inv((unsigned long) ret, size);
+		ret =(u32)ret|0xa0000000;// UNCAC_ADDR(ret);
+		//ret = UNCAC_ADDR(ret);
+	}
+	return ret;
+
+}
+
+struct rtl_pool *
+rtl_pool_create (const char *name, size_t size, size_t align, size_t allocation, int flags)
+{
+	struct rtl_pool		*retval;
+
+	if (align == 0)
+		align = 1;
+	if (size == 0)
+		return 0;
+	else if (size < align)
+		size = align;
+	else if ((size % align) != 0) {
+		size += align + 1;
+		size &= ~(align - 1);
+	}
+
+	if (allocation == 0) {
+		if (PAGE_SIZE < size)
+			allocation = size;
+		else
+			allocation = PAGE_SIZE;
+		// FIXME: round up for less fragmentation
+	} else if (allocation < size)
+		return 0;
+
+	if (!(retval = kmalloc (sizeof *retval, flags)))
+		return retval;
+
+#ifdef	CONFIG_PCIPOOL_DEBUG
+	flags |= SLAB_POISON;
+#endif
+
+	strncpy (retval->name, name, sizeof retval->name);
+	retval->name [sizeof retval->name - 1] = 0;
+
+	//retval->dev = pdev;
+	INIT_LIST_HEAD (&retval->page_list);
+	spin_lock_init (&retval->lock);
+	retval->size = size;
+	retval->flags = flags;
+	retval->allocation = allocation;
+	retval->blocks_per_page = allocation / size;
+	init_waitqueue_head (&retval->waitq);
+
+#ifdef CONFIG_PCIPOOL_DEBUG
+	printk (KERN_DEBUG "pcipool create %s/%s size %d, %d/page (%d alloc)\n",
+		pdev ? pdev->slot_name : NULL, retval->name, size,
+		retval->blocks_per_page, allocation);
+#endif
+
+	return retval;
+}
+
+
+static struct rtl_page *
+pool_alloc_page (struct rtl_pool *pool, int mem_flags)
+{
+	struct rtl_page	*page;
+	int		mapsize;
+
+	mapsize = pool->blocks_per_page;
+	mapsize = (mapsize + BITS_PER_LONG - 1) / BITS_PER_LONG;
+	mapsize *= sizeof (long);
+
+	page = (struct rtl_page *) kmalloc (mapsize + sizeof *page, mem_flags);
+	if (!page)
+		return 0;
+	page->vaddr = rtl_alloc_consistent (
+					    pool->allocation,
+					    &page->dma);
+	if (page->vaddr) {
+		memset (page->bitmap, 0xff, mapsize);	// bit set == free
+		if (pool->flags & SLAB_POISON)
+			memset (page->vaddr, POOL_POISON_BYTE, pool->allocation);
+		list_add (&page->page_list, &pool->page_list);
+	} else {
+		kfree (page);
+		page = 0;
+	}
+	return page;
+}
+
+
+static inline int
+is_page_busy (int blocks, unsigned long *bitmap)
+{
+	while (blocks > 0) {
+		if (*bitmap++ != ~0UL)
+			return 1;
+		blocks -= BITS_PER_LONG;
+	}
+	return 0;
+}
+
+static void
+pool_free_page (struct rtl_pool *pool,struct rtl_page *page)
+{
+	dma_addr_t	dma = page->dma;
+
+	if (pool->flags & SLAB_POISON)
+		memset (page->vaddr, POOL_POISON_BYTE, pool->allocation);
+	rtl_free_consistent (pool->allocation, page->vaddr, dma);
+	list_del (&page->page_list);
+	kfree (page);
+}
+
+
+/**
+ * rtl_pool_destroy - destroys a pool of pci memory blocks.
+ * @pool: pci pool that will be destroyed
+ *
+ * Caller guarantees that no more memory from the pool is in use,
+ * and that nothing will try to use the pool after this call.
+ */
+void
+rtl_pool_destroy (struct rtl_pool *pool)
+{
+	unsigned long		flags;
+
+#ifdef CONFIG_PCIPOOL_DEBUG
+	printk (KERN_DEBUG "pcipool destroy %s/%s\n",
+		pool->dev ? pool->dev->slot_name : NULL,
+		pool->name);
+#endif
+
+	spin_lock_irqsave (&pool->lock, flags);
+	while (!list_empty (&pool->page_list)) {
+		struct rtl_page		*page;
+		page = list_entry (pool->page_list.next,
+				struct rtl_page, page_list);
+		if (is_page_busy (pool->blocks_per_page, page->bitmap)) {
+			/* leak the still-in-use consistent memory */
+			list_del (&page->page_list);
+			kfree (page);
+		} else
+			pool_free_page (pool, page);
+	}
+	spin_unlock_irqrestore (&pool->lock, flags);
+	kfree (pool);
+}
+
+
+/**
+ * rtl_pool_alloc - get a block of consistent memory
+ * @pool: pci pool that will produce the block
+ * @mem_flags: SLAB_KERNEL or SLAB_ATOMIC
+ * @handle: pointer to dma address of block
+ *
+ * This returns the kernel virtual address of a currently unused block,
+ * and reports its dma address through the handle.
+ * If such a memory block can't be allocated, null is returned.
+ */
+void *
+rtl_pool_alloc (struct rtl_pool *pool, int mem_flags, dma_addr_t *handle)
+{
+	unsigned long		flags;
+	struct list_head	*entry;
+	struct rtl_page		*page;
+	int			map, block;
+	size_t			offset;
+	void			*retval;
+
+restart:
+	spin_lock_irqsave (&pool->lock, flags);
+	list_for_each (entry, &pool->page_list) {
+		int		i;
+		page = list_entry (entry, struct rtl_page, page_list);
+		/* only cachable accesses here ... */
+		for (map = 0, i = 0;
+				i < pool->blocks_per_page;
+				i += BITS_PER_LONG, map++) {
+			if (page->bitmap [map] == 0)
+				continue;
+			block = ffz (~ page->bitmap [map]);
+			if ((i + block) < pool->blocks_per_page) {
+				clear_bit (block, &page->bitmap [map]);
+				offset = (BITS_PER_LONG * map) + block;
+				offset *= pool->size;
+				goto ready;
+			}
+		}
+	}
+	if (!(page = pool_alloc_page (pool, mem_flags))) {
+		if (mem_flags == SLAB_KERNEL) {
+			DECLARE_WAITQUEUE (wait, current);
+
+			current->state = TASK_INTERRUPTIBLE;
+			add_wait_queue (&pool->waitq, &wait);
+			spin_unlock_irqrestore (&pool->lock, flags);
+
+			schedule_timeout (POOL_TIMEOUT_JIFFIES);
+
+			current->state = TASK_RUNNING;
+			remove_wait_queue (&pool->waitq, &wait);
+			goto restart;
+		}
+		retval = 0;
+		goto done;
+	}
+
+	clear_bit (0, &page->bitmap [0]);
+	offset = 0;
+ready:
+	retval = offset + page->vaddr;
+	*handle = offset + page->dma;
+done:
+	spin_unlock_irqrestore (&pool->lock, flags);
+	return retval;
+}
+
+
+static struct rtl_page *
+pool_find_page (struct rtl_pool *pool, dma_addr_t dma)
+{
+	unsigned long		flags;
+	struct list_head	*entry;
+	struct rtl_page		*page;
+
+	spin_lock_irqsave (&pool->lock, flags);
+	list_for_each (entry, &pool->page_list) {
+		page = list_entry (entry, struct rtl_page, page_list);
+		if (dma < page->dma)
+			continue;
+		if (dma < (page->dma + pool->allocation))
+			goto done;
+	}
+	page = 0;
+done:
+	spin_unlock_irqrestore (&pool->lock, flags);
+	return page;
+}
+
+
+/**
+ * rtl_pool_free - put block back into pci pool
+ * @pool: the pci pool holding the block
+ * @vaddr: virtual address of block
+ * @dma: dma address of block
+ *
+ * Caller promises neither device nor driver will again touch this block
+ * unless it is first re-allocated.
+ */
+void
+rtl_pool_free (struct rtl_pool *pool, void *vaddr, dma_addr_t dma)
+{
+	struct rtl_page		*page;
+	unsigned long		flags;
+	int			map, block;
+
+	if ((page = pool_find_page (pool, dma)) == 0) {
+		return;
+	}
+#ifdef	CONFIG_PCIPOOL_DEBUG
+	if (((dma - page->dma) + (void *)page->vaddr) != vaddr) {
+		printk (KERN_ERR "rtl_pool_free %s/%s, %p (bad vaddr)/%x\n",
+			pool->dev ? pool->dev->slot_name : NULL,
+			pool->name, vaddr, (int) (dma & 0xffffffff));
+		return;
+	}
+#endif
+
+	block = dma - page->dma;
+	block /= pool->size;
+	map = block / BITS_PER_LONG;
+	block %= BITS_PER_LONG;
+
+#ifdef	CONFIG_PCIPOOL_DEBUG
+	if (page->bitmap [map] & (1UL << block)) {
+		printk (KERN_ERR "rtl_pool_free %s/%s, dma %x already free\n",
+			pool->dev ? pool->dev->slot_name : NULL,
+			pool->name, dma);
+		return;
+	}
+#endif
+	if (pool->flags & SLAB_POISON)
+		memset (vaddr, POOL_POISON_BYTE, pool->size);
+
+	spin_lock_irqsave (&pool->lock, flags);
+	set_bit (block, &page->bitmap [map]);
+	if (waitqueue_active (&pool->waitq))
+		wake_up (&pool->waitq);
+	/*
+	 * Resist a temptation to do
+	 *    if (!is_page_busy(bpp, page->bitmap)) pool_free_page(pool, page);
+	 * it is not interrupt safe. Better have empty pages hang around.
+	 */
+	spin_unlock_irqrestore (&pool->lock, flags);
+}
+
+
+/* Pool allocator */
+#if 0
+EXPORT_SYMBOL (rtl_pool_create);
+EXPORT_SYMBOL (rtl_pool_destroy);
+EXPORT_SYMBOL (rtl_pool_alloc);
+EXPORT_SYMBOL (rtl_pool_free);
+#endif
Index: linux-2.4.27/drivers/pci/setup-res.c
===================================================================
--- linux-2.4.27.orig/drivers/pci/setup-res.c	2008-03-25 14:53:41.000000000 +0300
+++ linux-2.4.27/drivers/pci/setup-res.c	2008-03-25 14:55:36.000000000 +0300
@@ -195,7 +195,7 @@
 	DBGC((KERN_ERR "PCI enable device: (%s)\n", dev->name));
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-
+	cmd &=~PCI_COMMAND_PARITY;
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		struct resource *res = &dev->resource[i];
 
Index: linux-2.4.27/arch/mips/realtek/rtl865x/Makefile
===================================================================
--- linux-2.4.27.orig/arch/mips/realtek/rtl865x/Makefile	2008-03-25 14:55:36.000000000 +0300
+++ linux-2.4.27/arch/mips/realtek/rtl865x/Makefile	2008-03-25 14:55:36.000000000 +0300
@@ -18,7 +18,7 @@
 #obj-y		:= int-handler.o irq.o setup.o prom.o power.o
 obj-y		:= int-handler.o irq.o setup.o prom.o 
 export-objs	:= pci.o
-obj-$(CONFIG_PCI)		+= pci.o 
+obj-$(CONFIG_PCI)		+= pci.o pci-ops.o
 
 int-handler.o: int-handler.S
 
Index: linux-2.4.27/arch/mips/realtek/rtl865x/pci-ops.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.4.27/arch/mips/realtek/rtl865x/pci-ops.c	2008-03-25 19:49:45.000000000 +0300
@@ -0,0 +1,853 @@
+/*
+ *  arch/mips/realtek/rtl865x/pci.c
+ *
+ *  Copyright (C) 2004 Hsin-I Wu (hiwu@realtek.com.tw)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+
+#include <asm/pci_channel.h>
+#include <asm-mips/rtl865x/interrupt.h>
+#include "pci.h"
+
+#define REG8(offset)	(*(volatile unsigned char *)(offset))
+#define REG16(offset)	(*(volatile unsigned short *)(offset))
+#define REG32(offset)	(*(volatile unsigned long *)(offset))
+
+#define PCI_SLOT_NUMBER 4
+#if (PCI_SLOT_NUMBER < 1) || (PCI_SLOT_NUMBER > 4)
+#error "wrong range of PCI_SLOT_NUMBER, rtl865xB should between 1 and 4"
+#endif
+
+#define rtl865x_isLinuxIncompliantEndianMode 1
+#define PCI_ILEV 5
+
+typedef struct BASE_ADDRESS_STRUCT
+{
+	u32 Address;
+	enum type_s
+	{
+		IO_SPACE=0x80,
+		MEM_SPACE
+	} Type;
+	enum width_s
+	{
+		WIDTH32,
+		WIDTH64
+	} Width;
+	u32 Prefetch;
+	u32 Size;
+} base_address_s;
+
+typedef struct PCI_CONFIG_SPACE_STRUCT
+{
+	u32 Config_Base;  /* config space base address */
+	enum status_s
+	{
+		ENABLE,
+		DISABLE
+	} Status;  /* device is enable or disable */
+	u32 Vendor_Device_ID;
+	u8 Revision_ID;
+	u32 Class_Code;
+	u8  Header_Type;
+	base_address_s BAR[6];
+	u32 SubSystemVendor_ID;
+} pci_config_s;
+
+static pci_config_s *pci_slot[PCI_SLOT_NUMBER][8];
+
+#define rtlpci_read_config_endian_free(x) REG32(x)
+#define rtlpci_write_config_endian_free(x,y) REG32(x)=y;
+
+/* scan the resource needed by PCI device */
+void scan_resource(pci_config_s *pci_config, int slot_num, int dev_function, u32 config_base)
+{
+	int i;
+	u32 BaseAddr, data;
+
+	BaseAddr = config_base+PCI_CONFIG_BASE0;
+
+	for (i=0;i<6;i++) {  //detect resource usage
+		rtlpci_write_config_endian_free(BaseAddr,0xffffffff);
+		data = rtlpci_read_config_endian_free(BaseAddr);
+
+		if (data!=0) {  //resource request exist
+			int j;
+			if (data&1) {  //IO space
+				pci_config->BAR[i].Type = IO_SPACE;
+
+				//scan resource size
+				pci_config->BAR[i].Size=((~(data&PCI_BASE_ADDRESS_IO_MASK))+1)&0xffff;
+				printk("IO Space %i, data=0x%x size=0x%x \n",i,data,pci_config->BAR[i].Size);
+			}
+			else {  //Memory space
+				pci_config->BAR[i].Type = MEM_SPACE;
+				//bus width
+				if ((data&0x0006)==4) pci_config->BAR[i].Width = WIDTH64; //bus width 64
+				else pci_config->BAR[i].Width = WIDTH32;  //bus width 32
+				//prefetchable
+				if (data&0x0008) pci_config->BAR[i].Prefetch = 1; //prefetchable
+				else pci_config->BAR[i].Prefetch = 0;  //no prefetch
+				//scan resource size
+				if (pci_config->BAR[i].Width==WIDTH32) {
+					for (j=4;j<32;j++) if (data&(1<<j)) break;
+					if (j<32) pci_config->BAR[i].Size = 1<<j;
+					else  pci_config->BAR[i].Size = 0;
+				} else //width64 is not support
+				{
+					pci_config->BAR[i].Size = 0;
+				}
+				printk("Memory Space %i data=0x%x size=0x%x\n",i,data,pci_config->BAR[i].Size);
+			}
+		} else {  //no resource
+			memset(&(pci_config->BAR[i]), 0, sizeof(base_address_s));
+		}
+		BaseAddr += 4;  //next base address
+	}
+}
+
+/* scan the PCI bus, save config information into pci_slot,
+return the number of PCI functions */
+
+int rtl_pci_scan_slot(void)
+{
+	u32 config_base, data, vendor_device;
+	int i, dev_function;
+	int dev_num = 0;
+	u16 device, vendor, last_ok_func;
+
+	for (i=0;i<PCI_SLOT_NUMBER;i++) {  //probe 2 pci slots
+
+		if((REG32(0xbc805104)&0x00ff0000)<0x00020000) // RTL865XB verA,verB
+		{
+#ifndef CONFIG_RTL865XB_PCI_SLOT0
+			if(i==0) continue;
+#endif
+#ifndef CONFIG_RTL865XB_PCI_SLOT1
+			if(i==1) continue;
+#endif
+#ifndef CONFIG_RTL865XB_PCI_SLOT2
+			if(i==2) continue;
+#endif
+#ifndef CONFIG_RTL865XB_PCI_SLOT3
+			if(i==3) continue;
+#endif
+		}
+		// this delay is necessary to
+		// work around pci configuration timing issue
+		config_base = 0;
+
+		while(config_base < 3000000){
+			config_base++;
+		}
+		switch(i){
+			case 0:
+				config_base = PCI_SLOT0_CONFIG_BASE;
+				break;
+			case 1:
+				config_base = PCI_SLOT1_CONFIG_BASE;
+				break;
+			case 2:
+				config_base = PCI_SLOT2_CONFIG_BASE;
+				break;
+			case 3:
+				config_base = PCI_SLOT3_CONFIG_BASE;
+				break;
+			default:
+				return 0;
+		}
+		dev_function=0;
+//  	  printk("timeout=%x base=%x\n",REG32(0xbd012004),config_base+PCI_CONFIG_VENDER_DEV);
+//  	  printk("timeout=%x\n",REG32(0xbd012004));
+		vendor_device= rtlpci_read_config_endian_free(config_base+PCI_CONFIG_VENDER_DEV);
+		vendor=vendor_device&0xffff;
+		device=vendor_device>>16;
+		last_ok_func=0;
+		while (dev_function<8) {  //pci device exist
+			if((REG32(0xbc805104)&0x00ff0000)>=0x00020000) // RTL865XB verC and above
+			{
+				int match=1;
+				REG32(0xbd012064)&=0x8fffffff;
+				rtlpci_read_config_endian_free(config_base+PCI_CONFIG_VENDER_DEV);
+				if(vendor==0x13f6) // C-media
+					REG32(0xbc805038)|=0x80000000;	//enable 16bit mode
+				if(dev_function>0)
+				{
+					int j;
+					for(j=0;j<64;j+=4)
+						if(rtlpci_read_config_endian_free(config_base+j)!=rtlpci_read_config_endian_free(config_base+j-(dev_function-last_ok_func)*0x100)) match=0;
+				}
+				else
+				{
+					match=0;
+				}
+				if(((REG32(0xbd012004)&0x00210000)!=0)||(match==1))
+				{
+					REG32(0xbd012004)=REG32(0xbd012004); //clear the timeout register
+					//printk("BusTimeout Clear Register 0xbd012004=%x fun=%d\n",REG32(0xbd012004),dev_function);
+					dev_function++;
+					config_base += 256;
+					continue;
+				}
+				else
+				{
+					printk("using SLOT:%d, FUNCTION:%d\n",i,dev_function);
+					last_ok_func=dev_function;
+				}
+
+	  }
+	  else // RTL865XB verA,verB
+	  {
+
+	  switch(vendor)
+	  {
+	  	case 0x17a0: //Genesys
+	      	if(!((dev_function==0)||(dev_function==3)) )
+      		{
+      			goto next_func;
+      		}
+	  		printk("Found Genesys USB 2.0 PCI Card!, function=%d!\n",dev_function);
+			//REG32(config_base+0x50)&=(0xffffffef);
+	      	break;
+		case PCI_VENDOR_ID_AL: //ALi
+		    if(dev_function>3)
+      		{
+      			goto next_func;
+      		}
+	  		printk("Found ALi USB 2.0 PCI Card, function=%d!\n",dev_function);
+	      	break;
+		case PCI_VENDOR_ID_VIA: //0x1106
+	      	if(dev_function>2)
+      		{
+      			goto next_func;
+      		}
+	  		printk("Found VIA USB 2.0 PCI Card!, function=%d!\n",dev_function);
+	      	break;
+
+		case PCI_VENDOR_ID_NEC: //0x1033
+	      	if(dev_function>2)
+      		{
+      			goto next_func;
+      		}
+	  		printk("Found NEC USB 2.0 PCI Card, function=%d!\n",dev_function);
+	      	break;
+
+		case PCI_VENDOR_ID_REALTEK:
+			if(dev_function>0) ////assume realtek's chip only have one function.
+			{
+				if((device==0x8139)||(device==0x8185))
+				{
+					goto next_func;
+				}
+			}
+			if(device==0x8139)
+		  		printk("Found Realtek 8139 PCI Card, function=%d!\n",dev_function);
+			else if(device==0x8185)
+		  		printk("Found Realtek 8185 PCI Card, function=%d!\n",dev_function);
+			break;
+
+		case 0x168c: // Atheros
+			if(dev_function>0) //assume atheros's chip only have one function.
+			{
+				//if(device==0x0013)
+				{
+					goto next_func;
+				}
+			}
+			if(device==0x0013)
+				printk("Found Atheros AR5212 802.11a/b/g PCI Card, function=%d!\n",dev_function);
+			else if(device==0x0012)
+				printk("Found Atheros AR5211 802.11a/b PCI Card, function=%d!\n",dev_function);
+			else
+				printk("Found Atheros unknow PCI Card, function=%d!\n",dev_function);
+			break;
+	    case 0x13f6: // C-Media
+	    	REG32(0xbc805038) |= 0x80000000;
+	    	if(dev_function>0) //assume atheros's chip only have one function.
+			{
+					goto next_func;
+			}
+			break;
+	    case 0x17cb: //Airgo
+	    	if(dev_function>0) //assume atheros's chip only have one function.
+			{
+					goto next_func;
+			}
+			break;
+		case 0x1814: //Ralink
+	    	if(dev_function>0) //assume atheros's chip only have one function.
+			{
+					goto next_func;
+			}
+			break;
+		case PCI_VENDOR_ID_PROMISE: //0x105a
+	      	if(dev_function>0)
+      		{
+next_func:
+      			dev_function++;
+      			config_base += 256;
+      			continue;
+      		}
+	  		printk("Found Promise IDE PCI Card, function=%d!\n",dev_function);
+      	break;
+
+      	default:
+      		break;
+	  	}
+	  }
+
+   		  if ((0==rtlpci_read_config_endian_free(config_base+PCI_CONFIG_VENDER_DEV))||
+   		  	  ((rtlpci_read_config_endian_free(config_base+PCI_CONFIG_VENDER_DEV)&0xffff)==0xffff))
+   		  {
+		  	dev_function++;
+        	  config_base += 256;  //next function's config base
+        	  continue;
+   		 }
+
+          pci_slot[i][dev_function] = kmalloc(sizeof(pci_config_s),GFP_KERNEL);
+          pci_slot[i][dev_function]->Config_Base = config_base;
+          pci_slot[i][dev_function]->Status = DISABLE;
+          pci_slot[i][dev_function]->Vendor_Device_ID = rtlpci_read_config_endian_free(config_base+PCI_CONFIG_VENDER_DEV);
+          data = rtlpci_read_config_endian_free(config_base+PCI_CONFIG_CLASS_REVISION);
+          pci_slot[i][dev_function]->Revision_ID = data&0x00FF;
+          pci_slot[i][dev_function]->Class_Code = data>>8;
+          pci_slot[i][dev_function]->Header_Type = (rtlpci_read_config_endian_free(config_base+PCI_CONFIG_CACHE)>>16)&0x000000FF;
+          pci_slot[i][dev_function]->SubSystemVendor_ID = rtlpci_read_config_endian_free(config_base+PCI_CONFIG_SUBSYSTEMVENDOR);
+          scan_resource(pci_slot[i][dev_function], i, dev_function, config_base);  //probe resource request
+
+			printk("PCI device exists: slot %d function %d VendorID %x DeviceID %x %x\n", i, dev_function,
+				pci_slot[i][dev_function]->Vendor_Device_ID&0x0000FFFF,
+				pci_slot[i][dev_function]->Vendor_Device_ID>>16,config_base);
+			dev_num++;
+			dev_function++;
+			////config_base += dev_function*64*4;  //next function's config base
+			config_base += 256;  //next function's config base
+			//if (!(pci_slot[i][0]->Header_Type&0x80)) break;  //single function card
+			if (dev_function>=8) break;  //only 8 functions allow in a PCI card
+		}
+	}
+
+	return dev_num;
+}
+
+/* scan pci bus, assign Memory & IO space to PCI card,
+	and call init_XXXX to enable & register PCI device
+	rtn 0:ok, else:fail */
+int rtl_pci_init(void)
+{
+	int function_num;
+	u32 tmp, divisor, scr;
+	tmp=rtl_pci_isLinuxCompliantEndianMode();
+	printk("NEW PCI Driver...isLinuxCompliantEndianMode=%s\n",(tmp==2)?"True(Little Endian)":"False(Big Endian)");
+	rtl_pci_reset();
+#if 0
+	printk("SLOT 0: %x\n", REG32(PCI_SLOT0_CONFIG_BASE));
+	printk("SLOT 1: %x\n", REG32(PCI_SLOT1_CONFIG_BASE));
+	printk("SLOT 2: %x\n", REG32(PCI_SLOT2_CONFIG_BASE));
+	printk("SLOT 3: %x\n", REG32(PCI_SLOT3_CONFIG_BASE));
+	printk("REG32(0xbd012004)&0x10000=%x\n",REG32(0xbd012004)&0x10000);
+#endif
+
+	memset(pci_slot, 0, 4*PCI_SLOT_NUMBER*8);
+	function_num = rtl_pci_scan_slot();
+
+	if (function_num==0) {
+		printk("No PCI device exist!!\n");
+		return -1;
+	};
+	//auto assign resource
+	if (rtl_pci_assign_resource()) {
+		printk("PCI Resource assignment failed!\n");
+		return -2;
+	};
+
+	printk("Find Total %d PCI functions\n", function_num);
+	return 0;
+}
+
+/*	assign memory location to MEM & IO space
+	return 0:OK, else:fail */
+int rtl_pci_assign_resource(void)
+{
+	int i, slot, func, BARnum;
+	int mem_space_size[PCI_SLOT_NUMBER*8*6][2]; //[0]:store device index, [1]:store resource size
+	int io_space_size[PCI_SLOT_NUMBER*8*6][2]; //[0]:store device index, [1]:store resource size
+	int mem_idx, io_idx, total_size, tmp;
+	u16 config_command[PCI_SLOT_NUMBER][8];  	//record config space resource usage,
+
+#if defined(CONFIG_RTL865XB_PCI_SLOT2)||defined(CONFIG_RTL865XB_PCI_SLOT3)
+	printk("PCI: PCI slot 2/3 inuse. Config GPIOA pins for PCI use\n");
+	REG32(0xbd012054)|=0xf0000000;
+	REG32(0xbd01200c)|=0xf0000000;
+#endif
+	memset(mem_space_size, 0, sizeof(mem_space_size));
+	memset(io_space_size, 0, sizeof(io_space_size));
+	memset(config_command, 0, sizeof(config_command));
+
+	//collect resource
+	mem_idx = io_idx =0;
+	for (slot=0;slot<PCI_SLOT_NUMBER;slot++) {
+
+	if((REG32(0xbc805104)&0x00ff0000)<0x00020000) // RTL865XB verA,verB
+	{
+#ifndef CONFIG_RTL865XB_PCI_SLOT0
+		if(slot==0) continue;
+#endif
+#ifndef CONFIG_RTL865XB_PCI_SLOT1
+		if(slot==1) continue;
+#endif
+#ifndef CONFIG_RTL865XB_PCI_SLOT2
+		if(slot==2) continue;
+#endif
+#ifndef CONFIG_RTL865XB_PCI_SLOT3
+		if(slot==3) continue;
+#endif
+	}
+
+	if (pci_slot[slot][0]==0) continue;  //this slot is null
+	if (pci_slot[slot][0]->Vendor_Device_ID==0) continue;  //this slot is null
+	for (func=0;func<8;func++) {
+		if (pci_slot[slot][func]==0) continue;
+		pci_slot[slot][func]->Status = ENABLE;
+    		for (BARnum=0;BARnum<6;BARnum++) {
+      		if (pci_slot[slot][func]->BAR[BARnum].Type == MEM_SPACE) {  //memory space
+      			printk("memory mapping BAnum=%d slot=%d func=%d\n",BARnum,slot,func);
+			config_command[slot][func] |= CMD_MEM_SPACE;  //this device use Memory
+      		    mem_space_size[mem_idx][0] = (slot<<16)|(func<<8)|(BARnum<<0);
+      		    mem_space_size[mem_idx][1] = pci_slot[slot][func]->BAR[BARnum].Size;
+				mem_idx++;
+      		} else if (pci_slot[slot][func]->BAR[BARnum].Type == IO_SPACE) {  //io space
+	      		printk("io mapping BAnum=%d slot=%d func=%d\n",BARnum,slot,func);
+      		    config_command[slot][func] |= CMD_IO_SPACE;  //this device use IO
+      		    io_space_size[io_idx][0] = (slot<<16)|(func<<8)|(BARnum<<0);
+      		    io_space_size[io_idx][1] = pci_slot[slot][func]->BAR[BARnum].Size;
+				io_idx++;
+			}
+      		else
+      		{
+//      			printk("unknow mapping BAnum=%d slot=%d func=%d\n",BARnum,slot,func);
+		}
+	    }  //for (BARnum=0;BARnum<6;BARnum++)
+      }  //for (func=0;func<8;func++)
+    } //for (slot=0;slot<PCI_SLOT_NUMBER;slot++)
+
+	//sort by size
+    if (mem_idx>1) bubble_sort(mem_space_size, mem_idx);
+    if (io_idx>1)  bubble_sort(io_space_size, io_idx);
+
+    //check mem total size
+    total_size = 0;
+    for (i=0;i<mem_idx;i++) {
+    	tmp = mem_space_size[i][1]-1;
+        total_size = (total_size+tmp)&(~tmp);
+        total_size = total_size + mem_space_size[i][1];
+	};
+    if (total_size>PCI_MEM_SPACE_SIZE) {
+	printk("lack of memory map space resource \n");
+	return -1;  //lack of memory space resource
+    }
+
+    //check io total size
+    total_size = 0;
+    for (i=0;i<io_idx;i++) {
+    	tmp = io_space_size[i][1]-1;
+        total_size = (total_size+tmp)&(~tmp);
+        total_size = total_size + io_space_size[i][1];
+    }
+
+    if (total_size>PCI_IO_SPACE_SIZE)
+    {
+	printk("lack of io map space resource\n");
+		return -2;  //lack of io space resource
+    }
+
+
+	//assign memory space
+    total_size = 0;
+	for (i=0;i<mem_idx;i++) {
+    	unsigned int config_base;
+    	tmp = mem_space_size[i][1]-1;
+        total_size = (total_size+tmp)&(~tmp);
+        tmp = mem_space_size[i][0];
+
+        //assign to struct
+        if (pci_slot[(tmp>>16)][(tmp>>8)&0x00FF]->BAR[tmp&0x00FF].Type!= MEM_SPACE)
+        	continue;
+
+        pci_slot[(tmp>>16)][(tmp>>8)&0x00FF]->BAR[tmp&0x00FF].Address = PCI_SLOT_MEM_BASE+total_size;
+     	switch((tmp>>16)){
+     	case 0:
+     		config_base = PCI_SLOT0_CONFIG_BASE;
+     		break;
+     	case 1:
+     		config_base = PCI_SLOT1_CONFIG_BASE;
+     		break;
+     	case 2:
+     		config_base = PCI_SLOT2_CONFIG_BASE;
+     		break;
+     	case 3:
+     		config_base = PCI_SLOT3_CONFIG_BASE;
+     		break;
+     	default:
+     		panic("PCI slot assign error");
+    	}
+        //get BAR address and assign to PCI device
+        tmp = config_base   //SLOT
+              +((tmp>>8)&0x00FF)*64*4					//function
+              +((tmp&0x00FF)*4+PCI_CONFIG_BASE0);			//BAR bumber
+//        REG32(tmp) = (PCI_SLOT_MEM_BASE+total_size)&0x1FFFFFFF;  //map to physical address
+        rtlpci_write_config_endian_free(tmp,(PCI_SLOT_MEM_BASE+total_size)&0x1FFFFFFF);
+        printk("assign mem base %x~%x at %x size=%d\n",(PCI_SLOT_MEM_BASE+total_size)&0x1FFFFFFF,((PCI_SLOT_MEM_BASE+total_size)&0x1FFFFFFF)+mem_space_size[i][1]-1,tmp,mem_space_size[i][1]);
+
+        total_size = total_size + mem_space_size[i][1];  //next address
+	};
+    //assign IO space
+    total_size = 0;
+    for (i=0;i<io_idx;i++) {
+    	unsigned int config_base;
+    	tmp = io_space_size[i][1]-1;
+        total_size = (total_size+tmp)&(~tmp);
+        tmp = io_space_size[i][0];
+        //assign to struct
+        if (pci_slot[(tmp>>16)][(tmp>>8)&0x00FF]->BAR[tmp&0x00FF].Type!= IO_SPACE)
+			continue;
+
+        pci_slot[(tmp>>16)][(tmp>>8)&0x00FF]->BAR[tmp&0x00FF].Address = PCI_SLOT_IO_BASE+total_size;
+        //get BAR address and assign to PCI device
+     	switch((tmp>>16)){
+     	case 0:
+     		config_base = PCI_SLOT0_CONFIG_BASE;
+     		break;
+     	case 1:
+     		config_base = PCI_SLOT1_CONFIG_BASE;
+     		break;
+     	case 2:
+     		config_base = PCI_SLOT2_CONFIG_BASE;
+     		break;
+     	case 3:
+     		config_base = PCI_SLOT3_CONFIG_BASE;
+     		break;
+     	default:
+     		panic("PCI slot assign error");
+    	}
+        tmp = config_base   //SLOT
+              +((tmp>>8)&0x00FF)*64*4					//function
+              +((tmp&0x00FF)*4+PCI_CONFIG_BASE0);			//BAR bumber
+
+			// REG32(tmp) = (PCI_SLOT_IO_BASE+total_size)&0x1FFFFFFF;  //map to physical address
+			rtlpci_write_config_endian_free(tmp,(PCI_SLOT_IO_BASE+total_size)&0x1FFFFFFF);
+			printk("assign I/O base %x~%x at %x size=%d\n",(PCI_SLOT_IO_BASE+total_size)&0x1FFFFFFF,((PCI_SLOT_IO_BASE+total_size)&0x1FFFFFFF)+io_space_size[i][1]-1,tmp,io_space_size[i][1]);
+			total_size += io_space_size[i][1];  //next address
+		}
+		//enable device
+		for (slot=0;slot<PCI_SLOT_NUMBER;slot++) {
+			if((REG32(0xbc805104)&0x00ff0000)<0x00020000) // RTL865XB verA,verB
+			{
+	#ifndef CONFIG_RTL865XB_PCI_SLOT0
+				if(slot==0) continue;
+	#endif
+	#ifndef CONFIG_RTL865XB_PCI_SLOT1
+				if(slot==1) continue;
+	#endif
+	#ifndef CONFIG_RTL865XB_PCI_SLOT2
+				if(slot==2) continue;
+	#endif
+	#ifndef CONFIG_RTL865XB_PCI_SLOT3
+				if(slot==3) continue;
+	#endif
+			}
+
+			if (pci_slot[slot][0]==0) continue;  //this slot is null
+			if (pci_slot[slot][0]->Vendor_Device_ID==0) continue;  //this slot is null
+			for (func=0;func<8;func++) {
+				unsigned int config_base;
+				if (pci_slot[slot][func]==0) continue;  //this slot:function is null
+				if (pci_slot[slot][func]->Vendor_Device_ID==0) continue;  //this slot:function is null
+//get config base address
+				switch(slot) {
+					case 0:
+						config_base = PCI_SLOT0_CONFIG_BASE;
+						break;
+					case 1:
+						config_base = PCI_SLOT1_CONFIG_BASE;
+						break;
+					case 2:
+						config_base = PCI_SLOT2_CONFIG_BASE;
+						break;
+					case 3:
+						config_base = PCI_SLOT3_CONFIG_BASE;
+						break;
+					default:
+						panic("PCI slot assign error");
+				}
+
+				tmp = config_base + func*64*4;
+				//set Max_Lat & Min_Gnt, irq
+				//printk("1 REG32(tmp+PCI_CONFIG_INT_LINE) = %x\n",REG32(tmp+PCI_CONFIG_INT_LINE));
+				//REG32(tmp+PCI_CONFIG_INT_LINE) = 0x40200100|(PCI_ILEV); //IRQ level
+				rtlpci_write_config_endian_free(tmp+PCI_CONFIG_INT_LINE,0x40200100|(PCI_ILEV));
+				//printk("2 REG32(tmp+PCI_CONFIG_INT_LINE) = %x\n",REG32(tmp+PCI_CONFIG_INT_LINE));
+				//enable cache line size, lantancy
+				//REG32(tmp+PCI_CONFIG_CACHE) = (REG32(tmp+PCI_CONFIG_CACHE)&0xFFFF0000)|0x2004;  //32 byte cache, 20 latency
+				//printk("(REG32(tmp+PCI_CONFIG_CACHE)&0xFFFF0000)|0x2004=%x\n",(REG32(tmp+PCI_CONFIG_CACHE)&0xFFFF0000)|0x2004);
+				rtlpci_write_config_endian_free(tmp+PCI_CONFIG_CACHE,(rtlpci_read_config_endian_free(tmp+PCI_CONFIG_CACHE)&0xFFFF0000)|0x2004);
+
+				//set command register
+				//REG32(tmp+PCI_CONFIG_COMMAND) = (REG32(tmp+PCI_CONFIG_COMMAND)&0xFFFF0000)|config_command[slot][func]
+				//	|CMD_BUS_MASTER|CMD_WRITE_AND_INVALIDATE|CMD_PARITY_ERROR_RESPONSE;
+				// this delay is necessary to
+				// work around pci configuration timing issue
+				config_base = 0;
+				while(config_base < 1000){
+				config_base++;
+			}
+			REG16(tmp+PCI_CONFIG_COMMAND) = config_command[slot][func]
+			|CMD_BUS_MASTER|CMD_PARITY_ERROR_RESPONSE;//|CMD_WRITE_AND_INVALIDATE;
+		};
+	};
+	return 0;
+}
+
+static int rtlpci_read_config_byte(struct pci_dev *dev, int where, u8 *value)
+{
+	u32 tmp;
+	u32 addr;
+	u32 shift=3-(where & 0x3);
+
+	if(PCI_FUNC(dev->devfn) >= 8) return PCIBIOS_FUNC_NOT_SUPPORTED;
+	if(PCI_SLOT(dev->devfn) >= PCI_SLOT_NUMBER) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)] == NULL)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Status != ENABLE)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	addr = pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Config_Base;
+
+	if(addr == 0) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if (dev->bus->number != 0)
+	{
+		*value = 0;
+		return PCIBIOS_SUCCESSFUL;
+	}
+
+	addr |= (where&~0x3);
+	tmp = REG32(addr);
+	for (addr=0;addr<(3-shift);addr++)
+	tmp = tmp >>8;
+	*value = (u8)tmp;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int rtlpci_read_config_word(struct pci_dev *dev, int where, u16 *value)
+{
+
+	u32 tmp,addr;
+
+	if(PCI_FUNC(dev->devfn) >= 8) return PCIBIOS_FUNC_NOT_SUPPORTED;
+	if(PCI_SLOT(dev->devfn) >= PCI_SLOT_NUMBER) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)] == NULL)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Status != ENABLE)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	addr = pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Config_Base;
+
+	if(addr == 0) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if (dev->bus->number != 0)
+	{
+		*value = 0;
+		return PCIBIOS_SUCCESSFUL;
+	}
+
+	addr |= (where&~0x3);
+
+	if(rtl865x_isLinuxIncompliantEndianMode)
+	{
+		tmp=REG32(addr);
+	if (where&0x2)
+			*value = (u16)(tmp>>16);
+		else
+			*value = (u16)(tmp);
+	}
+	else
+	{
+		tmp=REG32(addr);
+		if(where&0x2)
+			*value=le16_to_cpu((u16)(tmp));
+		else
+			*value=le16_to_cpu((u16)(tmp>>16));
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int rtlpci_read_config_dword(struct pci_dev *dev, int where, u32 *value)
+{
+	u32 addr;
+
+
+	if(PCI_FUNC(dev->devfn) >= 8) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(PCI_SLOT(dev->devfn) >= PCI_SLOT_NUMBER) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)] == NULL)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Status != ENABLE)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	addr = pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Config_Base;
+
+	if(addr == 0) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if (dev->bus->number != 0)
+	{
+		*value=0;
+		return PCIBIOS_SUCCESSFUL;
+	}
+
+	*value = REG32(addr+where);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int rtlpci_write_config_byte(struct pci_dev *dev, int where, u8 value)
+{
+	u32 tmp;
+	u32 addr;
+	u32 shift=(where & 0x3);
+
+
+	if(PCI_FUNC(dev->devfn) >= 8) return PCIBIOS_FUNC_NOT_SUPPORTED;
+	if(PCI_SLOT(dev->devfn) >= PCI_SLOT_NUMBER) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)] == NULL)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Status != ENABLE)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	addr = pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Config_Base;
+	if(addr == 0) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if (dev->bus->number != 0)
+		return PCIBIOS_SUCCESSFUL;
+
+	u32 newval=(u32)value,mask=0xff;
+	addr |= (where&0xfffffffc);
+	tmp = REG32(addr);
+	newval <<= (8*(shift));
+	mask <<= (8*(shift));
+	REG32(addr)=(tmp&(~mask))|newval;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int rtlpci_write_config_word(struct pci_dev *dev, int where, u16 value)
+{
+	u32 addr;
+
+	if(PCI_FUNC(dev->devfn) >= 8) return PCIBIOS_FUNC_NOT_SUPPORTED;
+	if(PCI_SLOT(dev->devfn) >= PCI_SLOT_NUMBER) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)] == NULL)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Status != ENABLE)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	addr = pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Config_Base;
+
+	if(addr == 0) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if (dev->bus->number != 0)
+		return PCIBIOS_SUCCESSFUL;
+
+	{
+		u32 tmp;
+		addr |= (where&0xfffffffc);
+		tmp = REG32(addr);
+		if(where&2)
+			REG32(addr)=(tmp&0xffff)|(((u32)(value)<<16));
+		else
+			REG32(addr)=(tmp&0xffff0000)|((u32)(value));
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int rtlpci_write_config_dword(struct pci_dev *dev, int where, u32 value)
+{
+	u32 addr;
+
+	if(PCI_FUNC(dev->devfn) >= 8) return PCIBIOS_FUNC_NOT_SUPPORTED;
+	if(PCI_SLOT(dev->devfn) >= PCI_SLOT_NUMBER) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)] == NULL)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if(pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Status != ENABLE)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	addr = pci_slot[PCI_SLOT(dev->devfn)][PCI_FUNC(dev->devfn)]->Config_Base;
+
+	if(addr == 0) return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	if (dev->bus->number != 0)
+		return PCIBIOS_SUCCESSFUL;
+
+	REG32(addr+where)=value;
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops pcibios_ops = {
+	rtlpci_read_config_byte,
+	rtlpci_read_config_word,
+	rtlpci_read_config_dword,
+	rtlpci_write_config_byte,
+	rtlpci_write_config_word,
+	rtlpci_write_config_dword
+};
+
+#define PCI_IO_START      0x1be00000
+#define PCI_IO_END        0x1befffff
+#define PCI_MEM_START     0x1bf00000
+#define PCI_MEM_END       0x1bffffff
+
+static struct resource pci_io_resource = {
+	"pci IO space",
+	PCI_IO_START,
+	PCI_IO_END,
+	IORESOURCE_IO
+};
+
+static struct resource pci_mem_resource = {
+	"pci memory space",
+	PCI_MEM_START,
+	PCI_MEM_END,
+	IORESOURCE_MEM
+};
+
+struct pci_channel mips_pci_channels[] = {
+	{&pcibios_ops, &pci_io_resource, &pci_mem_resource, 0, 1},
+	{ NULL, NULL, NULL, 0, 0}
+};
+
